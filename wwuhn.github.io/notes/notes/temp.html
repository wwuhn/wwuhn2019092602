世间万物可以数字化，进一步，可以比特化。
用足够多的比特位来表示不同类别的事物。
分类是理解和认识世界的一种很重要的方式。
数据类型是所有编程语言所使用的一种语法机制。
不同类型确定不同的编码方式、不同的取值范围、不同的运算操作。
比特化方便硬件实现、其对应的布尔运算、逻辑运算、电路实现简单、可靠。但一串串的比特位太过抽象晦涩。正像摩尔斯电码、盲文一样，
现象世界的数字、字符、图像、音频、视频需要编码：
I 以补码方式存储整数；
II 通过ASCII编码方式存储字符；
III 以real-4或real-8方式存储浮点数（实数或小数）；
开关晶体管是比特位的硬件实现。
代码和数据在存储到内存中，由控制器通过取指令、解码指令（操作码+地址码），产生控制信号、从内存存取数据，由运算器执行布尔操作。
内存单元以一种线性关系排列，8个位做为一个字节，做为基本的存储单位，对应一个内存地址，不同的数据类型根据其取值范围的不同，需要不同长度的字节数，如double类型就使用8个字节，虽然包含有8个内存单元地址，但只用首地址来表示这一个数据。这个首地址我们一般不直接使用，而是用一个名字来表示，如果规定这个空间不被修改，只读，只被访问，这样的名字就称为常量，如果规定这个空间可以被修改，这样的名字称为变量。变量\常量与内存地址的对应关系由编译器与操作系统完成，一个变量\常量名就代表一块内存空间，在表达式中可以出现在表达式的左端或右端，出现在右端时表示引用内存空间解码后的数据值，出现在左端表示初始化或修改这块内存空间的值（常量初始化后即不能被修改）。
一个变量对应两个值：
I 地址值，由变量名显示表示；
II 数据值，即比特位按编码方式的解码；
double varName;
8个字节，首地址用varName表示，其初始化、赋值、存取用real-4或real-8编码方案。
varName出现在赋值表达式的左边时，用其地址值，表示对这一块内存空间的初始化或修改；
varName出现在赋值表达式的右边时，用其数据值，表示对这一块内存空间的比特码解码为double数据；
使用&data可以取得其地址，*(&varName)可以引用data地址对应的数据值，*(&varName)==varName。
varName隐藏了地址的复杂性和抽象性，但同时也丧失的地址本身的线性关系。
在编程中，有以下一些情况需要（或更有优势）显式地使用内存单元地址。
1 相同数据类型的数据顺序存储时。
如需要60个double类型的数据，使用60个变量名吗？显然不合适，如果利用地址的线性关系，用首地址来表示容纳这60个变量的空间，每一个变量都可以考虑通过地址偏移去访问；
2 函数参数的传值，如果除了传数据值以外，还可以传其地址值，可以增加函数的功能，能修改函数的外部数据，且传地址值不再需要开辟额外的内存空间并赋值，当数据量较大时，有更佳的效率。
3 另一种存储方式（链式存储）的实现，顺序存储有其优势，但也有不足的地方，当数据量较大时，很可能找不到这样一块内存空间而分配内存失败，且插入、删除元素时，操作效率较低。
存取的一个原则就是“存得进去，取得出来。”现实世界中东西的存取与内存的存取有异曲同工之处。如果你有60个东西要存储，但找不到这么大的空间，你可以分空间存储，依次在每一个位置放置一个下一个位置的地址即可顺藤摸瓜找到全部。数据在内存中的链式存储也是一样，单个数据元素再扩充一个地址，这个地址依次指向下一个位置，就可实现“存得进去、取得出来。”
4 动态存储的实现，静态数据需要在编译前（即编码阶段）确定数据元素的数量，而不是用一个变量来灵活实现实际需要，显然这样比较笨拙。程序可以向操作系统申请数量不等的内存空间，并返回一个地址。
5 效率
一个数组如果存放6000个名字，如果要等长实现这些名字，则有空间的浪费，如果存储6000个地址，用这些地址去访问对应的名字，则不等长也可以实现。
怎样显示地使用一个内存单元的地址？
上面提到，一个变量对应两个值：
I 地址值，由变量名显示表示；
II 数据值，即比特位按编码方式的解码；
如果这个数据值解析为地址，那这个变量就是一个存储地址的变量了，这样的变量在C++中就叫指针变量。
指针变量对应的两个址都是地址值，一个是其本身的地址，一个是其值是一个地址值，这个地址值指向另外一个内存单元空间。指向的内存单元空间可以按数据类型解析。（如果指向的数据类型还是一个地址，则这个指针变量称为双重指针）
有了指针，以上6种情况就有更好的方案：
1 数组实现线性顺序存储，数组名就是首地址，使用[]就可以实现地址偏移；
2 用指针作为函数参数；（C++还可以用引用为为函数参数实现传址）；
3 链表实现；
4 动态存储、动态数据的实现；
5 指针数组存储批量不等长字符串。




有上百种语言面向.NET Framework，所以.NET开发人员有一个巨大的语言库供他们使用。.NET Framework在设计时就考虑到语言的交互操作，所以这些语言可以彼此通信，在解决编程问题时可以相互借鉴各种语言的优势。开发人员可以选择正确的语言工具来完成任务。
使用正确的语言
选择一种语言和平台并拼命地练习以满足解决问题的需要，这种方式已经一去不复返了。有时不同的钉子需要不同的锤子。
编程语言广义上可以分为命令式、声明式、动态式、函数式。
1 命令式语言
传统的命令式语言描述了执行的方式，而不是执行的内容。命令式语言从一开始就设计为提供机器码的抽象级别。
命令式语言的语句主要是操作程序的状态。面向对象的语言就是经典的状态操作器，因为它们一直在创建和改变对象。VB、C、C++、C#都是命令式语言。
这些语言都非常擅长利用类型系统和对象描述现实世界中的情形。它们都非常严格－即编译器要进行许多安全检查。安全检查（或类型合理性）表示，不能轻易地把Cow类型变成Sheep类型，所以如果在方法的签名中声明需要一个Cow类型，编译器（和运行时）就要保证不会给方法传送Sheep类型。这些语言通常有奇异的重用机制－用多态性原则编写的代码很容易抽象出来。这样其他地方的代码，从同一模块到完全不同的项目，就可以利用已编写好的代码。
2 声明式语言
声明式语言描述了执行的内容，而不是执行方式（这与命令式语言相反，命令式语言描述了如何通过程序语句操作状态）。为人所熟知的声明式语言是HTML，它描述了页面的布局，需要的字体、文本和修饰，以及在哪里显示图像。另一个经典的声明式语言是SQL，它描述了要从关系数据库提取的内容。最近的一个声明式语言例子是XAML(eXtensible Application Markup Language），它引出了一大串基于XML的声明式语言。
声明式语言擅长描述和转换数据。多年来，我们从命令式语言中调用它们来检索和操作数据。
动态语言
动态语言包括具有“动态”特性的所有语言，如后期绑定和调用、REPL（Read Eval Print Loops）、鸭子类型化（不严格的类型化，即如果对象看起来像一只鸭子，行走起来也像一只鸭子，它就一定是一只鸭子）等。
动态语言一般会尽可能把编译的操作推迟到运行时执行。
像这样的方法编译有一些有趣副作用。如果类型不需要事先完全定义（因为类型系统非常灵活），就可以编写使用严格接口（例如，COM或者其他.NET程序集）代码，使这些代码在遇到该接口的失败时有很大的灵活性。
动态语言非常适合于快速建立原型，不必事先定义类型，就可以把注意力集中在解决问题的代码上，而不是集中在实现过程中的类型约束。REPL允许逐行编写原型代码，程序中的变化会立即反映出来，而不需要把时间浪费在编译－运行－调试循环上。
Python语言是一个经典的动态语言，Ruby也是。
函数式语言
函数式语言把计算看成数学函数，它们努力避免状态操作，而主要考虑函数的结果，以此作为解决问题的基础。如果读者以前做过微积分，那么就会很熟悉函数式编程的理论。
因为函数式编程语言一般不操作状态，所以程序中生成的副作用就小很多。这意味着这类语言一直在执行并行算法。高度并行系统的圣杯是避免重叠“无意中”的状态操作。死锁、竟态条件以及被破坏的不变量都是没有同步状态操作代码的经典问题。通过线程、共享内存以及锁来并行编程和同步都非常困难，所以为什么不一起避免？因为函数式编程语言鼓励程序员编写无状态的算法，这样编译器就可以推断出代码的自行并行性。这意味着可以利用多核处理器的强大能力，而没有管理线程、锁和共享内存的巨大负担。
函数式程序是很简洁的，与命令式语言相比，函数式语言通常需要较少的代码就可以解决问题。代码较少一般意味着bug较少，要测试的区域也较少。


transbot.blog.163.com
transbot.ys168.com
http://transbot.ys168.com
https://pan.baidu.com/s/lyd43w

<p>&lt;stdio> standard;</p>

<p>dsp: project</p>

<p>dsw: workbook</p>

<p>API: Application Program Interface</p>

<p>MFC: Microsoft Foundation Class</p>

<p>HWND: Handle Window</p>

<p>WM_PAINT: Window Message</p>

<p>DC: Device context</p>

<p>AFX Application frame work</p>

<p>GDI: Graphic Device Interface</p>

<p>DC: Device Context</p>

<p>ON_BN_CLICKED: Button</p>

<p>IDC_: ID of Control</p>

<p>IDD_: ID of Dialog</p>

<p>LPCT: Long Pointer Const TCHAR STRing.</p>

<p>CDialog: Class</p>

<p>HWND: handle of window</p>

<p>m_hWnd: member variable of handle of window</p>

<p>HKey: handle of Key</p>

<p>stdafx: Standard Application Framework Extensions（标准应用程序框架的扩展）。</p>

<p>sz:零终止的字符串</p>

<p>lp:long类型的指针；</p>

<p>m_hWnd：member of window's handle</p>

<p><a href="梢青奈 http://m.caocaocao1.com/vod-7675.html"></a></p>

<p><a href="波多野结衣 http://m.caocaocao1.com/vod-7900.html"></a></p>

<p><a href="小野寺梨纱 http://m.caocaocao1.com/vod-8300.html"></a></p>

<p>xlsm: module</p>

<p>\n: newline</p>

<p>vlookup：vertical</p>

<p>CDialogEx(): Extensible</p>

<p>cout: character</p><p>int main(int argc, char* argv[]) count, value</p><p>刨根问底，探究背后的原理，上升到理论的高度。</p><p>批处理自动建立的more.html文件本身不是utf-8格式的，在github下打开会是乱码，不管有没有声明utf-8格式。其用记事本打开是ANSI格式，用notepad++打开是GB2312格式。</p><p></p><p>如果批处理添加一行utf-8格式声明，本地用浏览器打开会是乱码？用notepad++打开也是乱码，显示gb2312，与声明的utf-8矛盾，而用记事本打开正常，显示ANSI格式。</p><p></p><p>Github下的文本本身必须是utf-8编码，不管有无有此utf-8声明。</p>