<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>摘录PCnotes</title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop属
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrower{
border-collapse:collapse;
}
#tbrower td{


border:1px #ccc solid;
padding:2px;
}
</style></head><body onload="downn();">
<div>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	//if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	//}
</script>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a><a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a></div>
<div id="container">
<script>
	goTopEx();
</script>


<p>临时对象的开销比局部对象小些。</p>

<p>编译器从模板生成一个特定的类或函数的过程称为模板的实例化。</p>

<p>如果这个指针变量需要定义为只读，即不能再另有指向，同时由编译器实现自动解引用，也就像使用一个变量一样来引用地址指向的值，则这样的指针变量在C++里称为引用，引用可以理解为一个变量的别名。</p>

<p>对象的列表初始化方法，大大提升了C++中object初始化语法的简易化程序。</p>

<p>并非所有类型都需要销毁实例，它牵涉应用程序的资源管理，主要在有动态内存需要释放时。</p>

<p>动态多态：纵向多态；函数重载和模板：横向多态；</p>
<hr />


<p>C++大胆地运用了类型修正符(type modifier），对原型进行一些修改和限制。主要包括：const、volatile、mutable</p>

<p>const用于规定变量的不可修改性；</p>

<p>mutable用于成员变量，指当声明一个const对象时，如果某个成员是mutable属性的，则该成员变量可以被修改，但是整体的“常量性”不变。</p>

<p>volatile是指当一个变量被优化存储到寄存器中时，在不断从寄存器中调用时，可能在内存中有对其修改，但没有同步更新的寄存器，volatile是告诉编译器，不能优化存储到寄存器中，以免出现更新不同步的错误。</p>

<p>类是一等公民：类实例可以作为函数的参数和返回值，可以在内存的任何域中出现：堆、栈、全程变量区。</p>
<hr />


<p>Objects contain their own data and algorithms.</p>

<p>The concept object include class and instance.</p>

<p>Polymorphism is A single name can have multiple meanings depending on its context.</p>
<p>所谓多态，简单地讲，就是指一个名字（或符号）具有多种含义。</p>
<p>Escape sequences tell the compiler to treat characters in a special way.</p>
<h4>variable</h4>
<p>variables are names for memory locations, instead of a series a number of a address.</p>

<p>We can  write a value in them;</p>

<p>We can change the value stored there;</p>

<p>We cannot erase the memory location;</p>

<p>Some value is always there;</p>
<hr />



<p>Result of an operator depends on the types of operands:</p>

<p>If both operands are int, the result is int;</p>

<p>If one or both operands are double, the result is double;</p>

<p>Binary operators with equal precedence are performed left to right</p>

<p>Unary operators of equal precedence are performed right to left</p>
<hr />

<p>Pointers "point" to a variable by telling where the variable is located</p>

<p>Sequential Containers are containers where the ultimate position of the element depends on where it was inserted, not on its value. </p>

<p>Container Adapters use the sequential containers for storage, but modify the user interface to stack, queue or other structure. </p>
<h4>异常</h4>
<p>如何处理一个异常，取决于该异常的类型。这与重载函数的参数匹配有些相似，但又有所不同。</p>

<p>重载函数可能有多个参数，而捕捉异常时的参数只有一个；其次，处理异常之后不会像调用函数那样返回异常的发生处。异常处理严重影响语句的运行顺序。</p>

<p>当有多个catch语句时，所发生的异常会按顺序与之匹配，一旦匹配成功就进入异常处理，不再与剩余的catch语句继续配对。</p>

<p>在异常处理中，有一种方法可以与所有的异常匹配，那就是使用catch (…)。</p>

<p>除了系统能够抛出异常外，用户也可以抛出异常。用户抛出的异常也可以被捕捉并处理。</p>

<p>抛出异常使用throw语句，它可以出现在任何函数体内。其语法格式为：</p>

<p>	throw 表达式;</p>

<p>如果throw抛出的异常没有被捕捉处理，则也会导致程序退出。</p>

<p>容器使用了一种叫“空间配置器”的东西，能够自动进行存储空间的申请、扩容和释放。</p>





<p>try语句括起一个测试块，其中含有可能出错的语句。如果有异常发生，则会抛出特定类型的异常。</p>

<p>每一个catch语句是一个异常处理器，相当于一个带参数的函数，功能是对指定异常类型进行处理。</p>

<p>一旦一个异常信号被抛出，那么与这个信号有相同类型参数的catch子句会捕获这个异常并处理。处理完成后整个异常处理流程结束。</p>
<hr />

<p>true和false是字面常量标识符，并不是字符串</p>
<p>形参：变量声明，实参用来初始化形参，分配内存，存储一个普通值或地址值；</p>

<p>函数返回值：临时变量，存储一个普通值或地址值；</p>

<p><h4>常量对象</h4></p>

<p>const关键字可以约束普通变量，也可以约束一个对象，使之成为常量对象。例如：</p>

<p>const Rectangle rect(3, 4);</p>

<p>这样一来，对象rect的所有属性都是不可修改的，除非某个属性被说明成是mutable。</p>

<p>常量对象不是很常见。最容易出现的一个场合是函数返回对象的值这一情况。这个返回的对象被编译器自动约束成为常量对象。另一个经常使用常量对象（引用）的场合是对象作为函数的参数。</p>

<p>与无约束对象一样，可以调用常量对象的成员函数来完成某项操作。但这可能带来潜在的错误：这个成员函数可能会修改对象的属性。</p>
<hr />

<p>类中的枚举成员不属于对象，而是该类的所有对象共享的。因此，对枚举成员的访问必须采用名字限定的方式进行。例如：</p>

<p>    Quadrangle::ID id = Quadrangle::RECTANGLE; //OK</p>

<p>     id = SQUARE;  //error</p>

<p>同样地，如果枚举定义被放在非公有段中，以上访问如果发生在Quadrangle类之外就是非法的。</p>
<hr />

<p>声明和定义包括</p>

<p>1 变量的声明和定义</p>

<p>2 函数的声明和定义</p>

<p>3 类型的声明和定义</p>

<p>继承性是对象之间合作的另一种方式(另两种方式是友元类和对象作成员)，派生类继承了基类，一个派生类对象除了可以包含基类对象，这一点和对象作成员类似，派生类还可以继承基类中的成员， 派生类对象可以在类外直接使用继承的基类公有成员。</p>

<p>类既可看作模块又可看作类型，继承的引入使这两种观点更加明显，从模块和类型两个角度来仔细考察继承的意义。</p>

<p><h4>一个成员函数什么时候需要声明为虚函数呢？主要考虑以下几点：</h4></p>

<p>首先考虑成员函数所在的类是否会做为基类。然后看成员函数在类的继承后有无功能被修改？如果希望修改其功能，一般将它声明为虚函数。</p>

<p>如果成员函数在类被继承之后功能不需要修改，或派生类中用不到该函数，则不要把它声明为虚函数。</p>

<p>应当考虑对成员函数的调用是通过对象名还是基类指针或引用去访问。如果通过基类指针或引用去访问，则声明为虚函数。</p>

<p>如果希望通过基类指针或者引用访问派生类成员函数，但基类功能比较抽象或者不能确定功能，可以将基类定义为抽象类，即只定义函数名字，没有函数体，具体功能由派生类添加。</p>

<p>对象销毁时（离开对象的作用域后），需要调用析构函数。在多态调用时，是用基类的指针访问派生类的对象。如果析构函数是非虚函数，则基类指针只能访问基类的析构函数，而不能访问派生类的析构函数，导致派生类对象销毁时，没有调用派生类的析构函数，只是调用了基类的析构函数。如果把析构函数定义成虚函数，则可克服这个问题。其实就是通过virtual这个定义在析构函数前的关键字，告诉编译器，需要调用子类的析构函数做析构。</p>
<hr />

<p>C++从C语言继承过来，但是我们的Bjarne博士更具有先见之明，他为了避免受到C语言的局限性，参考了很多的语言，例如：从Simula继承了类的概念，从Algol68继承了运算符重载、引用以及在任何地方声明变量的能力，从BCPL获得了//注释，从Ada得到了模板、名字空间，从Ada、Clu和ML取来了异常。</p>
<h4>隐式类型转换、类的隐式类型转换</h4>
<p>C++的内部数据类型遵循隐式类型转换规则。假设某个表达市中使用了一个短整型变量，而编译器根据上下文认为这儿需要是的长整型，则编译器就会根据类型转换规则自动把它转换成长整型，这种隐式转换出现在赋值、参数传递、返回值、初始化和表达式中。我们也可以为类提供相应的转换规则。</p>
<p>对一个类建立隐式转换规则需要构造一个转换函数，该函数作为类的成员，可以把该类的对象和其他数据类型的对象进行相互转换。声明了转换函数，就告诉了编译器，当根据句法判定需要类型转换时，就调用函数。</p>
<p>有两种转换函数。一种是转换构造函数;另一种是成员转换函数。需要采用哪种转换函数取决于转换的方向。</p>
<hr />

<p>派生类应当向基类的构造函数传递参数</p>
<p>在c++语言程序中，对象之间的相互通信通过调用成员函数实现。</p>
<p>类的成员函数可以访问全部数据成员，类的对象却只能访问公共成员。</p>
<p>cin是C++预定义的标准输入流对象</p>
<p>多态类中的虚函数表是Compile-Time，还是Run-Time时建立的</p>
<p>虚拟函数表是在编译期就建立了，各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的，这是实现多态的关键。</p>
<p>malloc是库函数，不在编译器控制范围之内；new是运算符，在编译器控制范围之内。 ? </p>
<p>调用malloc时，从堆中申请内存；调用new时，从堆中申请内存并为内存调用构造函数。</p>
<p>C++中为什么用模板类。</p>
<p>(1) 可用来创建动态增长和减小的数据结构</p>
<p>(2) 它是类型无关的，因此具有很高的可复用性。</p>
<p>(3) 它在编译时而不是运行时检查数据类型，保证了类型安全。</p>
<p>(4) 它是平台无关的，有可移植性。</p>
<p>(5) 可用于基本数据类型。</p>

<h4>默认参数</h4>
<p>可以为参数指定默认值，在函数调用时没有指定与形参相对应的实参时就自动使用默认值。默认参数可以简化复杂函数的调用。</p>
<p>默认参数通常在函数名第一次出现在程序中的时候，如在函数原型中，指定默认参数值。指定默认参数的方式从语法上看与变量初始化相似。例如： void myfunc(int x=0,int y=1); 如果一个函数中有多个参数，则默认参数应从右至左逐个定义。</p>
<p>在对函数进行重载时，不允许为其指定缺省参数，同时，对于重载的函数原型间不允许有类型完全相同的参数列表，对于返回类型，在重载时没有特别的要求。</p>
<p>class B:virtual public A{}虚函数的使用方法是在基类用virtual声明成员函数为虚函数。</p>
<p>类模板是一系列相关类的模板，类成员组成相同，成员函数的源代码形式相同，所不同的是所针对的类型。类模板的成员函数都是模板函数，在用类模板定义对象时，由于没有像函数实参表这样的额外信息渠道，因此无法按函数模板的方式省略模板实参。但可以为类模板的参数设置默认值。</p>
<p>在c++语言中，数据封装要解决的问题是防止不同模块之间数据的非法访问</p>

<h4>构造函数</h4>
<p>派生类构造函数要负责调用基类的构造函数</p>
<p>C++本身就规定创建子类对象的时，先调用基类的构造函数，然后再调用自己类的构造函数。当我们的基类没有自己定义构造函数时候（就是系统默认的构造函数）时。创建子类对象会先默认调用基类的默认构造函数 。但是，当我们的基类自己定义了构造函数，（可能定义了很多个）此时不会再自动生产默认构造。但是它不知道应该调用基类中的哪个构造，所以需要手动指定。</p>
<p>在释放派生类对象时，析构函数函数的执行顺序是：先执行派生类的析构函数，然后执行成员对象的析构函数，最后执行基类的析构函数。</p>
<p>C++本身就规定创建子类对象的时，先调用基类的构造函数，然后再调用自己类的构造函数。当我们的基类没有自己定义构造函数时候（就是系统默认的构造函数）时。创建子类对象会先默认调用基类的默认构造函数 <https://www.baidu.com/s?wd=%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao>。但是，当我们的基类自己定义了构造函数，（可能定义了很多个）此时不会再自动生产默认构造。但是它不知道应该调用基类中的哪个构造，所以需要手动指定。(如果基类定义了无参的构造函数，派生类可以不在构造函数的参数列表中调用基类的构造函数)</p>
<p>当没有显式调用指定形式的构造函数。系统自动调用无参构造函数，如果没有为类指定此构造函数，则系统自动为其生成一个最简单的无参构造函数。</p>
<hr />

<p>当自加运算符做后缀表达式的时候，表达式的值不变，只有变量的值增1</p>
<p>C++语言中的类是可以组成层次结构的，类是用于描述事物的属性和对事物的操作，类与类之间有相对的独立性，但其可以通过一些方法进行信息的通信。</p>
<p>C++中类的成员对象比类的对象先初始化。</p>
<p>C++中产生虚基类的作用就是为了解决继承中的二义性问题，通过虚基类继承可以把父基类中相同的函数只编译一次。</p>
<p>友元函数是独立于当前类的外部函数，但它可以访问该类的所有对象的成员；拷贝构造函数是使用已存在的对象初始化正在生成的对象时调用的成员函数。</p>
<p>在C++语言中，所有的函数都是平行的，即在定义函数时是互相独立的，一个函数并不从属于另一个函数，即函数不能嵌套定义，但可以互相调用。但是不能调用main()函数。</p>
<p>关连容器：数据成员有序；</p>
<p>map成员是pair类对象。</p>
<p>set成员是基本类型或自定义类型；大小比较可自定义函数，也有缺省的默认函数less，也就是<；如果类型是自定义类型，需要这个类型重载<运算符。</p>
<p>派生类的构造函数的成员初始化列中，不能包含基类的子对象初始化;。</p>

<p>要使引用pr代表变量char * p；，则pr应初始化为 char*& pr = p; 。</p>
<p>friend Sample operator+( Sample &s1, Sample &s2);//二元运算符，两个参数则是非成员函数，一个参数则是成员函数</p>
<p>Sample operator+( Sample &s); //二元运算符，两个参数则是非成员函数，一个参数则是成员函数</p>
<p>当没有显式调用指定形式的构造函数。系统自动调用无参构造函数，如果没有为类指定此构造函数，则系统自动为其生成一个最简单的无参构造函数。</p>
<p>在C++语言程序中，对象之间的相互通信通过调用成员函数实现。</p>
<hr />

<p>派生类初始化三部分内容：</p>
<p></p>
<p>1 新增内嵌对象以外的数据成员</p>
<p>2 新增的内嵌对象；</p>
<p>3 基类数据成员（不包括基类内嵌对象）；</p>
<p>第二和第三在初始化列表中调用构造完成；</p>
<p>在参数表中包含上述三类参数的实参；</p>
<hr />

<p>要实现函数重载，需要使用不同形参列表为同一函数编写不同的定义。</p>
<p>在已有作用域中创建的作用域就是嵌套作用域；</p>
<p>默认拷贝构造函数按成员逐项进行复制可能导致对象的浅拷贝，这时副本对象的指针数据成员与原始对象的指针数据成员指向相同的内存块。深拷贝是指对象的副本与原始对象没有共享的内存块。默认赋值运算符成员函数只提供按成员逐项进行的复制。</p>

<h4>virtual析构函数</h4>
<p>如果类中有虚函数，那么也应当将析构函数声明为虚函数。然而，有些程序员认为，为了安全起见，总是应当将析构函数声明为虚函数。因为当有多继承时，基类的析构函数定义为virtual时，编译器才会产生自动调用子类析构函数的行为。</p>
<p>派生类中有资源需要回收，而在编程中采用多态，由基类的指针指向派生类，则在释放的时候，如果基类的析构函数不是virtual，则派生类的析构函数得不到释放</p>

<p>C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p><p>文字量、常量和需要类型转换的参数都可以传递给const&参数，但不能传递给非const的引用参数。也就是说对非const引用参数不允许做类型转换。</p>
<p>检查字符串s中是否包含字符串t，若包含，则返回并输出t在s中的开始位置（下标值），否则返回-1。请将程序补充完整。</p>
<pre>
#include&lt;iostream>
using namespace std;
int main()
{
	int i,j,k;
	char s[20]="Today is sunday!",t[10]="sun";
	for(i=0;s[i]!='\0';i++)
	{
		for(j=i,k=0; t[k]!='\0'&&s[j] == t[k];j++,k++);
		if(t[k]=='\0')
		{
			cout&lt;&lt;"t在s中的开始位置下标为:"&lt;&lt;i&lt;&lt;endl;
			return i;
		}
	}
	return -1;
}
</pre>
<p>字符串字面量在C中具有数组类型char[N]，在C++中则为const char[N]，在表达式中当发生数组到指针的转换时，对应的等效指针类型分别是char*和const char*，因此，在C中，char *p = “ABCDEF”是合法的，但让人惊奇的是，上述语句在C++中也是合法的！看起来一个pointer to const char指针被赋予了pointer to char指针，似乎违反了C++中指针转换的more cv-qualified原则。其实字符串字面量在C++中存在两种转换，一种转换依据当前上下文环境，另一种遵循数组到指针的转换。</p>
<p>文件操作：建立流（C的流指针与C++的流对象），让一个文件与之相关联，如C的open函数，c++的open方法或直接初始化时附加一个路径。建立关联也称为打开文件，取消关联也称为关闭文件；</p>
<p>强类型的C++的泛型，除了使用模板，函数重载以外，还有类型方面的泛化，如void、variant、union。</p>
<p>At the language level, C++ represents  interfaces by declarations.</p>
<p>Exceptions report errors found at run time. If an error can be found at compile time, it is usually  preferable to do so. That’s what much of the type system and the facilities for specifying the interfaces  to user-defined types are for.</p>
<p>Concrete classes – especially classes with small representations – are much like built-in types: we  define them as local variables, access them using their names, copy them around, etc. Classes in  class hierarchies are different: we tend to allocate them on the free store using new, and we access  them through pointers or references.</p>
<p>Now each object is owned by a unique_ptr that will delete the object when it is no longer needed,  that is, when its unique_ptr goes out of scope.</p>
<p>If a constructor acquires a resource, its class needs a destructor to release the resource;</p>
<p>Use dynamic_cast where class hierarchy navigation is unavoidable;</p>
<p>Use dynamic_cast to a reference type when failure to find the required class is considered a failure; </p>
<p>Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative; </p>
<p>Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new;</p>
<p>constructor taking a single argument defines a conversion from its argument type.</p>
<p>explicit Vector(int s); // no implicit conversion from int to Vector</p>
<p>The && means "rvalue reference" and is a reference to which we can bind an rvalue. The word  "rvalue" is intended to complement "lvalue," which roughly means "something that can appear on  the left-hand side of an assignment." So an rvalue is – to a first approximation – a value that you  can’t assign to, such as an integer returned by a function call. Thus, an rvalue reference is a reference  to something that nobody else can assign to, so we can safely "steal" its value.</p>
<p>&&的意思是“右值引用”，是一个我们可以绑定右值的引用。“rvalue”这个词是对“lvalue”的补充，它大致意思是“可以出现在赋值左侧的某个值”。因此，rvalue是——对于第一个近似值——一个不能赋值的值，例如函数调用返回的整数。因此，右值引用是对其他人无法分配的对象的引用，因此我们可以安全地“窃取”它的值。</p>
<p>a move constructor allows an object to move simply and cheaply from one  scope to another.</p>
<p>That way, objects that we cannot or would not want to copy out of a scope can be  simply and cheaply moved out instead.</p>
<p>Do not copy data from an unbounded source to a  fixed-length array.</p>
<p>The code or text segment includes instructions and read-only data.</p>
<p>Guarantee that storage for strings has sufficient  space for character data and the null terminator.(bounds-checking)</p>
<p>mistakes using the basic_string class include</p>
<p>Using an invalidated or uninitialized iterator</p>
<p>Passing an out-of-bounds index</p>
<p>Using an iterator range that really is not a range</p>
<p>Passing an invalid iterator position</p>
<p>Never use gets(). Because it is impossible to tell without knowing the data  in advance how many characters gets() will read, and because gets() will  continue to store characters past the end of the buffer, it is extremely dangerous  to use. It has been used to break computer security.</p>
<p>The C Standard fgets() function has similar behavior to gets(). The  fgets() function accepts two additional arguments: the number of characters  to read and an input stream. When stdin is specified as the stream, fgets()  can be used to simulate the behavior of gets().</p>
<p>array and string the problems of security: buffer overflow and bounds checking. operator =、[], string-handling function,and basc_string class's iterator, gets() replaced by fgets() or getchar(), strcpy() with strncpy().</p>
<p>The gets_s() function accepts an additional  argument, rsize_t, that specifies the maximum number of characters to  input. An error condition occurs if this argument is equal to zero or greater  than RSIZE_MAX or if the pointer to the destination character array is NULL. If  an error condition occurs, no input is performed and the character array is  not modified. Otherwise, the gets_s() function reads, at most, one less than  the number of characters specified, and a null character is written immediately  after the last character read into the array.</p>
<p>The behavior of the getline() function is similar to that of fgets() but offers  several extra features. </p>
<p></p>
<p>First, if the input line is too long, rather than truncating  input, the function resizes the buffer using realloc(). </p>
<p>Second, if successful, it  returns the number of characters read, which is useful in determining whether  the input has any null characters before the newline. The getline() function  works only with buffers allocated with malloc(). If passed a null pointer,  getline() allocates a buffer of sufficient size to hold the input. As such, the user  must explicitly free() the buffer later. </p>
<p>the strncpy() function is not guaranteed to null-terminate the  destination string, the programmer must be careful to ensure that the destination  string is properly null-terminated without overwriting the last character.</p>
<p>一般情况下，重载输入（输出）运算符函数不能是类的成员函数。因为如果一个运算符函数是类的成员，则其左运算数就应当是调用运算符函数的类的对象，而此点是无法改变的。</p>
<p>重载输入（输出）运算符时，其左边的参数是流，而右边参数是类的对象。因此重载输入（输出）运算符函数必须是非成员函数－而用友元函数。</p>
<p>Templates offer compile-time ‘‘duck typing’’;</p>
<p>No significant program is written in just a bare programming language. First, a set of libraries is  developed. These then form the basis for further work.</p>
<p>In addition to the standard-library components, most implementations offer ‘‘graphical user  interface’’ systems (GUIs), Web interfaces, database interfaces, etc.</p>
<p>确保你的编译器支持Regex，如果你的编译器是GCC-4.9.0或者VS2013以下版本，请升级后，再使用。</p>
<p>In <fstream>, the standard library provides streams to and from a file:</p>
<p></p>
<p>ifstreams for reading from a file</p>
<p></p>
<p>ofstreams for writing to a file</p>
<p></p>
<p>fstreams for reading from and writing to a file</p>
<p>ofstream ofs {"target"}; // ‘‘o’’ for ‘‘output’’</p>
<p>if (!ofs)</p>
<p>error("couldn't open 'target' for writing");</p>
<p>Testing that a file stream has been properly opened is usually done by checking its state.</p>
<p>ifstream ifs {"source"}; // ‘‘i’’ for ‘‘input’’</p>
<p>if (!ifs)</p>
<p>error("couldn't open 'source' for reading");</p>
<p>Assuming that the tests succeeded, ofs can be used as an ordinary ostream (just like cout) and ifs can be used as an ordinary istream (just like cin).</p>
<p>Use cout for normal output and cerr for errors;</p>
<p>运算符函数重载：将指定的运算表达式转化为对运算符函数的调用，运算对象转化为运算符函数的实参。</p>
<p>the equivalent information represented as a  pointer plus offsets.</p>
<p>程序库：头文件（库函数原型，由编译器来做类型检查）+库文件（函数实现，由链接器链接，将代码复制到可执行文件中）。</p>
<p></p>
<p>VC++提供了一个名为comment的指令，它可以搭配lib选项给链接器发送一个特定信息，以链接特定的程序库。因此头文件中的代码：</p>
<p></p>
<p>#pragma comment(lib, "mylib")</p>
<p></p>
<p>将告知链接器链接程序库mylib。一般来说，最好使用项目管理工具，比如nmake或者MSBuild，用于确保将正确的程序库链接到项目中。</p>
<p></p>
<p>大部分C运行时库是以如下方式实现的，在一个静态库或者动态链接库中编译函数，然后在头文件中声明函数原型。开发人员在链接器命令行中提供了程序库，通常还将为该程序库引用头文件，以便编译器能够访问函数原型。只要链接器能够识别该程序库，就可以在项目代码中输入其函数原型（将它定义为外部链接，以便告知编译器函数是在其他地方定义的）。这样可以省去将某些大型文件引入到源代码中的麻烦，因为这些文件中很有可能包含大量不会用到的函数原型。</p>
<p>If you have a class hierarchy that relies on virtual functions to get polymorphic behavior, do not store objects directly in a container.  instead store a pointer (or a smart pointer).</p>
<p>For example:</p>
<p>vector<Shape> vs; // No, don’t - there is no room for a Circle or a Smiley</p>
<p>vector<Shape?>vps; //better, but see §4.5.3</p>
<p>vector<unique_ptr<Shape>> vups; // OK</p>
<p>Why doesn’t the standard guarantee range checking? Many performance-critical applications  use vectors and checking all subscripting implies a cost on the order of 10%. Obviously, that cost  can vary dramatically depending on hardware, optimizers, and an application’s use of subscripting.  However, experience shows that such overhead can lead people to prefer the far more unsafe builtin  arrays. Even the mere fear of such overhead can lead to disuse. At least vector is easily range  checked at debug time and we can build checked versions on top of the unchecked default.</p>
<p>a map is known as an associative array or a dictionary. It is implemented as a balanced  binary tree.</p>
<p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p></p>
<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<p>类型限定符提供了变量的额外信息。包括有const、volatile、restrict。C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>
<p>const	const 类型的对象在程序执行期间不能被修改改变。</p>
<p>volatile	修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</p>
<p>restrict	由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。</p>
<p>C++ 存储类说明符：定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。auto、register、static、extern、mutable、thread_local (C++11)、从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<p>C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。下面列出了数据类型修饰符：signed、unsigned、long、short、</p>
<p>存储类说明符 类型限定符 类型修饰符 标识符</p>
<p>specifier delimiter modifier identifier</p>
<p>extern volatile unsigned long int i;</p>
<p>volatile unsigned long int i=0;</p>
<p>函数参数传值、返回值，都会在栈上有一个值的内存空间的副本，而传址（包括引用），内存副本只是一个内存地址的副本；指向函数体栈帧外一段空间的首地址。</p><p>调用类型	描述</p><p>传值调用	该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</p><p>指针调用	该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p><p>引用调用	该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p><p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings。</p><p>传值、传址（引用）、返回值、返回址（引用），值是函数栈帧上的值，址是本函数栈帧以外上的内在空间上的址。</p><p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。</p><p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。</p><p>C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</p><p>就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p><p></p><p>例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p><p>cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p><p>为什么基类指针和引用可以指向派生类对象，但是反过来不行？</p><p>在内存中，一个基类类型的指针是覆盖N个单位长度的内存空间。</p><p>当其指向派生类的时候，由于派生类元素在内存中堆放是：前N个是基类的元素，N之后的是派生类的元素。</p><p>于是基类的指针就可以访问到基类也有的元素了，但是此时无法访问到派生类（就是N之后）的元素。</p><p>p是基类指针，p指向的是绿色的部分，但可以通过转换把让p指向派生类(实际上p的指向的地址没有变，只是类型变了，指向的空间的大小不一样而已)</p><p></p><p>派生类的指针却不能指向基类，那样那越界，就是说小的可以变大，大的却不能变小</p><p>而基类指针指向派生类对象实例，是通过多态实现的。只能调用其接口，及虚函数。</p><p>静态类型：对象在声明时采用的类型，在编译期既已确定；</p><p>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</p><p>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</p><p>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；必须搞清楚的一点是：动态绑定只有当我们指针或引用调用虚函数的时候才会发生。</p><p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。</p><p>所以在C++中有两种类型转换static_cast和dynamic_cast的。</p><p>另外C++增加了const，所以又有了const_cast。</p><p>对于C的转换，有了reinterpret_cast的转换。</p><p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</p><p>静态数据成员共享数据的一种机制，比全局变量安全，能将作用域限制在类内；</p><p>ofstream(fileName, mode)</p><p>ios::app :  start writing at end of file</p><p>ios::ate: start reading or writing at end of file</p><p>Ios::in : open for reading</p><p>ios::trunc: truncate file to zero length if it exists</p><p>ios::nocreate : error when opening if file does not exist</p><p>ios::noreplace: error when opening for output if file exists.</p><p>ios::binary: open file in binary mode.</p><p>ios::out : open for writing</p><p></p><p>fstream file; file.open("Group.dat", ios::app | ios:: out | ios::in | ios::binary);</p><p>基类ios(继承istream的类)提供一个重载的强制类型转换运算符，将流变成void*类型的指针。如果读取数值时发生错误或遇到文件结束符，则指针值为0。编译器能够隐式使用void*类型的强制转换运算符。</p><p>stringstream类用于执行C++风格的串流的输入操作。 </p><p>　　ostringstream类用于执行C风格的串流的输出操作。 </p><p>　　strstream类同时可以支持C风格的串流的输入输出操作。</p><p>两个整数相除是整除(integer division)，小数部分丢失(即截尾，truncated)。</p><p>c++编译器只能对操作数的数据类型一致的表达式求值。要保证操作数的数据类型一致，编译器对所选择的操作数进行提升(promotion)操作(也称为隐式类型转换，implicit conversion)。</p><p>程序中一个标识符有意义的部分称为其作用域。例如，块中声明局部变量时，其只能在这个块或这个块嵌套的块中引用。一个标识符的4个作用域是函数范围(function scope)、文件范围(file scope)、块范围(block scope)和函数原型范围(function-prototype scope)。后面还要介绍第五个--类范围(class scope)。</p><p>派生类总是负责直接基类的构造。</p><p>派生类利用初始化列表构造基类的属性。</p><p>有多个基类的情况下，派生类对基类的构造顺序取决于继承顺序，先继承的先构造，最后构造自身。析构顺序与此相反。</p><p>Thus, the standard containers plus back_inser ter()s eliminate the need to use error-prone, explicit C-style memory management using realloc().</p><p>Dynamic memory management in C programs can be extremely complicated  and consequently prone to defects. Common programming defects related to  memory management include initialization errors, failing to check return values,  dereferencing null or invalid pointers, referencing freed memory, freeing the same  memory multiple times, memory leaks, and zero-length allocations.</p><p>Initializing large blocks of memory can degrade performance and is not  always necessary. The decision by the C standards committee to not require  malloc() to initialize this memory reserves this decision for the programmer.  If required, you can initialize memory using memset() or by calling calloc(),  which zeros the memory. When calling calloc(), ensure that the arguments,  when multiplied, do not wrap.</p><p>Containers are neatly partitioned  into two categories: sequence containers and associative containers.  The sequence containers are conceptually similar to arrays; they provide  accesses to sequences of elements. Associative containers contain key/  value pairs, so elements in the containers can be looked up by key.</p><p>Invariants are features of a class that don’t  change once they’ve been constructed.</p><p>By wrapping a dynamic object with  a smart pointer, you can rest assured that memory will be cleaned up appropriately  as soon as the object is no longer needed.</p><p>Examples of actions you might  want to take in a destructor include releasing file handles, flushing network  sockets, and freeing dynamic objects.</p><p>Pointers encode both pieces of information required to interact with another  object—that is, the object’s address and the object’s type.</p><p>Pointers share several characteristics with arrays. Pointers encode object location.  Arrays encode the location and length of contiguous objects.</p><p>References are safer, more convenient versions of pointers. You declare references  with the & declarator appended to the type name. References cannot  be assigned to null (easily), and they cannot be reseated (or reassigned).  These characteristics eliminate some bugs endemic to pointers.</p><p>If you’ve been programming in an application language, chances are you’ve  used an automatic memory manager, or a garbage collector. At runtime, programs  create objects. Periodically, the garbage collector determines which objects  are no longer required by the program and safely deallocates them. This  approach frees the programmer from worrying about managing an object’s  life cycle, but it incurs several costs, including runtime performance, and  requires some powerful programming techniques like deterministic  resource management.  C++ takes a more efficient approach. The trade-off is that C++ programmers  must have intimate knowledge of storage durations. It’s our job,  not the garbage collector’s, to craft object lifetimes.</p><p>Because the compiler doesn’t typically clean up memory after an object is deleted, a  subtle and potentially serious type of bug called a use after free can occur. If you  delete an object and accidentally reuse it, your program might appear to function correctly  because the deallocated memory might still contain reasonable values. In some  situations, the problems don’t manifest until the program has been in production for a  long time—or until a security researcher finds a way to exploit the bug and discloses it!</p><p>In practice, your program’s operating environment might clean up leaked resources  for you. For example, if you’ve written user-mode code, modern operating systems will  clean up the resources when the program exits. However, if you’ve written kernel code,  those operating systems won’t clean up the resources. You’ll only reclaim them when  the computer reboots.</p><p>You use try-catch blocks to establish exception handlers for a block of code.  Within the try block, you place code that might throw an exception. Within  the catch block, you specify a handler for each exception type you can handle.</p><p>左值存储在一个内存单元中，右值存储在寄存器中。使用右值引用可以将右值备份到内存单元中。</p><p>相当于快速引用一个寄存器的值。</p><p>The static_cast reverses a well-defined implicit conversion, such as an integer  type to another integer type. The object-to-cast is of some type that the  desired-type implicitly converts to. The reason you might need static_cast is  that, generally, implicit casts aren’t reversible.</p>