<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />

<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /></head>


<body onload="downn();">

<div id="container">




<p>程序设计诞生的历史:1 重新调整电缆的连接方式；2 程序内置；</p>

<p>数在内存中的表示，是先要定义类型，也就是定义在内存中你计划用多少空间，因为不同类型的数据，其长短是不一样的，所以double实型的数据会有截断的情形，由此两个实型的数据的比较会有一些问题存在；如0.3的二进制是0.0 1001 1001 1001 1001...</p>

<p>正数与负数怎样在计算机中进行表示呢？计算机补码的方案，如果有0开头表示负数，1开关的表示负数，则对于0的表示会存在歧义。补码的思路是：正数按正常的方法表示，负数对正数的位数全部取反，然后再加1，这样对于0的表示则不会再有歧义。</p>
<p>字符串的编码方案：Ascii、Unicode;</p>
<p>浮点型：real-4、real-8;</p>
<p></p>
<p>数据处理：包括数据的输入（将需要处理的数据放入内存的容器中）、处理、输出（显示到屏幕或保存到文件）；处理主要分为文字的处理和数值的计算（对于电脑功能来说，还包括不需要输入输出的过程控制。）计算主要是加减乘除等，而文字或文本的处理也就是增查删改；</p>

<p>.Net策略：所有.NET语言（如VB,VC,VC#和其它语言）都可以利用Microsoft所创建的大量类库，并享受自动内存管理、类型和安全的异常处理的好处。</p>

<p>为与电子元件开关特性相适应，计算机中用二进制表示数。</p>

<p>穿孔纸带上的当前位置用5个孔位的编码表示一个数字或字母。</p>

<p>How many planes will an air-traffic system need to manage? How many shapes will a CAD system require? In the general programming problem, you can't know the quantity, lifetime, or type of objects needed by your running program.</p>

<p>二进制文件中的一个整型占4个字节，需要4个字节的数据连在一起解释才有意义。</p>

<p>在表达式中，等号的左边必须是变量（不能是常量），等号的右边可以是变量，也可以是常量。</p>

<p>ActiveX是由用户使用程序设计语言定制的可征用对象。</p>

<p>让机械做立方运算是极难之事。乘算和除算也都很难。但加算似乎总能想办法做到。只用加算来完成乘算、除算、微分、积分等很难的运算，这是后来任何一种计算机设计时的根本原理。</p>

<p>UL是无符号长整型。</p>

<p>静态数组在定义静态数组变量时直接就可以获得相应内存的空间，静态数组的内存空间由系统自动回收。动态数组则需要通过malloc等函数进行动态分配；在动态数组使用完毕后，需要通过显式调用free等函数释放所占用的内存。</p>

<p>程序的两层概念，一个数据，二是数据的处理。数据如何存储，直接关系到数据处理的方法设计。另外，数据有不同的输入和输出方法。</p>

<p>从某一个方面说，函数参数及语句块内定义的变量就是数据的输入，输出就是函数的返回值。</p>

<p>visual studio code</p>

<p>Atom编辑器是由Github开发的一个跨平台的编辑器，使用了跨平台的Electron，用前端技术编写图形界面。
<p>微软公司也利用Electron做了一个跨平台的编辑器，叫做Visual Studio Code。虽然它的社区远远不如Atom社区活跃，插件也不是很丰富，但是易用性方面非常好。
<p>Visual Studio Code是微软推出的一款轻量级的编辑器，主要针对web前端开发如javascript、html等，但是其支持插件的功能，于是人们为其开发了众多其他语言的插件，如C/C++语言的插件。</p>

<p>对象是属性、方法、事件的集合。</p>

<p>函数是编程语言的一种很重要的编程机制，用于将一段计算包装起来，然后可以多次调用。</p>

<p>函数按是否有返回值，可以分为无返回值的类型，只是提供一种执行效果，可以单独构成一个语句。有返回值的提供一个返回值，用于表达式或函数参数中。</p>

<p>编程语言细节：程序中经常要写诸如n=n+1或x=x*2或prod = prod * K一类的语句。这类语句是基于一个变量的原值，用一个运算算出新值，最后用这个新值更新变量并保存存储单元不变。同一个变量写了两次，如果能减少这种重复书写当然也有价值。这处理这个问题，一般编程语言都会提供一组扩展赋值符，其功能相当于做一次二元运算，再用运算结果更新变量，如+=、_=等。除了书写简单外，解释器还可以利用硬件的更新寄存器的专门指令，让效率更优化。</p>

<p>网络爬虫的最终目的就是从网页中截取自己所需要的内容。最直接的方法当然是用urllib2请求网页得到的结果，然后使用re(正则表达式模块)匹配所需要的内容。如果使用爬虫框架，如scrapy，则会简单很多。</p>

<p>字符串可以是键盘上可见的字符，也可以是不可见的回车符、制表符等；</p>

<p>跟踪挂起的函数调用，递归调用将反复进行，直到基准情形出现。也就是说，递归调用必须总能够朝着产生基准情形的方向推进。</p>

<p>数组使得查找的操作可以以线性时间执行，但插入和删除较慢，且大小须事先确定。</p>

<p>为了避免插入和删除的线性开销，我们需要允许表可以不连续存储，否则表的部分或全部需要整体移动。而链表刚好可以达到此目标。</p>

<p>字符串：大小写转换、删除字符末尾的空格、分割字符串；</p>

<p>整数和小数：加减运算、简单数据运算；</p>

<p>数据可以存储成许多不同的格式和文件类型。某些格式存储的数据很容易被机器处理，而另一些格式存储的数据则容易被人工读取。微软的word文档属于后者，而CSV、JSON和XML文件则属于后者。</p>

<p>CSV，Comma-Separated Values，逗号分隔值；</p>

<p>JSON，JavaScript Objet Notation，JavaScript对象符号；</p>

<p>XML，eXtensible Markup Language，可扩展标记语言；</p>

<p>总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。
<p>函数的内部观点：关心函数的定义，1 采用什么计算方法；2 采用什么实现结构；3 实际参数如何使用；4 怎样得到所需要的返回值；
<p>函数的外部观点：关心函数的使用，1 实现了什么功能；2 名字是什么；3 要求几个参数，各参数的意义和作用；4 返回什么值；

<p>动态语言：<strong>是指程序在执行期间去做数据检查，也就是说不用给任何变量指定数据类型</strong>，该语言会在第一次赋值给变量时，在内部将数据类型记录下，如Python和Ruby就是一种典型的动态类型语言。
<p>静态语言：与动态语言相比较，在写程序时，所有变量必须声明其数据类型。例如Java就是静态语言，其声明变量时，必须给定数据类型，并初始化。
<p>强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。强类型定义语言带来的严谨性能够有效的避免许多错误
<p>弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。
<p>程序员通常需要处理下述5个内存区域：
<p>1 全局名称空间：存储全部变量；
<p>2 静态变量空间：存储静态变量；
<p>3 堆：也称为自由存储区，由程序员申请使用，询问预留的空间地址，将其存储在地址中；申请的堆内存用完后程序员如果不释放，需要等到程序结束后才会由系统清理堆。C语言一般使用malloc()函数和realloc()函数申请，而C++一般使用new运算符申请堆空间；
<p>4 寄存器：用于内部管理，如跟踪栈顶和指令指针；
<p>5 代码空间：存储代码；
<p>6 栈：存储函数的局部变量和参数，当函数返回时，都会由系统清理栈；<p>编辑框输入一个函数表达式,怎样转换为数学表达式
<p>有个思路。如没括号的式子：5+3*1-6/3就是分两次遍历，第一次遇到*、/直接运算为数值，第二次加减运算。括号可用函数写。
<p>数据结构的书上是这么说的：首先为每个符号设定优先级，然后弄两个栈，一个是数字的，一个是括号和运算符的。
<p>VC编辑框输入一个函数表达式,怎样转换为数学表达式
<p>如果实现 a op b通过字符遍历取得运算符可以简单的思想得到；


<p>数据类型是一组性质相同的值集合以及定义在这个值集合上的一组操作的总称。数据类型定义了两个集合，即该类型的取值范围以及该类型中可允许使用的一组运算。例如，高级语言中的数据类型就是已经实现的数据结构的实例。从这个意义上讲，数据类型是高级语言中允许的变量种类，是程序设计语言中已经实现的数据结构（即程序中允许出现的数据形式）。</p>

<p>ADT(Abstract Data Type)定义了一个数据对象、数据对象中各元素间的结构关系以及一组处理数据的操作。ADT通常是指由用户定义且用以表示应用问题的数据模型，由基本的数据类型组成，并包括一组相关服务操作。</p>

<p>ADT <ADT 名>
<p>{数据对象：<数据对象的定义>
<p>结构关系：<结构关系的定义>
<p>基本操作：<基本操作的定义>
<p>} ADT <ADT 名>
<p>如数据结构，图：元素、元素关系及关于图的操作；
<p>数据元素+函数；
<p>类属性+类方法；

<p>数据的逻辑结构：体现各结点间的相邻关系；</p>

<p>查找方法：基于线性表的查找方法、基于树的查找方法、计算式查找法；</p>

<p>排序：插入类排序、交换类排序、选择类排序、归并排序、分配类排序；</p>

<p>一个变量代表一个内存地址；</p>

<p>对象需占内存空间的大小：数据成员所需空间的总和。</p>

<p>局部变量的局限性是不会持久化，函数返回时，局部变量将丢弃。全局变量解决了这个问题，但代价是整个程序中都能访问它，这导致代码容易出现bug，难以理解和维护。将数据放在堆中可解决这两个问题。</p>

<p>可将堆视为大块内存，其中有数以千计的文件架等待您存储数据，但您不能像栈那样标识这些文件架。您必须询问预留的文件架的地址，将其存储到指针，然后丢掉。</p>

<p>每当函数返回时，都会清理栈。此时，所有局部变量都不在作用域内，从而从栈中删除。只有到程序结束后才会清理堆，因此使用完预留的内存后，您需要负责将其释放。让不再需要的信息留在堆中称为内存泄露。</p>

<p>堆的优点在于，在显式释放前，您预留的内存始终可用。如果在函数中预留堆听内存，在函数返回后，该内存仍然可用。</p>

<p>以指针访问堆中内存（而不是全局变量）的优点是，只有有权访问指针的函数才能访问它指向的数据。这提供了控制严密的数据接口，消除了函数意外修改数据的问题。</p>

<p>如果不能从堆中分配内存（因为内存资源有限），将引发异常。异常是处理错误的对象。</p>

<p>使用循环时，指定一个循环体。循环体的重复是被循环控制结构所控制的。在递归中，函数重复地调用它自己。必须使用一条选择语句来控制是否继续递归调用该函数；</p>

<p>递归会产生相当大的开销。程序每调用一个函数，系统就给函数所有局部变量和参数分配空间。这就要占用大量的内存，还需要额外的时间来管理这些附加的内存空间；</p>

<p>任何使用递归解决的问题都可以用迭代非递归地解决。递归至少会有一个副作用：它耗费了太多的时间并占用了太多的内存。那么，为什么还要使用它呢？因为在某些情况下，本质上有递归特性的问题很难用其他方法解决，而递归可以给出一个清晰、简单的解决方案。如汉诺塔访问、目录大小问题等；</p>

<p>左值通常是内存单元，右值可以是内存单元的内容。所有的左值（要初始化或赋值）都可用作右值；但并非所有的右值都可用作左值；</p>

<p>Robert Kowalski 在这篇论文里提到：</p>

<p>An algorithm can be regarded as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency. The efficiency of an algorithm can often be improved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.</p>

<p>翻译过来的意思大概就是：</p>

<p>任何算法都会有两个部分， 一个是 Logic 部分，这是用来解决实际问题的。另一个是 Control 部分，这是用来决定用什么策略来解决问题。Logic 部分是真正意义上的解决问题的算法，而 Control 部分只是影响解决这个问题的效率。程序运行的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护。</p>

<p>编程的本质</p>

<p>两位老先生的两个表达式：</p>

<p>Programs = Algorithms + Data Structures</p>

<p>Algorithm = Logic + Control</p>

<p>第一个表达式倾向于数据结构和算法，它是想把这两个拆分，早期都在走这条路。他们认为，如果数据结构设计得好，算法也会变得简单，而且一个好的通用的算法应该可以用在不同的数据结构上。</p>

<p>第二个表达式则想表达，数据结构不复杂，复杂的是算法，也就是我们的业务逻辑是复杂的。我们的算法由两个逻辑组成，一个是真正的业务逻辑，另外一种是控制逻辑。程序中有两种代码，一种是真正的业务逻辑代码，另一种代码是控制我们程序的代码，叫控制代码，这根本不是业务逻辑，业务逻辑不关心这个事情。</p>

<p>Control 是可以标准化的。比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。</p>

<p>因为 Control 需要处理数据，所以标准化 Control，需要标准化 Data Structure，我们可以通过泛型编程来解决这个事。</p>

<p>而 Control 还要处理用户的业务逻辑，即 Logic。所以，我们可以通过标准化接口 / 协议来实现，我们的 Control 模式可以适配于任何的 Logic。</p>

<p>上述三点，就是编程范式的本质。</p>

<p>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</p>

<p>如何分离 control 和 logic 呢？我们可以使用下面的这些技术来解耦。</p>

<p>State Machine</p>

<p>状态定义</p>

<p>状态变迁条件</p>

<p>状态的 action</p>


<p>DSL – Domain Specific Language</p>

<p>HTML，SQL，Unix Shell Script，AWK，正则表达式……</p>

<p>编程范式</p>

<p>面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC……</p>

<p>函数式编程：修饰、管道、拼装</p>

<p>逻辑推导式编程：Prolog</p>

<p>这就是编程的本质：</p>

<p>Logic 部分才是真正有意义的（What）</p>

<p>Control 部分只是影响 Logic 部分的效率（How）</p>

<p>在阅读代码的时候，并不总应该按照代码书写顺序一行行阅读；有时候，按照程序执行的流程来阅读代码，理解的效果可能会更好。</p>

<p>栈图stack diagram，可以展示函数名以及函数名下包含的参数和局部变量。每个函数使用一个帧（function frame）包含。帧在栈图中就是一个带着函数名称的盒子，里面有函数的参数和变量。</p>

<p>为什么要有函数？</p>

<p>函数把解决一个小问题的代码构建成块，可以反复调用，在逻辑上更易于阅读和理解，也可以减少代码的重复使用或冗余。另外，函数还可以组合成模块，然后在其实模块中可以引入包含有需要的函数的模块，并通过模块名和函数名来调用。</p>

<p>给函数添加参数的过程称为泛化（generalization）。因为它会让函数变得更通用。如你想计算一个正方形的面积，如果不提供参数，只能是算某一个具体边长的正方形的面积，如果你将边长做为一个变量len，并提供给函数做为参数，那在这个函数的新版本中，你就可以计算任意大小的正方形的面积。</p>

<p>程序开发的“封装和泛化”：</p>

<p>1 最开始写一些小程序，而不需要函数定义；</p>

<p>2 一旦程序成功运行，识别出其中一段完整的部分，将它封装（将一组语句转换为函数定义）到一个函数中，并加以命名。通过函数将代码进行分块组合；</p>

<p>3 泛化（generalization，给函数添加参数的过程，将一些不必要的具体值替换为合适的通用参数或变量的过程）这个函数，添加合适的形参，让这个函数变得更加通用；</p>

<p>4  重复上面的步骤，直到得到一组可行的函数；</p>

<p>5 寻找可以使用重构（refactoring，重新组织程序，以改善接口（函数名称与形参），提高代码重用）来改善程序的机会。例如，如果发现程序中几处地方有相似的代码，可以考虑将它们抽取出来做一个合适的通用函数。</p>

<p>6 在上述开发的过程中，也可以考虑“增量开发”的思路，也就是从最简单的部件开始，每次只增加和测试一部分代码；并适当地增加临时变量来保存和输出，逐步达到你需要的轮廓。一旦程序完成，你就可以删除这些你最终并不需要，只是帮助你理清逻辑思路并调试结果的脚手架代码（scaffolding）。这是一个笨办法，特别是当你逻辑思路不是很清晰时，当然此后你可能需要不断去泛化和重构你的代码。</p>

<p>多态是指子类的对象可以传递给需要父类类型的参数，一个方法可以被沿着继承链的几个类执行（最特定→最通用，最底层→最顶层，最晚辈→最长辈）。</p>

<p>使用父类类型的地方都可以使用子类。</p>

<p>子类的对象可以充满父类方法中需要用父类做为参数的父类对象。</p>

<p>集合set的基本功能是进行成员关系测试和删除重复元素。</p>

<p>计算机的核心就在于用数据来模拟事物，数据和处理数据的代码输入并存储到内存，处理后产生输出。</p>

<p>一个常见的说法是：程序＝数据结构+算法</p>

<p>数据结构＝数据元素集合 + 逻辑关系 + 存储实现 + 数据元素运算（数据结构的算法，如数据元素检索、插入、删除、更新、排序）</p>

<p>1 数据元素构成：字符、数字等；</p>

<p>2 数据元素的逻辑关系：属于一个集合、一对一的线性关系、一对多的树型层次关系；多对多的图型网状关系；</p>

<p>3 数据元素存储方式：顺序存储（数字索引）、链式存储（指针定位相邻元素）、哈希存储（字符索引）</p>

<p>4 数据元素运算：增删操作、访问查询操作、元素修改更新操作；</p>

<p>存储方式与数据元素的关系：</p>

<p>数据存储的目的在于运算，要“存得进出、取得出来”，并要追求效率，但数据元素三个方面的操作，用存储方式去实现时，无法同时达到最优。如顺序存储，可以通过数字索引随机访问，效率很高，但增删的效率很低（尾部操作效率高）；而链式存储，虽然访问的效率很低（需要按顺序一个个去找），但 增删操作的效率很高；而哈希存储的数据元素集合，可以按字符串索引（关键字或键）提供随机访问。</p>

<p>以上4个元素的不同组合，构成了不同的数据结构。不同的数据结构可以模拟不同事物，有不同的运算效率。</p>

<p>底层数据结构+函数或方法→复杂数据结构；</p>

<p>图（多对多的关系，二维邻接表）→特殊的图：树→特殊的树：线性表；</p>

<p>元素的限制：字符串</p>

<p>操作的限制：栈、队列</p>

<p>逻辑关系的限制：二叉树</p>

<p>数据结构（集合），可以定义成函数模块的形式，操作可以定义成函数；也可以定义成类，操作可以定义为类或对象方法；</p>

<p>最复杂的图是顶点与边的集合，也就是数据元素与关系的集合{V,E}，可以用一个二维表来表示。</p>

<p>一个简单的程序就是，输入需要的数据（设计数据结构，如结构体、类等），适当的处理（算法和函数），输出（呈现给用户）。</p>

<p>一个输入：传感器；一个输出：LED；CPU或者说微处理器的功能就是根据输入计算和控制，然后控制输出。</p>

<p>程序员各自开发各自的模块，只需要约定好互相调用的接口即可。</p>

<p>函数就可以起到接口的作用。</p>

<p>我们在现实生活中解决问题，往往需要分为“做什么”和“怎么做”两个部分。大多数时候，做什么是设计，怎么做是实现。</p>

<p>函数为我们提供了在程序设计时的抽象机制，可以首先解决做什么的问题，设计出程序的结构，通过函数机制做出接口，具体的实现可以逐步细化。</p>

<p><strong>一个单元就是一个模块。在任何一个单元中，分为接口和实现两个部分。我们要用这个模块，只需要理解接口中的调用函数用法即可。</strong></p>

<p><strong>重新赋值的最常见形式是更新，此时变量的新值依赖于旧值。</strong></p>

<p>正则表达式能处理某一类具有某些相似特征的字符或字符串（一般的字符串处理函数处理的是具体字符串的字面量）。</p>

<p>正则表达式是强大、便捷、高效的文本处理工具。利用它使用者可以描述和分析任何复杂的文本，配合编程语言或文本编辑器提供的支持，正则表达式能够查找、替换、提取、验证、添加、删除、分离和修整各种类型的文本和数据。</p>


<p>函数就是一个功能部件，其头部定义了它的接口，描述了函数的名字及其对参数的要求。使用者只需要考虑函数的功能是否满足实际需要，还要保证调用式符合函数头部的要求，并不需要知道函数实现的任何具体细节。</p>

<p>在程序开发的实践中人们逐渐认识到，仅有计算层面的抽象机制和抽象定义还不够，还需要考虑数据层面的抽象。能围绕一类数据建立程序组件，将该类数据的具体表示和相关操作的实现包装成一个整体，也是组织复杂程序的一种有效技术，可以用于开发出各种有用的程序模块。要把这种围绕着一类数据对象构造的模块做成数据抽象，同样需要区分模块的接口和实现。模块接口提供使用它提供的功能所需的所有信息，但不涉及具体实现细节。另一方面，模块实现者则要通过模块内部的一套数据定义和函数（过程）定义，实现模块接口的所有功能，从形式上和实际效果上满足模块接口的要求。</p>

<p>组合类型作为一个整体存储、传递和处理。</p>

<p>编程语言的内置数据类型就可以看作一个抽象数据类型。</p>



<p>抽象数据类型的三类操作：构造、解析、变动。不提供变动操作的类型称为不可变数据类型，提供变动操作的类型称为可变数据类型。</p>





<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>


<p>控制器的控制信号来自于程序中的指令。</p>

<p>指令中有操作码和地址码，分别指向操作动作与操作数据；</p>

<p>操作系统功能：进程管理、内存管理、文件管理、输入输出管理；</p>


<p>机器语言是一串二进制数字，将计算的步骤从指令表中查出对应的机器语言编码，再人工写成数列。而查表（指令表）的工作正是计算机所擅长的，指令表的二进制编码用助词符来表示，用汇编器来翻译，这就是汇编语言机制。</p>



<p>编程语言的进化在于抽象化，“赋予名称”是抽象化的重要部分。抽象程序高的语言不必描述详细过程。</p>



<p><strong>由于程序本身的信息是可以被访问的，因此在程序运行过程中也可以对程序本身进行操作，这就是元编程（动态运行模式）</strong>。</p>



<p>在运行过程中程序能识别自身，并对自身进行操作，对程序自身进行操作的编程称为元编程（Metaprogramming）。</p>



<p>比如查询某个对象拥有哪些方法，或者在运行时对类和方法进行定义。</p>



<p>动态语言，运行时才能确定结果（HTML、Ruby）</p>



<p>静态语言，不实际运行程序，仅通过程序代码的字面来确定结果（Java、Go）</p>

<p>内联函数和宏的区别在于内联函数只做一次类型检查与参数评估，而宏可以做多次。换言之，宏不做type-checking，也不会保证输入值只被求值（evaluated)一次。</p>



<p>在计算机编程中，条件编译的实现是为了让编译器可以依据不同的输入参数来生成不同的可执行文件。这在不同的硬件平台和操作系统上甚至是不同版本的库之间被经常使用的技术。</p>



<p>编译时绑定也称早期绑定（early binding）或静态绑定（static binding），顾名思义，就是在编译阶段所有的变量与表达式已经被锁定了，典型的例子有function overloading、operator overloading等。</p>



<p>运行时绑定也称晚绑定（late binding）或动态绑定（dynamic binding），它指目标对象的调用方法在运行时被锁定。最典型的例子就是OO三大特性中的多态性体现在虚拟函数中。比如，base class pointer（或reference）被分配了一个derived class的pointer（或reference），那么具体的函数调用是在运行时通过动态的虚拟表（vfptr）来指定的。C++、Java都支持晚绑定技术。</p>



<p>静态链接库就是把（lib）文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其他库文件。</p>



<p>动态链接则是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应的DLL文件的支持。顾名思义，动态链接是在运行时通过连接器（linker）来加载启动代码，从而加载所需要的库，对每一个库的调用都要通过一个跳台（jump table）指向该库，唯一的开销是间接引用。动态链接还需要验证jump table符号链接（symbols linkage），动态loader需要检查共享库，加载入内存并且附加在程序内存段。</p>



<p>静态链接库与动态链接库都是共享代码的方式。</p>

<p>转义字符是指字符从一种含义（用法）变成另外一种含义；</p>


<p>按数据的组织形式可以把文件分为文本文件和二进制文件两大类。如常见的图形图像文件、音频视频文件、可执行文件、各种数据库文件、各类Office文档都属于二进制文件。</p>



<p>二进制文件把信息以字节串（bytes）进行存储，无法用记事本或其他普通字处理软件直接进行编辑，通常也无法直接阅读和理解，需要使用正确的软件进行解码或反序列化之后才能正确地读取、显示、修改或执行。</p>

<p>每个文件在文件系统中都包含两个要素：文件名和存放文件内容数据的数据结构。</p>

<p>用变量引用内存单元；</p>

<p>程序开发的“封装和泛化”：</p><p>1 最开始写一些小程序，而不需要函数定义；</p><p>2 一旦程序成功运行，识别出其中一段完整的部分，将它封装（将一组语句转换为函数定义）到一个函数中，并加以命名。通过函数将代码进行分块组合；</p><p>3 泛化（generalization，给函数添加参数的过程，将一些不必要的具体值替换为合适的通用参数或变量的过程）这个函数，添加合适的形参，让这个函数变得更加通用；</p><p>4  重复上面的步骤，直到得到一组可行的函数；</p><p>5 寻找可以使用重构（refactoring，重新组织程序，以改善接口（函数名称与形参），提高代码重用）来改善程序的机会。例如，如果发现程序中几处地方有相似的代码，可以考虑将它们抽取出来做一个合适的通用函数。</p><p>6 在上述开发的过程中，也可以考虑“增量开发”的思路，也就是从最简单的部件开始，每次只增加和测试一部分代码；并适当地增加临时变量来保存和输出，逐步达到你需要的轮廓。一旦程序完成，你就可以删除这些你最终并不需要，只是帮助你理清逻辑思路并调试结果的脚手架代码（scaffolding）。这是一个笨办法，特别是当你逻辑思路不是很清晰时，当然此后你可能需要不断去泛化和重构你的代码。</p><p>面向过程：解决问题的步骤；</p><p>面向对象：把解决问题的步骤分解到对象，这里的对象是指问题的主体与客体。谁来解决，解决谁？</p><p>所以面向对象离不开面向过程的思路。</p><p>先要解决1+2的问题：加法器；然后要解决1+2+3的问题，需要存储器，数据与数据处理的指令序列（机器语言或汇编语言或高级语言）存储到存储器中，这样计算机就能够一条条往下执行，不需要人工介入，直到运行到停止指令才结束，整个过程实现自动化。</p><p>++var左结合；</p><p>赋值运算符：将值与变量绑定起来，也就是说，值写入变量所引用的内存单元。通常仅声明的变量是没有初始值的，给变量填入数据最直接的办法就是使用赋值运算符将值赋予变量。</p><p>以是代码将"wwu"赋予变量name，“=”运算符左边的操作数称为左值，其右边的操作数称为右值。右值必须是变量，右值可以是变量、常量或表达式。</p><p>Win32是一个子系统，这个当然是对的，不过我们有时候我们所说Win32通俗的就是指32位的Windows系统，从windows95/98到NT/2000/XP都是32位Windows。子系统却是仅对NT架构的系统而言的。</p><p>API就是应用程序接口，是由系统提供的一些函数，比如你想创建一个文件，就要调用CreateFile，这个CreateFile就是一个API。任何一个操作系统都会提供API的，比如DOS也提供API，不过它是通过Int 21h中断提供的就是了。</p><p>SDK是指一些公司针对某一项技术为软件开发人员制作的一套辅助开发或者减少开发周期的工具。一般专指Windows系统提供的相关的头文件和LIB文件。有时候很多人将不用MFC等相关类库，而只用API进行开发的方式也叫做SDK开发，从这一点来说，API和SDK似乎是通用的。</p><p>MFC是MS对API的一个封装，也就是一个C++类库，当然MFC比一般类库庞大，所以有人称之为应用程序框架。但其本质还是一个类库</p>


  
  <h4>自动化、强大的程序功能是如何实现的?</h4>
  <p>自动化、强大的程序功能是如何实现的?</p>
  <p>如果编写的代码只能按顺序机械地执行，则无法实现自动化及无法利用计算机计算速度快的特点；</p>
  <p>1 利用计算机的逻辑计算的功能，计算机语言有了条件选择的逻辑控制结构，可以对编写的一些代码，根据条件选择性地执行某一些代码；</p>
  <p>2 利用计算机逻辑计算和机械性速度快的特点，计算机语言有了循环控制结构，可以对编写的一些代码选择性地重复执行n次；</p>
  <p>3 将上述的控制结构嵌套、组合，再利用计算机语言提供的函数，便可以构建强大的数据处理的程序；</p>
  <p>头文件.h提供声明信息，包括函数、类等的声明以及宏定义。源文件提供实现信息使程序的逻辑结构更清晰，源文件包括头文件的引用以及相关函数或类方法的实现。</p>

<p>3 如果被读入行中存在尚未配对的括号，两样认为下一行是本行的继续。<p>编程：从简单的有代表性的实例，模拟机械思维写出伪代码，然后再用程序高级语言来描述。</p>

<p>函数模板是一系列相关函数的模型或样板，这些函数的源代码形式相同，只是所针对的数据类型不同。对于函数模板，数据类型本身成了它的参数，因而是一种参数化类型的函数。</p><p>声明一个函数模板的格式是：</p><p>template <<模板形参表声明>><函数声明></p><p>类模板就是一系列相关类的模板或样板，这些类的成员组成相同，成员函数的源代码形式相同，所不同的只是针对的类型（数据成员的类型以及成员函数的参数和返回值的类型）。对应类模板，数据类型本身成了参数，因而是一种参数化类型的类，是类的生成器。类模板中声明的类称为模板类。</p><p>声明一个模板类的格式是：</p><p>template <<模板形参表声明>><类声明></p><p>为什么要分为很多头文件？如果所有的库写到一个库文件中，你写的程序会很大，所以头文件只是把一些相信功能的函数写到一个头文件中，这样引用时则数据比较少。</p><p>声明变量并不是多此一举，因为当你在某处使用这个变量的某一个字母写错时，会编译报错？如果没有变量声明机制，这样的错误发现不了，可能会出现意料之外的错误。</p><p>return的功能，一是返回一个值；2 退出函数；如果一个函数中有两个return，也相当于一个if else的分支。</p><p>常量是对数据的一种保护方式，也是一种统一字面量值的一种方式；</p>


<p>指令顺序存放，控制器顺序读取，但可以根据设定的条件跳转读取。</p>

<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。下面分别来介绍：</p>



<p>栈区（stack）—— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>



<p>堆区（heap）—— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 </p>



<p>全局区（静态区）（static）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p>



<p>文字常量区——常量字符串就是放在这里的，程序结束后由系统释放 。</p>



<p>程序代码区——存放函数体的二进制代码。</p>

<p>C把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果ar是一个数组，那么表达式ar[i]和*(ar+i)等价。</p>



<p>对C语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字const。在被调函数中可以使用数组表示法或指针表示法，无论用哪个表示法，实际上使用的都是指针变量。</p>

<p>黑盒视角只是在你使用库时。</p>



<p>基准条件可以有n个返回值，递归条件返回参数值变化的递归函数，可以假设有一条 函数调用链。</p>



<p>递归函数中位于递归调用之前的语句均按被调函数的顺序执行；</p>



<p>递归函数中位于递归调用之后的语句均按被调函数的相反的顺序执行；</p>



<p>每次递归调用都会创建函数中的局部变量，除此以外，递归调用类似于一个循环语句；</p>



<p>递归的代码量通常比较少，但局部变量需要占用空间，赋值时也需要时间。</p>



<p>尾递归是指递归调用写在递归函数的return语句之前；</p>

<p>使用指针在函数中通信，也就是用指针作为函数参数。</p>

<p>函数原型：允许编译器验证函数调用中使用的参数个数和类型是否正确，总的思路是避免错误。</p>

<p>数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持随机访问。有两种访问方式：随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。数组和链表还被用来实现其他数据结构。</p>

<p>在变量和数组等数组结构中存储信息。用函数或类的方法来处理信息。</p>

<p>Evaluate["expression"]</p>



<p>[expression]</p>



<p>[a1].value = 11</p>



<p>[a1] = 11</p>

<p>前置条件precondition：指调用函数前应具备的条件；</p>



<p>抹黑条件postcondition：指执行完函数后的情况。</p>

<p>回过头来看以前写的代码，知道写得不好，并且知道怎样重写，这样也就是进步了。</p>

<p>编程需要三种很重要的思维：逻辑思维、抽象思维、机械思维；</p>

<p>冯诺依曼结构是：数据和代码放在一起。</p>



<p></p>



<p>哈佛结构是：数据和代码分开存在。</p>

<p>字符串常量为什么要使用引号，如果不使用的话，怎样与变量进行区别？</p>

<p>Sql属于声明式编程。</p>



<p>在一台冯诺依计算机中，最核心的就是CPU和内存，指令和数据都存入在内存当中，CPU每次取出一条指令，译码、执行，然后把结果写回内存。</p>



<p>高级语言的变量声明，其实就对应着内存的一个存储单元，流程控制语句对应着CPU的跳转指令，函数调用对应着内存的栈帧。</p>



<p>面向对应相当于是数据的类类型，在属性（属于类的基本数据类型或复合类型）和成员函数（对属性的操作）前面多了一个前缀，同时，类之间具备了继承、多态的关系。</p>



<p>命令式编程就是对硬件操作的抽象，程序员需要通过指令精确地告诉计算机估秉公无私一。</p>

<p>指令集是对CPU的抽象，文件是对输入/输出设备的抽象，虚拟存储器是对程序存储的抽象，进程是对一个正在运行的程序的抽象，而虚拟机是对整个计算机（包括操作系统、处理器和程序）的抽象。</p>

<p>程序是一系列的函数的实现，包括输入、输出函数，程序运行在操作系统之上，通过操作系统与硬件交互，对于GUI操作系统，一般是多用户操作系统，可能运行了多个应用，所要主导权必须在操作系统的手上。如何调用函数呢？DOS与Windows的区别在于，DOS是通过函数调用，而Windows则是通过消息传递，如单击工具栏图标或菜单项或命令按钮。另外的区别在于输入与输出的方式不同，Windows采用控件这种窗口进行交互。</p>

<p>数据表示：编码方案，如unicode用utf-8实现；</p>



<p>数据结构的存储结构：顺序存储和链式存储；</p>



<p>数据结构的逻辑结构：一对一、一对多、多对多的关系，表现为线性关系、树型关系、图形关系；</p>



<p>数据的共享：全局变量、指针或引用参数，返回指针或引用（在函数体内申请内存空间返回）；</p>



<p>数据的保护：函数传值、访问控制符、const；</p>

<p>转义字符是指不将反斜杠后面的字符做字面解释，而是转为其它特殊含义；</p>

<p>浮点数是指小数点位置可以浮动的数。</p>

<p>将一组数据和对该数组的一组操作封装在一起。</p>

<p>构造函数一般是用来初始化一个对象的部分或全体数据成员。</p>

<p>程序：一组指令的有序结合，是静态的指令，是永久存在的。</p>



<p>进程：正在进行的程序，具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单元。进程的存在是暂时的，是一个动态的概念。</p>



<p>线程：进程的一个实体，是CPU调度的一个基本单元，是比进程更小的能独立运行的基本单元。本身基本上不拥有系统资源，只拥有一些运行中不可少的资源（如程序计数器、一组寄存器和栈）。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p>

<p>做产品要效率还是要用现代的语言和框架。</p>

<p>当初在选择Qt还是MFC时，毫不犹豫选了Qt，MFC那一坨一坨看的的好乱，我宁愿用C+win32 api也不用MFC，大程序果断C#。Qt也就在linux环境下编一些小软件。</p>

<p>大公司的客户端有自己的UI库，商业软件都是Java/.NET做界面了，极少有继续使用MFC的。各种原理和工作机制，可以从windows核心编程这种层面的入手，MFC那也是隔靴搔痒。</p>

<p>没有人说C#就是拖拖控件。JAVA和C#，将系统程序员（制造控件）和应用程序员（使用控件）分得很清楚，前者关心程序自身，后者关心业务实现。</p>

<p>无论MFC，还是wxWidgets、QT，都是框架，都得对API的封装，都是为了让你不用从Windows API开始写程序，都是为了让你站在某一些前人的肩膀上，掌握这些框架同样也需要技能。不要觉得你会了那个稍微底层一点的东西，就蔑视上层框架和上层技术。</p>

<p>程序语言帮你准备好材料，框架工具帮你搭建好框架，你做做装修就能完成一个产品。如C+API、C+++MFC或C+++QT，或C+++WPL</p>

<p>一、C语言入门。现在主流语言大都是C系的，如C++,Java, Object C,C# , JavaScript.而C语言本身小巧强大，学习的投入产出比最高，又易于转向其他流行语言。</p>



<p>二、五笔打字：可能打拼音的同学不以为然。在你频繁地使用中文时，用五笔所带来的效率感，以及大脑省略掉语音过程而能提供的宁静，非拼音输入爱好者所能体验。另外，我是也是带着强烈的敬意来使用这个输入法的，它的实现绝对是个经典的算法、经典的大数据解决方案！作者王永民的解决过程非常地励志。能在微软系统里顽强生存下来的中文东西，只有它。</p>



<p>三、HTML： 很多人不把它当作语言看待，实际上它才是当今的语言之王，它的复杂性和重要性一点也不比常规语言低。很多程序员之所以在职业上有失败，盖因没看透这点。在HTML生态里，需要JS功夫，需要P图功夫，需要配色布局功夫，而程序员若仅仅会龟缩在那个方寸之内的服务端脚本里，就完蛋了。理想化的前后端工程师分工，仅在BAT类的公司里有机会。全栈型的的确有明显优势。如果做一件事，会遇到超过三个以上的难点，这种类型的事就是你的新职业技能，你应感到高兴而不是躲避学习。（真的有很多程序员不喜欢打理那一堆烂面条似的网页标签，更不喜欢去P图，实际上这些基本功一旦掌握，将给他带来多大便利，他从未体验过！，打个比方，我知道你注定不会去开出租，然而，当你学会驾驶，你的自由度将有多大）。</p>

<p>算法作为高级技能看待，强求精通会带来职业障碍。</p>

<p>Windows 2000泄露的源代码，我记得有不少是MFC的。</p>



<p></p>



<p>Visual Studio 6，2003，2005，2008，我一直以为是MFC界面。</p>



<p>Visual Studio 2010，2012，2013，2015，我一直以为是WPF界面。</p>



<p></p>



<p>Office 97, 2000，2003，我一直以为是MFC界面。用Spy++看过，有窗口句柄，至少不全是DirectUI。</p>



<p>Office 2007，2010，明显风格不同于以前，属于DirectUI。</p>



<p>Office 2013，使用了.NET框架，但界面是WPF还是DirectUI的呢？</p>



<p>其实无所谓了，我想如果微软还在用DirectUI，DirectUI的界面描述语言也应该是Xaml了，Xaml也是DirectUI不断发展的成果。</p>

<p>从MFC的思想优越感到Win32的底层优越感，都是沉浸在单机时代里的幻觉，终归都是封闭世界里的优越感。</p>



<p>从MFC到Windows API只是程序人生的一小步，MFC是Win API的封装，但不是唯一的封装。GDI也不是唯一的图形接口，并且DirectX是更强大的图形接口，想想那些对图形显示要求更高的游戏是DirectX开发的。我再重复说一遍，MFC是用GDI画的，Xaml是用DirectX画的。</p>

<p>AutoCAD 2010是.NET Framework 3.5，AutoCAD 2013也是.NET Framework 版本 4.0 了。</p>

<p>当然不是必须的，还有C++/CLI，QT，Win32，...</p>



<p>但是MFC比CLI门槛低，比QT资料多，比Win32开发快，所以对于用C++的新手，MFC是最好的选择。</p>

<p>一开始只知道MFC，就是看不懂，后来学了下《WINDOWS程序设计》和《MFC windows程序设计》和《vc技术内幕》后，才逐渐明白MFC。不过只是用来做界面，用Directx3d做3d。去年，才兼职参与了第一个能挣钱的项目，对方要求用QT+OSG，由我和另一个程序员两个人做。另一个程序员不会OSG，也不会QT，只会MFC和DIRECT3。我当时犹豫了半天，参与否？osg我比较熟悉，QT是压根不懂。参与吧，怕完不成，不参与吧，机会丧失。我下定决心，还是自学QT，于是参照MFC，三天内就大概知道了QT的用法，顺利完成了项目。目前兼职的项目，使用QT+OSGEARTH，可以说和MFC不搭界。但是，在MFC中学到的思想，以及信念，MFC都学会了，还怕QT？</p>

<p>windows平台的360也不是用mfc开发的用的是DirectUI这个开发库</p>

<p>另外，从软件水平来说。技术水平最高的，很显然在互联网公司。以前听到oracle的数据库，大家都肃然起敬。可是，互联网公司，出于需要，不但用改造过的mysql换掉oracle 。甚至自己开发分布式数据库（比如goolge 比如淘宝，比如京东）。以前想都不敢想的事情。在互联网公司基于自己的需要下，自然就做出来了。</p>

<p>用MFC的(虽然我不用，用的是WTL)，可以用擅长的C++语言，可以方便的调用C/C++类库（系统或第3方），可以嵌入各种脚本语言，可以方便极致的优化。当然如果一开始就学的C#，真的没有必要再学MFC。当然qt作为界面开发也行，但是这个库实在过于庞大，和STL也没什么事了，所以我推荐如果要用，可以用WTL开发界面，简单的对Win32封装。而且只是界面，其他库完全可以用stl或第3方库什么的。</p>

<p>Windows搞界面就选这几个，如果是C++为主要语言：wtl，duilib，qt(qt真心不建议，qt的学习成本也不低，不过好在难逆向)</p>

<p>从Windows7时代以来，Managed C++与XAML的组合，必将逐渐替代MFC的固有位置，原来大家可能要用MFC来做的事情，现在会有更多的选择，许许多多的新的技术，新的工具，新的总是更好用，而且由于不用背负历史的负担，包袱轻，所以一上来就可以按照最现代的方法去设计。所以新手学习新的工具是非常好的。</p>

<p>反正，不管你们怎么唱衰MFC，但MFC一时半会儿也死不了，再过十年也死不了，甚至到某些人将来已经从程序员、软件工程师的职位上改行去做别的事情、完全脱离了IT业，到那时MFC说不定也还活得很好，在工控领域、在航空领域、在能源化工生产制造领域，依然发挥着中坚力量。</p>

<p>其实在工控领域，MFC也在受到新技术的威胁。你所说的那种XAML的技术，其实在工控领域，也在涌现出类似的技术。有一种图形界面开发技术，名称我就不说了，业内的人都知道，不是业内的人知道也没用。这种技术，是用类似于XML的语法去定义一个界面，然后靠一个底层的引擎去渲染出一个界面来，而底层用的其实是OpenGL。这种界面技术运行也非常高效，非常稳定，而且在现代的飞机上，驾驶舱里面，大量采用的就是这种技术。这种图形界面技术可以移植到PC上、VxWorks操作系统、Linux系统，甚至我们公司自己写的RTOS，也移植了这种图形界面技术。</p>

<p>如果数据结构，网络技术，c++是必修课，是基础。  mfc只是选修课，一个window平台的编程框架。要不要学习这门工具看工作需要。在移动应用火热的今天。还让新人守着mfc，是误人子弟。就算学window编程，也先学习基础的win32编程，轮不上mfc。</p>

<p>我们用代码操作文件的时候可以把文件理解为有序字符的集合，其基本单位是字符，长度为该文件包含的字符的个数。</p>

<p>硬件是一些特殊开关（晶体管、特别小（纳米级），数量特别多）的特殊组合（逻辑门→加法器（包括记忆电路）→模板→五大部件）提供或实现了一个指令指，软件就是用用这个指令指按编程语言的规则去组合，去实现基础功能（驱动与操作系统）和应用功能（应用程序）。</p>

<p>【2】简述寄存器、主存储器和外存储器的异同点。 </p>



<p>【解】 寄存器、主存储器和外存储器都是用于存储信息，但级别不同。从功能来讲，寄存器存储的是运算器当前正在运算的数据或当前正在执行的那条指令。主存储器保存的是正在运行的程序代码和数据。外存储器保存的是需要长期保存的数据。从容量角度来讲，寄存器容量最小，内存次之，外存储器最大。从访问速度来讲，寄存器最快，内存次之，外存最慢。 </p>



<p>【3】所有的计算机能够执行的指令都是相同的吗？ </p>



<p>【解】 计算机能够执行的指令是直接由硬件完成的，与硬件设计有关。不同的硬件设计产生不同的指令系统。因此，不同类型的计算机所能执行的指令是不同的。 </p>



<p>【4】投入正式运行的程序就是完全正确的程序吗？ </p>



<p>【解】程序的调试及测试不可能将程序所有的路径、所有的数据都执行一遍，因此只能发现并改正程序中的某些错误，而不能证明程序是正确的。 </p>



<p>【5】为什么需要编译？为什么需要链接？ </p>



<p>【解】计算机硬件能“认识”的只有机器指令，它并不认识程序设计语言，如C++。要使计算机能够执行C++写的程序，必须把C++的程序翻译成计算机认识的机器语言，机器语言版的程序称为目标程序。源程序到目标程序的翻译是由编译器完成的。 </p>



<p>程序员编写的程序通常会用到其他程序员或C++系统已经编好的一些工具，程序运行时会用到这些工具的代码。需要将目标文件和这些工具的目标文件捆绑在一起，这个过程称为链接。链接器就是完成这个链接工作。链接以后的代码称为一个可执行文件。这是能直接在某台计算机上运行的程序。 </p>



<p>【6】调试的作用是什么?如何进行程序调试？ </p>



<p>【解】调试的作用是尽可能多地找出程序中逻辑错误，使程序能给出正确的答案。调试一般需要运行程序，通过观察程序的阶段性结果来找出错误的位置和原因，并改正错误。 </p>



<p>【7】试列出一些常用的系统软件和应用软件。 </p>



<p>【解】常用的系统软件有：操作系统、编译系统、数据库系统等。应用软件又分成通用的应用软件和专用的应用软件。通用的应用软件提供一些常规的应用，如文字处理软件word，媒体播放软件Media Play等。专用的应用软件是某个领域专用的一些软件，如银行系统、证劵交易系统等。 </p>



<p>【8】为什么在不同生产厂商生产的计算机上运行C++程序需要使用不同的编译器。 </p>



<p>【解】因为不同的生产厂商生产的计算机有不同的机器语言，所以需要不同的编译器将同样的C++程序翻译成不同的机器语言。 </p>



<p>【9】什么是源程序？什么是目标程序？为什么目标程序不能直接运行？ </p>



<p>【解】用某种程序设计语言写的程序称为源程序，源程序经过编译产生的机器语言的程序称为目标程序。因为程序可能用到了一些其他程序员写好的程序，没有这些工具程序的代码整个程序就无法运行，因此需要将目标程序和这些工具的目标程序链接在一起后才能运行。 </p>



<p>【11】为什么不直接用自然语言和计算机进行交互，而要设计专门的程序设计语言？ </p>



<p>【解】自然语言太复杂，而计算机本身（机器语言）的功能又非常简单，如果要将自然语言作为人机交互的工具，编译器的设计与实现必将非常的复杂。另外，自然语言太灵活，理解自然语言需要一些背景知识，否则会产生二义性，这也给计算机实现带来了很大的麻烦。 </p>



<p>【12】试列举出高级语言的若干优点（相比与机器语言）。 </p>



<p>【解】首先高级语言更接近于自然语言和人们熟悉的数学表示，学起来比较方便。其次高级语言功能比机器语言强。一般的机器语言只能支持整数加法、移位、比较等操作，而高级语言能执行复杂的算术表达式、关系表达式和逻辑表达式。高级语言可以使程序员在较高的抽象层次上考虑问题，编程序比较容易。第三，高级语言具有相对的机器独立性，在一台机器上用高级语言编写的程序可以在另外一台不同厂商生产的计算机上运行，这使得程序有较好的可移植性，有利于代码重用。 </p>



<p>【13】为什么不同类型的计算机可以运行同一个C++程序，而不同类型的计算机不能运行同一个汇编程序？ </p>



<p>【解】因为不同类型的计算机上有不同的C++编译器，可以将同一个C++程序编译成不同机器上的机器语言表示的目标程序。而汇编程序仅是机器语言的另一种表现形式。不同类型的计算机有不同的机器语言，也就有不同的汇编语言。 </p>



<p>【14】机器语言为什么要用难以理解、难以记忆的二进制比特串来表示指令，而不用人们容易理解的符号来表示？ </p>



<p>【解】因为计算机是由逻辑电路组成的，而0、1正好对应于逻辑电路中的两种电平信号，可以直接翻译成控制信号，使计算机硬件实现比较容易。如果采用人比较容易理解的符号，如英文、中文或者数学符号，则计算机需要用硬件将这些符号翻译成控制信号，使硬件设计非常复杂，甚至无法实现。 </p>



<p>【15】为什么电视机只能播放电视台发布的电视，DVD播放机只能播放DVD碟片，而计算机却既能当电视机用，又能当DVD机用，甚至还可以游戏机用？ </p>



<p>【解】电视机只能播放电视台发布的电视，DVD播放机只能播放DVD碟片，这是因为设计时已经规定好它们的功能。而计算机有一个开放的平台，具有学习的功能，可以允许程序员“教会”它们新的知识和技能。只要编写了能完成相应功能的程序，计算机就具备了相应的功能。</p>

<p>【1】程序开头的注释有什么作用？ </p>



<p>【解】程序开头的注释是对程序整体的介绍。一般包括源文件的名称、程序的功能、作者、创建日期、修改者、修改日期、修改内容等。程序注释还可以描述程序中特别复杂的部分的实现方法和过程，给出如何改变程序行为的一些建议等。当程序在将来的某一天需要修改时，程序员可以通过这些注释而不是程序本身来了解程序是如何工作的。 </p>



<p>【2】库的作用是什么？ </p>



<p>【解】库是一些常用工具的集合，这些工具是由其他程序员编写的，能够完成特定的功能。当程序员在编程时需要用到这些功能时，不需要再自己编程解决这些问题，只需要调用库中的工具。这样可以减少重复编程。 </p>



<p>【3】在程序中采用符号常量有什么好处？ </p>



<p>【解】采用符号常量主要有两个好处：提高程序可读性和可维护性。 </p>



<p>【4】C++有哪两种定义符号常量的方法？C++建议的是哪一种？ </p>



<p>【解】第一种是C语言的风格：#define 符号常量 值 </p>



<p>第二种是C++语言的风格：const 类型 符号常量 = 值； </p>



<p>C++建议用第二种。用#define定义符号常量有两个问题：一是所定义的符号常量无法进行类型检查；二是#define的处理只是简单的字符串替换，可能会引起一些意想不到的错误。而C++的风格指明了常量的类型，同时是将右边的表达式的值计算出来后再与符号常量关联起来。例如有定义 </p>



<p>#define ABC 3+5 </p>



<p>程序中有语句 </p>



<p>x = 3 * ABC; </p>



<p>则x 的结果是14，即3 * 3 + 5，而不是24，即3 * 8。但如果用 </p>



<p>const int ABC 3+5 </p>



<p>则结果是24。 </p>



<p>【5】C++定义了一个称为cmath的库，其中包括常用的数学函数。要访问这些函数，需要在程序中引入什么语句？ </p>



<p>【解】需要有一个编译预处理命令：#include &lt;cmath>，表示程序用到这个库。 </p>

<p>(程序中使用的函数从开发者的角度理解，只有两种，或者是库提供的，或者是你自己开发的。）</p>



<p>【8】简单程序通常由哪三个阶段组成？ </p>



<p>【解】简单程序通常由输入阶段、计算阶段和输出阶段组成。输入阶段接收用户输入的需要加工的数据。计算阶段将输入的数据加工成输出数据。输出阶段将加工后的数据输出给用户。 在编写程序时，最好在各阶段之间插入一个空行，使程序逻辑更加清晰。 </p>



<p>【9】一个数据类型有哪两个重要属性？ </p>



<p>【解】第一个是该类型的数据在内存中是如何表示的，第二个是这类数据允许执行哪些操作。 </p>







<p>【11】算术表达式 true + false 的结果是多少？结果值是什么类型的？ </p>



<p>【解】布尔型数据在执行算术运算时会先被转换成标准的整型然后执行整型运算，true转换位1， false转换为0，所以true+false的结果是整型1。 </p>





<p>【17】在一个变量赋值之前，可以对它的值做出什么假设？ </p>



<p>【解】可以假设它的值是一个随机值。</p><p>阅读代码习惯：从主函数开始；如果有函数嵌套，从内部函数开始。</p><p>为了有效地完成数据存储任务，需要对存储器做如下处理：</p>

<p>1 划分：以字节（8个位bit，对应8个开关晶体管，0或1）为单位将存储器划分为一系列的存储单元。</p>

<p>2 编址：以线性方式给每个存储单元赋予唯一的存储地址，可以随机访问。</p>

<p>3 数据存储约定：数据以二进制形式放入存储空间，需要约定数据的存储空间大小、存储空间地址、数据编码和解码方式以及字节排序方式。如一个基本类型需要多字节时，用大头地址还是小头地址做为数据的地址？</p>

<p>3.1 数据的编码和解码方式</p>

<p>I 以补码方式存储整数；</p>

<p>II 通过ASCII编码方式存储字符；</p>

<p>III 以real-4或real-8方式存储浮点数（实数或小数）；</p>

<p>3.2 大头还是小头，按理说只要统一约定就好，但是Intel公司的机器多采用小头方式，IBM、Sun等公司采用大头方式。一般情况下，可以不考虑字节排序方式的问题，但是在针对网络应用编写程序时，就必须关注使用哪种字节排序方式，这是因为网络程序通常需要在不同类型的机器之间交换数据。</p>

<p>为什么是不个bit为一个byte做为最小（基本）的存储单元呢？2^3=8,指数计算方便，另位2^8=256，能够包含全部英文字母+数字+一些基本常用的符号。</p><p>程序核心的内容就是数据表示和存储，以及对这些数据的运算，表现为运算符和函数，对于一个高级语言，及其编译器和IDE，运算符可以理解为一种特殊的函数，一种基本数据类型可以使用特定的运算符，这已经由编译器实现，另外，一些标准的数据结构和操作也通过标准函数库或类库来实现，通常包含在IDE中，或由用户下载配置进来，程序员所有做的工作就是在此基础上的编程。</p><p>程序是一个字符序列、一个单词序列、一个语句序列、一个函数集合、一组文件；</p><p>数据＝数据地址（变量）+数据规格（类型）</p>

<p>数据规格：存储空间大小、编码和解码方式｜可接受的运算处理</p><p>字面量一般作为代码的一部分，字符串例外，存储在内存的数据段内存空间中。</p><p>表达式语句：描述数据的基本运算处理；</p>

<p>流程控制语句：描述数据处理的流程逻辑；</p>

<p>输入输出流类库：描述数据的输入输出处理；</p>

<p>函数：通过数据处理实现某种功能；</p><p>为了存储输入并像平时那样用草稿纸来演算，计算机提供了存储器。</p><p>每个字节都代表一个能容纳8个二进制位的内存位置。那么，8有何特别之处？有两个原因使8显得很特殊。首先，8是2的3次方。由于计算机在最底层使用的是二进制位，而每一位只有两个可能的值，所以2的乘方用起来比10的乘方更方便。其次，需要8位(1个字节)才能对一个字符(比如一个英语字母或其他键盘符号)进行编码。</p><p>更复杂的程序要求能以某种方式改变语句执行顺序。语句执行顺序通常称为控制流程或控制流。</p><p>如果在一个程序中一个字面量需要多次使用，建立给这样的一个字面量命名为常量const。</p><p>switch 语句尤其适合用来实现菜单。</p><p>有4 种常用的方法终止输入循环。</p>

<p>(1) 已知长度的列表。</p>

<p>(2) 每次迭代都询问。</p>

<p>(3) 以哨兵值结束的列表。</p>

<p>(4) 判断是否用完所有输入。</p><p>for 循环可实现“重复循环主体n 次”。</p>

<p>? 通常用4 种方法终止输入循环：已知长度的列表、每次迭代都询问、以哨兵值结束的列表和判断是否用完所有输入。</p>

<p>? 一般最好用伪代码设计循环，不要事先指定具体的C++循环语句。一旦设计好算法，就很容易决定具体应该选择什么C++循环语句。</p>

<p>? 为了简化嵌套循环，一个办法是将循环主体转变成函数调用。</p>

<p>? 一定要确保循环使用的变量在循环开始之前正确初始化。</p>

<p>? 一定要确保循环不会多迭代或者少迭代一次。</p>

<p>? 设计循环时，可考虑在循环主体中对关键变量进行跟踪。</p>

<p>? 如果程序或算法很难理解，或者执行效率很差，不要试图去修正它。彻底丢弃并重新设计一个。</p><p>函数作为黑盒（使用者视角）来编写和使用，这也称为过程抽象。用C++进行程序设计时，称为函数抽象似乎更恰当。但“过程”这个术语比“函数”还要常规。计算机科学工作者用“过程”一词表示所有“函数风格”的指令集，所以他们使用了“过程抽象”这一说法。“抽象”是指，将函数当作一个黑盒使用时，实际是对函数主体代码的细节进行提炼(抽象)。可将这种技术称为黑盒原则、过程抽象原则或者信息隐藏。三个术语的含义一样。不管怎样称呼，最重要的是在设计和编写函数定义时采用这种技术。</p><p>应用于函数定义时，过程抽象原则是指你写的函数应该能像一个黑盒那样使用，也就是说，使用该函数的程序员不需要查看函数定义主体来了解函数的工作原理。程序员为了使用这个函数，只需查看函数声明及其注释。为了确保函数定义具有这一重要的属性，应严格遵守以下原则。</p>

<p>怎样写返回值的黑盒函数定义</p>

<p>在函数声明的注释中，指出对函数实参的所有要求，并指出用这些实参来调用函数，函数的返回值是什么。</p>

<p>函数主体使用的所有变量都应该在函数主体中声明(形参不需要声明，因为它们已在函数声明中列出)。</p><p>任何时候要将一个循环嵌套到另一个循环中，或需在循环主体包括其他任何复杂计算，都考虑是否用一个函数调用代替。这样就可将复杂计算和程序其余部分分开，将编程任务分解成两个较小的子任务。</p><p>设计算法最有效的手段是将任务分解成多个子任务，再将每个子任务分解成更小的子任务，依此类推。最终，子任务会变得非常小，很容易用C++代码实现。这种设计方法学称为自顶向下设计。如果分治算法中的归并排序一样。</p><p>递归，为什么要使用栈这种数据结构来在内存中存储？关键是“归”的要求， 要能回得去，就得是“后进先出”。</p><p>调用函数时，实参会替换函数定义中的形参。通俗地说，实参在形参位置“代入”。有几种代入机制。</p><p>程序变量作为内存位置实现。编译器为每个变量都分配一个内存位置。</p><p>要使形参成为传引用参数，需在其类型名称后添加符号&。对应地，在函数调用中，传递的实参应该是变量，而不能是常量或其他表达式。调用函数时，实参变量(而不是该变量的值)会替换形参。调用函数期间，函数主体对形参的任何更改都会作用于实参变量。</p><p>(1) 函数形参在函数声明中列出，在函数定义主体中使用。任何形参都是一种空白位置或者占位符，会在函数调用时被别的东西填充。</p>

<p>(2) 实参用于填充形参。写函数调用时，实参在函数名后的圆括号中列出。执行函数调用时，实参会在形参的位置“代入”(或者说“插入”)。</p>

<p>(3) “传值调用”和“传引用调用”这两个术语是“代入”过程的具体机制。传值调用机制只使用实参的值。这种机制中，向形参(局部变量)传递的是实参的值。而传引用调用机制传递的是变量本身。这种机制中，实参变量会替换形参，故对形参的任何更改实际都会作用于实参变量。</p><p>为函数声明写注释时，一个好办法是将其分解为两种信息，即前条件和后条件。前条件(precondition)指出调用函数需满足什么条件。除非满足前条件，否则不要调用函数；强行调用不保证会正确执行。后条件(postcondition)描述函数调用结果。也就是说，在满足前条件的前提下，后条件指出函数执行后会达成什么条件。对于要返回值的函数，后条件应描述返回值。对于要对实参变量进行修改的函数，后条件应描述对实参进行的修改。</p><p>前条件和后条件不仅是总结函数行动的一种手段，还是设计和编写函数的第一步。先用注释描述程序要做什么，再在函数定义中指定具体如何做。如果发现不能以合理的方式实现设计规范，就回头重新思考函数应该做什么。无论如何，事先想清楚对函数的要求，既有助于减少设计错误，还能防止浪费时间写无用的代码。</p><p>程序所有子任务都可作为函数实现，要么实现成返回值的函数，要么实现成void 函数。</p>

<p>形参是占位符，调用函数时由实参填充(替换)。有两种替换方式：传值调用和传引用调用。</p>

<p>传值调用替换形参的是实参的值；传引用调用实参应该是变量，替换形参的是变量本身而非变量的值。</p>

<p>要在函数定义中指定传引用参数，方法是在形参的类型名称后附加符号&。</p>

<p>与传值参数对应的实参不会被函数调用更改，与传引用参数对应的实参可以被函数调用更改。函数要更改变量的值需使用传引用参数。</p>

<p>注释函数声明时，一个好办法是使用前条件和后条件。前条件指出函数调用时要满足什么条件。后条件描述函数调用结果。也就是说，在满足前条件的前提下，后条件指出函数执行后会达成什么条件。</p>

<p>测试某函数时，程序中的其他所有函数都应已通过了全面的测试和调试。</p>

<p>驱动程序是专门用来测试函数的程序。</p>

<p>存根函数是函数的简化版本。存根函数替代尚未测试(或尚未写好)的函数定义，先让程序的其余部分能进行测试。</p><p>push为入栈命令。 </p>

<p>pop为出栈命令。 </p>

<p>栈命令都跟伴随栈指针的移动。 </p>

<p>mov在此过程中将一个寄存器中的值移到另一个寄存器。 </p>

<p>call可以理解为goto。并将它的下一行指令地址存到栈中。 </p>

<p>leave为mov+pop。为退出栈机制的重要一环。 </p>

<p>ret也可以理解为goto。并移动栈指针。</p><p>存储单元编址：只是将存储器划分成一系列字节单元还不够，为了快速方便地在存储器中标识和定位存储单元，写入和读出其中的数据（即数据的存取访问），还需给每个存储单元编上唯一的号码，称为存储地址。采用的编址方案非常简单－线性编址方案。</p>

<h4>数据的存储约定</h4>

<p>容许一个数据占据多个连续的存储单元，称为数据的存储空间。</p>

<p>显然，我们必须把多个字节的存储单元组合拼接起来，才能得到完整的数据。因此要存储一个数据，我们必须回答关于数据存储空间的一些问题。</p>

<p>1 我们的数据有多大，需要占据多少个存储单元。如win32约定4个字节存储一个int类型的整数。</p>

<p>2 用哪相存储单元的地址，作为数据存储空间的地址。多个存储单元中最小的那个地址，就是数据的存储空间地址。</p>

<p>3 数据怎么变成二进制形式，以及二进的，形式怎样变回来。如数据的补码、ASCII编码的方式。</p>

<p>4 多个字节的数据按何种顺序旋转到多个存储单元中。</p>

<p></p>

<p>编程的思维方式：过程化思维：描述数据以及描述数据的处理过程。</p>

<p>描述数据：说明求解问题需要哪些数据，这些数据的规格是什么样的。</p>

<p>描述数据的处理过程：说明数据如何输入、如何加工处理以及如何输出处理结果的过程，包括输入数据、处理数据和输出结果三个环节。</p>

<p>针对描述数据，C++语言首先提供了变量的概念，用来记住数据所在的存储空间的地址，通过变量我们可以方便地对数据进行存取访问。</p><p>用户处理的数据往往需要存盘作永久备份。将文档类中的数据成员变量的值保存在磁盘文件中，或者将存储的文档文件中的数据读取到相应的成员变量中。这个过程称为序列化(Serialize)。</p><p>pyecharts是一个封装百度开源图表库echarts的包，使用pyecharts可以生成独立的网页，也可以在flask、django中集成使用。</p><p>进程之间通信的途径主要有以下3种： </p>

<p>共享存储系统； </p>

<p>消息传递系统； </p>

<p>管道：以文件系统为基础。</p>

<p>操作系统中进程调度策略有FCFS（先来先服务）、优先级、时间片轮转和多级反馈。</p><p>事物总有优、劣两面性，不可能事事完美，所以必须权衡和取舍。</p>

<p>编程语言语言就是这样。</p>

<p>弱类型语言比强类型语言的优势、劣势、分别是什么？能用两种语言如 PHP 和 C# 举例论证吗？</p>

<p></p>

<p>弱类型语言的编译器可以自动推断类型，学习简单，语言表达简单易懂，代码更优雅，开发周期更短，更加偏向逻辑设计。但是，变量混乱，运行效率低下，更容易出BUG，难以调试。</p>

<p>相反强类型语言，对于类型和存储的约束使得学习成本上升，开发效率比较低下，代码设计必须考虑存储问题，但是程序可靠，调试简单，变量更加规范。</p>

<p>所以强类型语言就要考虑相同功能的函数（按道理应该取同样的函数标识符）因为参数类型不同而要考虑标识符重用，其语言机制就是函数重载，只要参数类型不同或者参数个数不同，就可以使用相同的函数名，编译器可以按参数的不同而调用不同的版本。</p><p>在构建应用程序时的一大问题是能否在不需要重新构建的情况下随时调整应用程序的功能。很久以来我们一直使用配置文件来控制应用程序的运行方式。.NET应用程序同样使用一系列XML配置文件来控制应用程序的行为。</p><p>信息系统模块：基本数据输入模块、业务数据输入模块、查询模块、管理模块等；</p><p>变量定义，如static unsigned short int i</p>
<p>告诉编译器在何处（i）创建变量，以及如何创建(static unsigned short int）,包括空间大小、编码解码方式、作用域和存续期、链接域（定义的位置也有影响），还可以使用的限定符有：unsigned、long、static、extern。何处，也就是内存地址，编码器将一个内存地址与i隐式关联，可以是在全局静态区、栈区，取决于限定符及语言在代码的代码块中的位置。</p><p>变量的声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明使用extern，在多文件中，声明变量在其他文件中有唯一定义，这里使用的是其他文件中定义的那个名字。在单文件中，声明在此处的语句块的外面有唯一全局的定义，这里是使用外面定义的名字。</p><p>32机的地址采用32位的寻址方式，一个地址占32位，即4个字节。</p><p>Data type are proceeds in many functions in a structured program. When changes occur in those data types, the corresponding change must be made to every location that acts on those data types within the program. This is really a very time consuming task if the program is very large.</p>
<p>Let us consider the case of software development in which several programmers work as a team on an application. In a structured program, each programmer is assigned to build a specific set of functions and data types. Since different programmers handle separate functions that have mutually shared data type. Other programmers in the team must reflect the changes in data types done by the programmer in data type handled. Otherwise, it requires rewriting several functions.</p><p>1980年的数据是： 0x095b0二进制：0000 1001 0101 1011 0000 表示1980年没有闰月，从1月到12月的天数依次为：30、29、29、30 、29、30、29、30、 30、29、30、30。</p>
<p>1982年的数据是：0x0a9740000 1010 0 1001 0111 0100表示1982年的4月为闰月，即有第二个4月，且是闰小月。从1月到13月的天数依次为：30、29、30、29、?29(闰月)、 30、29、29、30、 29、30、30、30。</p>
<p>从后开始：</p>
<p>1-4: 表示当年有无闰年，有的话，为闰月的月份，没有的话，为0。</p>
<p>5-16：为除了闰月外的正常月份是大月还是小月，1为30天，0为29天。</p>
<p>            注意：从1月到12月对应的是第16位到第5位。</p>
<p>17-20： 表示闰月是大月还是小月，仅当存在闰月的情况下有意义。</p><p>加载动态链接库，将代码和数据映射到进程的地址空间中。</p><p>存储器需要按字节划分和线性编址，并约定数据的存储空间的大小、地址、数据编码和解码方式，以及数据内容的字节排序方式。</p><p>汇编语言引入助记符代替机器语言中的二进制指令码和存储地址。</p><p>开发应用程序首先要选择开发环境，然后选择应用程序框架；</p><p>开发包括不同OS的桌面应用、浏览器、移动端、移动浏览器端，且都分客户端、服务端。还有云计算、大数据、AI、VR，以及工控、嵌入端等；</p><p>BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化，或初始化为0的全局变量，静态局部变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。</p>
<p>数据段：数据段（data segment）通常是指用来存放程序中已初始化为非0的全局变量的一块内存区域。数据段属于静态内存分配。</p>
<p>代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<p>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<p>栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p><p>MinGW，是Minimalist GNUfor Windows的缩写。它是一个可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合，允许你在GNU/Linux和Windows平台生成本地的Windows程序而不需要第三方C运行时（C Runtime）库。MinGW 是一组包含文件和端口库，其功能是允许控制台模式的程序使用微软的标准C运行时（C Runtime）库（MSVCRT.DLL）,该库在所有的 NT OS 上有效，在所有的 Windows 95发行版以上的 Windows OS 有效，使用基本运行时，你可以使用 GCC 写控制台模式的符合美国标准化组织（ANSI）程序，可以使用微软提供的 C 运行时（C Runtime）扩展，与基本运行时相结合，就可以有充分的权利既使用 CRT（C Runtime）又使用 WindowsAPI功能。</p><p>只有从业十年以上的程序“老猿”，才懂这十五条IT定律</p>
<p>1.软件开发这个行业里，人们总是在做重复的事, “假装”自己在发明新的东西。</p>
<p>若你觉得有个东西很酷炫新奇, 那它肯定是从Smalltalk, HAKMEM, Ivan Sutherland, Douglas Engelbart, 早期的IBM, 或者Bell 实验室其中之一抄来的.</p>
<p>2.别相信编译器, 别相信工具, 别相信文档, 也别相信你自己.</p>
<p>3.我们不需要更多的编程语言! 但是还是会有人跑去发明一个新的语言。而那个超酷的新语言肯定还是用的IEEE-754浮点数, 和定宽整数吧.</p>
<p>4.维护旧代码比写代码困难的多. 写很多很多新代码其实只是在犯懒.</p>
<p>5.我们学习到的知识是, 内存, cpu, 带宽都是无限和免费的. 实际上不是这样的, 推荐读读 Knuth的 prematrue optimization 相关的文字.</p>
<p>6.几个月之后你就会忘记你当时为啥写那段代码… 写的时候能写多直白就多写多直白(建议: 永远低估几月后自己的智力准没问题的).</p>
<p>7.有时候一行sed命令就够了.</p>
<p>8.如果谁跟你说他的方案绝逼是最好最快的, 你得明白一点， 编程是个艺术不是宗教.</p>
<p>9.如果你觉得有个事情你要重复做10次以上, 就立刻把它做成自动化的!(其实大概3次就该考虑了)</p>
<p>10.备份是一个事情, 而恢复备份是完全不同的另外一个事情!</p>
<p>11.在你自己的电脑上可以运行不代表没有bug. - Piers Sutton.</p>
<p>12.想要装一个新工具的话, 等0.1版本出来再说, 小白鼠就让别人去做把。</p>
<p>13.好的程序员写好的代码. 杰出的程序员不写代码. 大师程序员删代码.</p>
<p>14.出问题时, 别管有多少领导正在朝你吼着训话, 第一件事情总应该是稳定复现bug.</p>
<p>15.或早或晚, 你会遇到一个经验丰富的前辈, 偶尔他会向你传授 Laws of Programming.然后你可以让他滚一边去.</p><p>内存：线性编址方案；</p>
<p>数据的存储约定：约定数据的存储空间大小（数据类型）、存储空间地址（变量名称）、数据编码和解码方式（数据类型）、字节排序方式（大头方式还是小头方式）；</p><p>可以编码解码为数据，也可以是指令。</p><p>常变量可以理解为可寻址的字面量。字面量都是不可寻址的，但用常变量可以寻址。</p><p>函数调用时的堆栈使用：</p>
<p>1 每个函数战胜一个连续的区域，称为帧frame</p>
<p>2 进入函数前，保存“返回地址”和变量；</p>
<p>3 进入函数后，保存实参或实参复制、局部变量；</p>
<p>4 实参列表从右至左入栈，从右至右出栈；</p><p>面向对象是把数据和对数据的操作方法放在一起，作为一个相互储存的整体，即对象。对同类对象抽象出其共性，即类，类中的大多数数据只能被本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。</p><p>面向过程是一个以事件为中心的开发方法，就是自顶向下顺序执行，逐步求精，其程序结构是按功能为若干个基本模块，这些模块形成一个树状结构，各模块之间的关系也比较简单，在功能上相互独立，每一模块内部一般都是由顺序、选择和循环三种基本结构组成的，其模块化实现的具体方法就是使用子程序，而程序流程在写程序时就已经决定。</p><p>面向过程主要是强调过程的抽象化和模块化。各模块之间存在控制与被控制、调用与被调用的关系。</p><p>程序设计中的层次关系：面面过程设计时的函数分解，类的继承关系都是一种层次关系。</p><p>数组元素的下标、结构体、类的成员数据变量名，对于内存映像来说，相当于索引。</p><p>对于数组的大部分操作，都是对其索引的操作，确定了索引号，也就确定了其元素值。</p><p>程序的运行结果在输出保存到文件后，可以将这些数据作为本程序或其它程序的输入数据，再次进行处理。</p><p>文件通常是驻留在外部介质（如磁盘等）上，在使用时才调入内存中来。从不同的角度可对文件进行不同的分类。</p><p>Windows操作系统所能够完成的每一个特殊功能通常都有一个函数与其对应。也就是说，操作系统把它所能够完成的功能以函数的形式提供给应用程序使用。应用程序对这些函数的调用就叫做系统调用。这些函数的集合就是Windows操作系统提供给应用程序编程的接口（Application Programming Interface），简称Windows API。</p>
<p>API是函数，是用某一种语言写的函数，如C，可以与Windows系统交互的函数。</p><p>程序运行时，加载到内存，并给数据开辟栈内存空间，运行时还可以动态开辟堆内存空间。</p><p>最简单的函数定义，有返回值的函数，定义一条return语句；无返回值的函数，定义一条输出语句，如cout或printf()。</p><p>十进制补码：就是模数-需要补码的数字，如13的补码，99+1－13=87</p>
<p>二进制补码：101的补码：111+1-101=11(也就是十进制的8-5)</p><p>load：内存→寄存器；</p>
<p>store：寄存器→内存；</p><p>二进制代码形式的语言称为机器语言。早在计算机诞生之初，人们就是直接用机器语言编程。但是，这种在计算机看来十分明了的机器语言程序，在人看来却是一部“天书”。后来，人们又将3个二进制位合并在一起变成了八进制。再后为，为了与字节对应，又将4个二进制位合并在一起变成了十六进制。将机器语言写成八进制，或十六进制形式，要比二进制形式“好看”一些。</p>
<p>随着计算机应用不断扩大，程序需求量大增，编程工作量也越来越大，人们便产生了用符号代表机器指令的想法，设计出汇编语言（Assemble Language，又称符号语言）。比如，用ADD表示加法指令，用SUB表示减法指令，要比用二进制0\1序列“00111011”表示某一条指令直观得多。用汇编语言编写的程序称为汇编程序。将汇编程序送入计算机，由计算机自动地将汇编源程序翻译成计算机能够直接执行的二进制程序，而计算机的自动翻译功能是由专门的软件－－汇编程序（Assembler，又称汇编器）完成的，当然，这个软件也是人们事先编写的，并安装在计算机系统中。一台计算机配上汇编程序就相当于人们“教会”计算机认识汇编语言了。再后来，人们又设计出反汇编程序，它能将机器语言程序反过来翻译成汇编语言程序。通过反汇编，人们就可以读懂安装在计算机中的可执行程序。</p><p>使用汇编语言减轻了不少人们的编程工作量，但是，汇编语言仍然十分原始，一条 汇编语句（也称为汇编指令）对应一条机器指令，易读性仍然很差。编制一个程序，哪怕只是用来完成简单计算任务的程序，通常需要成百上千条汇编指令。不仅编程效率低，程序不易调试，而且容易出错。更为麻烦的是，这种语言是完全按照计算机硬件设计的，不同各类的计算机都有自己特有的机器语言和汇编语言，一种类型的机器无法识别另一种类型机器的机器语言，所以，汇编源程序缺乏可移植性。</p><p>人们都机器语言和汇编语言归属为低级语言。</p>
<p>汇编语言的出现具有划时代的意义，它启发人们，可以设计出更好用的语言，只需要通过翻译器，将新语言的源程序翻译成机器语言程序。于是，人们期待的脱离计算机机种的高级程序设计语言便陆续被设计出来。</p><p>高级语言引入变量、数组以及结构化程序思想（分支、循环等控制结构）、函数（子程序）以及接近数学语言的表达式等语法成分，用接近英语口语的语句描述处理步骤（如if...then...else...），不仅容易理解和记忆，而且一条语句的处理能力相当于几条、几十条、甚至几百条 汇编指令，大大提高了编程效率。</p><p>数据类型系统可以实现错误的早发生机制。</p><p>数据类型系统的性能可保障性，因为其无须动态时检查。</p>
<p>以时间换时间，编译时要花费更多时间，以空间换时间，静态数据类型系统需要更多的空间。静态可以在运行前实施一定的的静态优化。</p><p>在操作系统中，每个线程都有一个自己的堆栈供过程和函数使用。</p><p>堆栈的最大用途是模拟数据结构中的递归遍历算法，堆栈对递归有天然支持的属性。</p><p>一个应用程序是如何开始？</p>
<p>1 操作系统创建一个新的进程和一个初始线程；</p>
<p>2 应用程序代码装载到内存；</p>
<p>3 动态链接库装载到内存(如果需要使用DLL)；</p>
<p>4 为数据和堆栈分配物理内存，并映射到虚拟内存；</p>
<p>5 应用程序开始执行；</p><p>一般而言，发布的动态链接库，需要包含三个文件：包含文件（.H）、导入库文件（.LIB）和实际代码文件（.DLL）。</p><p>包含文件（.H）为后缀名为.H的头文件。在该文件中，定义了DLL能够导出的函数、数据结构或类的声明。在DLL开发时，包含文件所声明的内容需要在.CPP文件中实现，.CPP文件形成的源程序代码被封装在DLL中。当要使用DLL时，必须将DLL的这个头文件添加到使用该DLL的源程序代码中。</p><p>导入库文件（.LIB）虽然与静态链接库文件扩展名一样，但它不同于静态链接库文件。导入库文件包含了调用使用DLL的一些隐式链接，即加载时动态链接的信息。当应用程序以隐含的方式链接DLL时，导入库文件中的信息，如函数名、函数地址等，被拷贝到应用程序的代码中去。</p><p>实际代码文件（.DLL）包含有DLL的真正可执行代码。应用程序调用DLL运行时，.DLL文件中实际代码被动态装入运行。</p><p>程序设计语言是用于书写计算机程序的语言，其基本成分有以下4种，数据成分：用来描述程序中的数据。运算成分：描述程序中所需的运算。控制成分：用来构造程序的逻辑控制结构。传输成分：定义数据传输成分，如输入输出语言。</p><p>八进制和十六进制只是二进制的一种过渡性的“易读”形式，与二进制无本质区别。</p><p>最原始的编程是硬件编程。</p><p>MarkI使用纸带做为输入，连接约束进行循环，修补纸带上的孔来debug。</p><p>系统从高地址空闲块中进行分配，直到分配无法进行时，才回收所有用户不再使用的空闲块，重新组织一个大的空闲块来再分配；</p><p>哈希(散列)查找:在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。</p><p>①  顺序表和链表的查找：将给定的K值与查找表中记录的关键字逐个进行比较， 找到要查找的记录；</p><p>②  散列表的查找：根据给定的K值直接访问查找表， 从而找到要查找的记录；</p><p>③  索引查找表的查找：首先根据索引确定待查找记录所在的块 ，然后再从块中找到要查找的记录。</p><p>传参时需要考虑的一个问题是，我是需要修改它还是不修改它，如果不想修改它，怎样操作呢？操作它的复本就不会修改到它原来的值了。如果想修改它呢？不做复本，直接通过地址指向它所在的内存空间就可以修改它了。</p><p>理解编译器不只是编译，还有类型推导、类型检查、语法错误检查等；</p><p>变量：按其类型使用一定大小的内存空间存储其类型解释的值。</p><p>其实 wchar_t 是这样来的：typedef short int wchar_t;</p><p>一个程序处理时会，会有三个过程：</p><p>compiling、linking、running；编译时（编译器）、链接时（链接器），如果有错误，会有调试器显示错误信息、运行时。</p><p>你会发现，一个变量或函数只有声明，没有定义时，编译时是没有问题，到了链接时，链接器必须链接到定义。</p><p>指令系统指令格式</p><p>OP A B C</p><p>A OP B → C</p><p>OP A B</p><p>A OP B → A</p><p>OP A</p><p>OP A → A</p><p>OP</p><p>ADD AX, 3048H</p><p>AX=AX内容+3048</p><p>ADD AX, [2000H]</p><p>AX=AX + 数据段偏移2000H</p><p>程序中的数据对象可以具有左值和（或）右值。左值指存储单元（或地址、容器），右值是值（或内容）。变量具有左值和右值。</p><p>常量只有右值，在程序运行过程中右值不能改变。</p><p>程序是计算机指令的集合，它以文件的形式存储在磁盘上，而进程通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。一个程序可以对应多个进程.</p><p>进程是资源申请，高度和独立运行的单位，因此，它使用系统中的运行资源，而程序不能申请系统资源，不能被系统高度也不能作为独立运行的单位，因此它不占系统运行资源.</p><p>结构化编程的自顶向下：逐层分解，先确定上层模板的功能，再确定下层模块的功能。上层模块只规定下层模块做什么和所属模块间的协调关系，但不规定怎么做，以保证各模块的相对独立性和内部结构的合理性，使得模块与模块之间层次分明，易于理解、实施和维护。</p><p>模块之间的耦合尽可能小，模块的内聚度尽可能高；</p><p>寻址方式：形成当前指令操作数或操作数地址及下条指令地址的方式；</p><p>存放数据的部件：寄存器、主存、I/O设备，堆栈、IR(指令中)；</p><p>所谓指针的移动，是指通过指针的计算或偏移，获得一个新的地址值，从而可以访问这个新的地址值所对应的内容。</p><p>内存中指令和数据没有任何区别，都是二进制信息，CPU在工作的时候把有的信息看作指令，有的信息看作数据。</p><p>CPU根据什么将内存中的信息看作指令？</p><p>   CPU将CS:IP指向的内存单元中的内容看作指令。</p><p>2、算术运算指令</p><p>   比如：</p><p>   add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，</p><p>   这些指令实现寄存器和内存中的数据的算数运算。</p><p>   它们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af位。</p><p>指令系统中采用不同寻址方式的目的主要是         。</p><p></p><p>缩短指令长度，扩大寻址空间，提高编程灵活性</p><p>CPU响应中断时，必须先保护当前程序的断点状态，然后才能执行中断服务程序，这里的断点状态是指返回地址和状态寄存器的内容。</p><p>半导体动态RAM靠电容暂存电荷原理存贮信息，而半导体静态RAM靠双稳电路（内部交叉反馈）原理存贮息。</p>