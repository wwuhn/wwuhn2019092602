<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
height:28px;
//white-space:nowrap;
//overflow:hidden; 
//text-overflow:ellipsis; 
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
padding-left:2px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
</style>
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<script language="javascript"> 
//bg_even("表格ID属性名","奇数行背景色","偶数行背景色","鼠标经过背景色","点击后背景色");
function bg_even(o,a,b,c,d){
        var t=document.getElementById(o).getElementsByTagName("tr");
        for(var i=0;i<t.length;i++){
                t[i].style.backgroundColor=(t[i].sectionRowIndex%2==0)?a:b;
                t[i].onclick=function(){
                        if(this.x!="1"){
                                this.x="1";
                                this.style.backgroundColor=d;
                        }else{
                                this.x="0";
                                this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                        }
                }
                t[i].onmouseover=function(){
                        if(this.x!="1")this.style.backgroundColor=c;
                }
                t[i].onmouseout=function(){
                        if(this.x!="1")this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                }
        }
}
</script>

</head>

<body> 
<div id="container">

<p>vector下标操作不添加元素,属于安全的泛型编程。相对于普通数组，vector定义的数据线性序列，可以动态使用push_back添加元素。这是普通数组所没有的功能。</p>


<p>关联容器中的元素不是顺序排列，而是按键（key）排序的。关联容器共享了许多顺序容器提供的操作，此外，还定义了自己特殊的操作。</p>

<p>C++ 定义的容器类型中，只有 vector 和 deque 容器提供下面两种重要的运算集合：迭代器算术运算，以及使用除了 == 和 != 之外的关系操作符来比较两个迭代器（== 和 != 这两种关系运算适用于所有容器）。</p>

<p>vector 和 deque 容器都支持对其元素实现高效的随机访问。也就是说，我们可以高效地先访问 5 号元素，然后访问 15 号元素，接着访问 7 号元素，等等。 由于 vector 容器的每次访问都是距离其起点的固定偏移，因此其随机访问非常有效率。在 list 容器中，上述跳跃访问会变得慢很多。在 list 容器的元素之间移动的唯一方法是顺序跟随指针。从 5 号元素移动到 15 号元素必须遍历它们之间所有的元素。</p>

<p>默认的 stack 和 queue 都基于 deque 容器实现，而 priority_queue 则在 vector 容器上实现。在创建适配器时，通过将一个顺序容器指定为适配器的第二个类型实参，可覆盖其关联的基础容器类型：</p>


<p>// empty stack implemented on top of vector</p>

<p>stack&lt; string, vector&lt;string> > str_stk;</p>

<p>// str_stk2 is implemented on top of vector and holds a copy of svec</p>

<p>stack&lt;string, vector<string> > str_stk2(svec);</p>

<p>支持先进先出或后进后出或优先的顺序操作；</p>

<p>最经常使用的容器类型是 vector，它支持对元素的快速随机访问。可高效地在 vector 容器尾部添加和删除元素，而在其他任何位置上的插入或删除运算则要付出比较昂贵的代价。deque 类与 vector 相似，但它还支持在 deque 首部的快速插入和删除运算。list 类只支持元素的顺序访问，但在 list 内部任何位置插入和删除元素都非常快速。</p>

<p><strong>容器定义的操作非常少，只定义了构造函数、添加或删除元素的操作、设置容器长度的操作以及返回指向特殊元素的迭代器的操作。其他一些有用的操作，如排序、查找，则不是由容器类型定义，而是由标准算法定义。</strong></p>

<p>priority_queue（优先级队列）</p>

<p>Adaptor for the sequential containers that yields a queue in which elements are inserted, not at the end but according to a specified priority level. By default, priority is determined by using the less-than operator for the element type.</p>

<p>一种顺序容器适配器。在这种队列中，新元素不是在队列尾部插入，而是根据指定的优先级级别插入。默认情况下，元素的优先级由元素类型的小于操作符决定。</p>

<p>stack（栈）Adaptor for the sequential containers that yields a type that lets us add and remove elements from one end only.一种顺序容器适配器，这种类型只能在一端插入和删除元素。</p>

<p>关联容器（Associative containers）支持通过键来高效地查找和读取元素。两个基本的关联容器类型是 map set。map 的元素以键－值（key-value）对的形式组织：键用作元素在 map 中的索引，而值则表示所存储和读取的数据。set 仅包含一个键，并有效地支持关于某个键是否存在的查询。</p>

<p>关联容器支持很多顺序容器也提供的相同操作，此外，还提供管理或使用键的特殊操作。</p>

<p>pair 包含两个数据值。与容器一样，pair 也是一种模板类型。但又与之前介绍的容器不同，在创建 pair 对象时，必须提供两个类型名：pair 对象所包含的两个数据成员各自对应的类型名字，这两个类型必相同。</p>

<p>关联容器共享大部分——但并非全部——的顺序容器操作。关联容器不提供 front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。</p>

<p>“容器元素根据键的次序排列”这一事实就是一个重要的结论：在迭代遍历关联容器时，我们可确保按键的顺序的访问元素，而与元素在容器中的存放位置完全无关。</p>

<p>map 容器是键－值对的集合，好比以人名为键的地址和电话号码。相反地，set 容器只是单纯的键的集合。例如，某公司可能定义了一个名为 bad_checks 的 set 容器，用于记录曾经给本公司发空头支票的客户。当只想知道一个值是否存在时，使用 set 容器是最适合的。例如，在接收一张支票前，该公司可能想查询 bad_checks 对象，看看该客户的名字是否存在。</p>

<p>map 和 multimap 类型存储的元素是键－值对。它们使用在 utility 头文件中定义的标准库 pair 类，来表示这些键－值对元素。对 map 或 multimap 迭代器进行解引用将获得 pair 类型的值。pair 对象的 first 成员是一个 const 键，而 second 成员则是该键所关联的值。set 和 multiset 类型则专门用于存储键。在 map 和 set 类型中，一个键只能关联一个元素。而 multimap 和 multiset 类型则允许多个元素拥有相同的键。</p>

<p>关联容器的元素可用迭代器访问。标准库保证迭代器按照键的次序访问元素。begin 操作将获得拥有最小键的元素，对此迭代器作自增运算则可以按非降序依次访问各个元素。</p>

<p>pair Type that holds two public data members named first and second. The pair type is a template type that takes two type parameters that are used as the types of these members.一种类型，有两个 public 数据成员，分别名为 first 和 second。pair 类型是带有两个类型形参的模板类型，它的类型形参用作数据成员的类型。</p>

<p>除了模板形参表外，类模板的定义看起来与任意其他类问相似。类模板可以定义数据成员、函数成员和类型成员，也可以使用访问标号控制对成员的访问，还可以定义构造函数和析构函数等等。在类和类成员的定义中，可以使用模板形参作为类型或值的占位符，在使用类时再提供那些类型或值。</p>

<p>Queue<int> qi;</p>

<p>编译器自动创建名为 Queue 的类。实际上，编译器通过重新编写 Queue 模板，用类型 int 代替模板形参的每次出现而创建 Queue 类。实例化的类就像已经编写的一样：</p>

<p>容器可以理解为特定的泛型数据结构与特定的泛型算法、特定的迭代器的组合</p>

<p>C++类模板实例化时为什么需要具体类型</p>

<p>类成员的泛类型；</p>

<p>typename这个关键字，它的作用同class一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：      template<typename T>.在模板定义语法中关键字class与typename的作用完全一样。</p>

<p>一个类模板(也称为类属类或类生成类)允许用户为类定义一种模式，使得类中的某些数据成员、默认成员函数的参数、某些成员函数的返回值，能够取任意类型(包括系统预定义的和用户自定义的)。</p>

<p>如果一个类中数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表着一类类。</p>

<p>类模板的使用实际上是将类模板实例化成一个具体的类，它的格式为：类名<实际的类型>.</p>

<p>函数模板可以用来创建一个通用的函数，以支持多种不同的形参，避免重载函数的函数体重复设计。它的最大特点是把函数使用的数据类型作为参数。</p>


<p>STL deque，double-ended queue，双端队列，可以实现队列两端快速插入和删除操作的功能；</p>

<p>map可以通过下标操作符直接存取元素。下标操作符并非元素整数位置，而是元素的键值key。</p>

<p>STL会提供适当的构造函数、普通成员函数、迭代器函数来进行构造、插入、删除、访问（查找）、修改数据元素的操作；</p>

<p>STL的算法函数设计，都使用模板来提供通用类型，都使用迭代器来提供访问容器中数据的通用表示。</p>

<p>仿函数：使用一个类(假设类名字是classname)，好像调用一个函数。类的实现里包含函数operator()，之后这个类就有了类似函数的行为（使用类就如同调用operator()函数），这个类就是一个仿函数类。当使用类似函数调用形式classname()时，函数operator()被自动执行。</p>


<p>最简单的迭代器是指针。给定一个指向数组中的第一个元素的指针，可递增该指针使其指向下一个元素，还可直接对当前位置的元素进行操作。</p>

<p>STL中的迭代器是模板类，从某种程序上说，它们是泛型指针。这些模板类让程序员能够对STL容器进行操作。注意，操作也可以是以模板函数的方式提供的STL算法，迭代器是一座桥梁，让这些模板函数能够以一致而无缝的方式处理容器，而容器是模板类。</p>

<p>输入迭代器：通过对输入迭代器解除引用，它将引用对象，而对象可能位于集合中。最严格的输入迭代器确保只能以只读的方式访问对象。</p>

<p>迭代器的分类：输入、输出、前向、双向、随机访问五种，是只读、只写、递增操作、递减操作、加减偏移量操作的5个功能的叠加组合。</p>

<p>查找、排序、反转等都是标准的编程需求，不应让程序员重复实现这样的功能。因此STL以STL算法的方式提供这些函数，通过结合使用这些函数和迭代器，程序员可对容器执行一些最常见的操作。</p>

<p>简单地说，标准模板库（STL）是一组模板类和函数，向程序员提供了：</p>

<p>用于存储信息的容器；</p>

<p>用于访问容器存储的信息的迭代器；</p>

<p>用于操作容器内容的算法；</p>

<p>STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。</p>

<p>STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm>、&lt;deque>、&lt;functional>、&lt;iterator>、&lt;vector>、&lt;list>、&lt;map>、&lt;memory>、&lt;numeric>、&lt;queue>、&lt;set>、&lt;stack> 和&lt;utility>。</p>

<p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；STL的sort()函数可以用来操作vector,list等容器。</p><p>经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在 细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p>


<p>在STL中，容器一般用模版类来实现。不过STL并没有采用面向对象的技术，所以在STL中并没有一个通用的容器类，各种具体的容器也没有统一的基类。</p>

<p>容器可以视为是数组的扩展，即对象的数组（广义数组），其中的元素（对象）通过容器对“[]”的重载，可以和数组一样利用下标（索引）来访问。 </p>

<p>注意：STL中的容器可以包含的类型有内置的基本数据类型和带有公用拷贝构造函数和赋值操作符的类。</p>

<p>顺序容器，指的是将一组具有相同类型T的对象，以严格的线性形式组织在一起。顺序由容器可以视为数组和链表的推广。包括有以下3种顺序容器。 </p>

<p>vector<T>； </p>

<p>deque<T>； </p>

<p>list<T>。 </p>

<p>（2）关联容器，提供一个key（键）实现对元素的随机访问，其特点是key是有序的，即元素是按预定义的键顺序（例如升序）插入的。关联容器具有从基于键的集合中快速提取对象的能力，其中集合的大小在运行时是可变的。关联容器可以视为关联数组、映射或字典的推广，它们保存的都是键值对，给定了其中的一个被称为键（key）的值，就可以快速访问与其对应的另一个值的值。STL中的关联容器有以下4种。 </p>

<p>set&lt;Key>（集合）： 支持唯一键值，并提供对键本身的快速检索；例如set&lt;long>：{学号}（set类的头文件&lt;set>）； </p>

<p>multiset&lt;Key>（多重集合）：支持可重复键值，并提供对键本身的快速检索；例如set&lt;string>：{姓名}（可能有同名的）（multiset类的头文件是&lt;set>）； </p>

<p>map&lt;Key,T>：支持唯一Key类型的键值，并提供对另一个基于键的类型T的快速检索；例如map&lt;long,string>：{(学号,姓名)}、{(电话号码,姓名)}等（map类的头文件是&lt;map>）； </p>

<p>multimap&lt;Key,T>（多重映射）：支持可重复Key类型的键值，并提供对另一个基于键的类型T的快速检索；例如map&lt;string,string>：{(姓名, 地址)}、{(姓名, 年龄)}等（multimap类的头文件是&lt;map>）。 </p>

<p>除了这两种以外，还有一种容器是容器适配器。不过容器适配器不是独立的容器，只是某种容器的变种，它提供原容器的一个专用的受限接口。特别是，容器适配器和普通容器的不一样是在于不提供迭代器。在STL中有3种容器适配器，具体如下。 </p>

<p>stack&lt;T>（栈）：只支持top()（读取栈顶元素）、push()（在栈顶处加入新元素）和pop()（取出栈顶元素）操作（先入后出）的一种序列容器。（stack类的头文件是<stack>）； </p>

<p>queue&lt;T>（队列）：与stack类似，queue也是对序列容器的限制实现。与栈相比，队列也支持back()（读取队尾处的元素）和push_back()（在队尾处插入新元素）操作，但是不再支持pop_back()（取出队尾处的元素）操作。不过，队列允许front()（读取队首处的元素）和pop_front()（取出队首处的元素）操作（前出后入）。（queue类的头文文件是&lt;queue>）； </p>

<p>priority_queue&lt;T>（优先队列）：也是一种队列queue，不过其中的每个元素都被给定了一个优先级，用来控制元素到达队首top()的顺序。默认情况下，优先队列简单地使用运算符<进行元素比较，top()返回最大的元素。 </p>

<p>注意：优先队列，并不要求其全部元素都是有序的，而只要求其第一个元素是最大的。</p>



<p>vector使用allocator来进行内存管理，使用3个迭代器来引用这段内存。vector的iterator其实就是T*的别名。在一个连续的内存里（数组），指针是可以做算术运算的，也支持[]操作，由此，vector的iterator也支持算术运算，++，--，+=，-=，[]。vector的迭代器就是通常的随机访问迭代器了。</p>

<p>Vector&lt;T>容器表示一个在必要时可自动增加容量的数组，该数组存储T类型的元素。只能在矢量容器的末尾添加新元素。</p>

<p>aray&lt;T,N>容器表示一个数组N，它存储指定数量的T类型元素。与普通数组相比，这个容器的一个优点是它知道其大小，所以把array&lt;>容器传递给函数时，它仍知道所存储元素的个数。array&lt;>容器优于vector&lt;>的一个优点是，它可以完全在栈上分配内存，而vector&lt;>总是需要访问堆。</p>

<p>deque&lt;T>容器实现一个双端队列，它存储T类型的元素。它等价于一个矢量，但增加了向容器开头添加元素的能力。</p>

<p>list&lt;T>容器是一个双向链表，它存储T类型的元素。</p>

<p>forward_list&lt;T>容器是一个单向链表，它存储T类型元素。只要以前向方式处理链表中的元素，在forward_list&lt;T>中插入和删除元素就比在list&lt;T>中快。</p>

<p>map&lt;K,T>是一个关联容器，用关联键（类型为K）存储T类型的每个元素。键/对象对在映射中存储为pair&lt;K,T>类型的对象，pair&lt;K,T>是另一个STL模板类型。键确定键/对象对的位置，用于检索对象。映射中的每个键必须唯一。这个头文件也定义了multimap&lt;K,T>容器，其中键/对象对中的键不需要唯一。</p>

<p>大多数STL容器都会自动增大其容量来容纳所存储的元素。这些容器的附加内存用一个名为分配器的对象来提供，分配器一般会在需要时分配堆上的内存。这可以通过一个额外的类型形参，提供自己的分配器对象类型。例如，创建向量的vector&lt;T>模板实际上是一个vector&lt;T,A&lt;T>>模板，其中的第二个类型参数A&lt;T>就是分配器类型。第二个类型形参的默认值是allocator&lt;T>，所以没有指定自己的分配器时，这就是所使用的分配器类型。</p>

<p>容器适配器是包装了现有STL容器类的模板类，提供了一个不同的、通常更有限制性的功能。</p>

<p>queue<T>容器由deque<T>容器中的适配器定义，但可以用list<T>容器来定义它。只能访问队列中的第一个和最后一个元素，而且只能从后面添加元素，从前面删除元素。因此queue<T>容器的运行过程或多或少就像我们在咖啡店排队一样。</p>

<p>stack<T>容器用deque<T>容器中的适配器定义，但可以用vector<T>或list<T>容器定义它。栈是一种后进先出容器，因此添加或删除元素总是发生在顶点，并且只能访问顶点的元素。</p>

<p>容器由怎样操作来定义，如怎样访问？怎样增加元素？怎样删除元素？怎样附加内存来增大容量由分配器来定义，存储何种类型由类型参数T来定义。</p>

<p>容器的遍历使用迭代器，迭代器都定义了==、!=、=等操作符，而不同的迭代器定义了其它不同的操作符，如++、--、*、--、+、-、<、[]等操作符。</p>

<p>1 元素数量弹性；（分配器实现内存增加）</p>


<p>2 元素类型参数化；（模板技术实现泛型）</p>
<p>3 算法独立于容器；（迭代器技术实现元素遍历）</p>

<p>三方面的泛化：</p>
<p>1 类型的泛化：模板技术让容器不局限于具体类型；</p>
<p>2 迭代器的泛化：迭代器是指针的泛化，如vector可以用指针实现迭代器，list可以通过类实现迭代器。迭代器的使用除了声明有所区别以外，其它方面基本一致，如：</p>
<p>vector<double>::iterator pr;</p>

<p>//list<double>::iterator pr;</p>

<p>for(pr=ins.begin(); pr != ins.end(); pr++)</p>

<p>{cout&lt;&lt;*pr&lt;&lt;endl}</p>

<p>3 算法的泛化：因为迭代器的泛化，可以让算法独立于具体的容器。也就是说，算法能够独立于具体的容器、独立于具体的类型。</p>



<p>The STL provides an alternative to arrays called the vector template class, and C++11 adds an array template class. These alternatives are more sophisticated and flexible than the built-in array composite type.</p>


<p>STL is a collection of useful templates for handling various kinds of container objects.</p>

<p>The StL exemplifies the programming paradigm called generic programming.</p>

<p>但如果站在代码重用的角度考虑，函数重载还是没有解决代码冗余的问题。因为重载的函数可以除了类型不同以外，剩下的函数名和函数体基本一样。这就是C++语言类型泛化的语法机制，用函数模板通过参数泛化在函数调用时由编译器去生成不同参数的函数。</p>

<p>STL算法是在一对迭代器指定的一个对象序列上操作的函数模板。</p>

<p>容器是一个存储和组织其他对象的类对象。序列容器用一个序列（如数组）存储对象。关联容器存储键/对象对的元素，其中键确定对存储在容器中的何处。</p>

<p>函数对象是重载()操作符（通过在类中实现函数operator()())的类型的对象。</p>


<p>编译器首先会为这一组重载函数中的每个函数取一个不同的内部名字。当发生函数调用时，编译器根据实际参数和形式参数的匹配情况确定具体调用的是那个函数，将这个函数的内部函数名取代重载的函数名。</p>

<p>如果一组重载函数仅仅是参数的类型不一样，程序的逻辑完全一样，那么这一组重载函数可以写成一个函数模版。 </p>

<p>所谓的函数模版就是实现类型的参数化（泛型化），即把函数中某些形式参数的类型定义成参数，称为模版参数 </p>

<p>在函数调用时，编译器根据实际参数的类型确定模版参数的值，生成不同的模版函数。</p>

<p>一 般的定义形式</p>

<p></p>
<pre>
template&lt;类型形式参数表>
返回类型 FunctionName(形式参数表)
{
	//函数定义体
｝
类型形式参数表可以包含基本数据类型，也可以包含类类型（需加前缀class）
template&lt;class T>
T max(T a, T b)
{ return a>b ? a : b；}        
</pre>

<p>STL是用模板技术实现的数据结构和算法库。</p>

<p>vector容器相对于数组，在于其可以自动分配存储区和释放存储区，也就是相当于一个动态数组。</p>

<p>string、vector都是类，有重载构造函数，所以有多种初始化方式；</p>

<p>容器类函数一般可以分为以下几类：</p>

<p>1 构造类，构造函数有重载，所有有多种对象初始化方式；</p>

<p>2 迭代器函数：返回不同的迭代器，也就是指针指向不同的元素；</p>

<p>3 容量类函数，与size相关；</p>

<p>4 存取类，访问、查询相关；</p>

<p>5 操作类，增、删、改相关；</p>


<p>STL提供了大量的函数模板和类模板；</p>

<p>STL有助于提高算法和数据结构的重用性，将将开发者从这些通用而常见的问题中解放出来。STL提供的算法或数据结构在效率和性能上都是比较优秀的。</p>

<p>STL容器：数据存储方案及其对应操作；</p>

<p>STL容器的.begin()方法可以返回一个对应类型的迭代器，可以用此类型的迭代器被赋值。</p>

<p></p>
<pre>
vector<int> vec;
vector<int>::iterator itr = vec.begin();
for (vector<int>::itertor itr = vec.begin(); itr != vec.end(); ++itr)
{
    cout&lt;*itr&lt;endl;
}
</pre>

<p>C++标准模板库里提供有3种顺序容器，vector以数组为基础，与数组不同的是，当内存不够时，vector会重新申请内存，把原来的数据复制到新的内存里面，并释放旧的内存区。list以双向链表为基础。</p>

<p>关联容器支持高效的关键字查找和访问。Map中的元素是关键字起到索引作用，值则表示和索引相关联的数据。而set中每个元素只包含一个关键字查询操作。</p>



</div>
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>


<!--
_____________________________________________________________________________________

1 段落替换：
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])
------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
4 把第和章两个字去掉
第(\S*)章
------------------
$1

5 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/

6
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
-->



