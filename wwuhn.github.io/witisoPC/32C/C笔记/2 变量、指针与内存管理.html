<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">
<p>堆空间：动态分配的空间；</p>

<p>栈空间：非静态局部变量空间，函数参数，函数内部定义的变量，以及返回的地址值；</p>

<p>全局和静态数据区：全局变量、静态局部变量，常量；</p>

<p>数据段，用于存储字符串字面量。</p>

<p>代码区：存放代码的区域；</p>

<p>对于栈空间，VC6一般就分配1M左右；</p>



<p>变量名只是隐式地声明了变量值存储的地址，而它的指针则是显式地声明了变量值存储的地址。</p>

<p>C将数组名视为指针，即将数组名解释为其第一个元素的地址，如apples = &apples[0];</p>



<p>符号常量：#define PI 3.14159</p>

<p>const常变量：const int a=3;(必须写成一行，不能分开写)</p>

<p>typedef short int wchar_t;</p>


<p>计算机的内存（RAM）由数百万个顺序存储位置组成，每个位置都有唯一的地址。计算机的内存地址范围从0开始至最大值（取决于内存容量，可访问的最大值取决于计算机的数据总线的数量，如果是32位，则是到2^32，4G）。</p>

<p>运行计算机时，操作系统要使用一些内存。运行程序时，程序的代码（执行程序中不同任务的机器语言指令）和数据（该程序使用的信息）也要使用一些内存。</p>

<p>在C程序中声明一个变量时，编译器会预留一个内存位置来储存变量。此位置有唯一的地址。编译器把该地址与变量名相关联。当程序使用该变量名时，将自动访问正确的内存位置。</p>


<p>要理解变量作用域，首先要理解结构化编程的思路。结构化编程把程序分成若干独立的函数，每个函数都执行特殊的任务。这里的关键是函数独立。为了真正让函数独立，每个函数的变量都不能受其他函数代码的影响。只有隔离每个函数数据，才能确保函数在完成自身任务时不会被其他函数破坏。<strong>在函数中定义变量，便可“隐藏”这些变量，让程序的其他部分无法访问它们</strong>。</p>

<p>然而，并非所有情况都要在函数间完全隔离所有的数据。程序员通过指定变量的作用域能很好地控制数据隔离的程序。</p>

<p>任何变量都有一个指定的存储类别，用于决定变量的作用域（在程序中何处可见）和生命期（变量在内存中的存活时间）。</p>

<p>对于结构化编程，正确使用存储类别非常重要。在函数中使用局部变量，提高了函数间的独立性。尽量使用自动存储类别的变量，除非有特殊原因需要使用外部或静态变量。</p>

<p>既然外部变量在程序中的任何地方都可用，为何不将所有的变量都声明为外部变量？</p>

<p>随着程序越来越大，包含的变量也越来越多。外部变量在程序运行期间会一直占用内存，而自动变量只在执行它所在的函数时占用内存。因此，<strong>使用局部变量节约内存空间。然而，更重要地是，使用局部变量能减少程序不同部分不必要的交互，从而减少了程序的bug，同时也遵循了结构化编程的原则。</strong></p>


<p>常量是不可以改变的数据，常量按照数据类型主要分为整型常量、浮点型常量、字符型常量、字符串常量、转义字符常量、地址常量等6种。</p>
<p>在C中，字面量（右式）除了字符串字面量以外，都只作代码处理，并不单独分配内存，而字符串字面量要分配内存，并保存到内存的数据段、栈区或堆区。</p>
<p></p>
<pre>
char *s1, *s2, *s3 = “abcde”;
char ch[] = “fff”;
s1 = ch;
s2 = new char[10];
strcpy(s2, “fgh”);
</pre>
<img src="memory.jpg" />
<p>这样保存的好处是当有多个地方使用同一字符串常量时，可以直接引用。</p>
<p>变量，顾名思义就是在程序运行中，可以被改变的量。变量在定义后为程序提供了一个有名字的内存区域，编程者可以通过程序对它进行读写和处理。变量值的改变是通过赋值操作进行的。变量的基本使用示例代码如下： </p>



<pre>
double pi = 3.14; //定义double型变量pi 
pi = 3.1415; 
pi = 3.1415926; //可以通过赋值不断改变pi的值 scanf( "%lf", &pi ); 
</pre>



<p>常量和变量都是在程序中需要经常使用到的，特别是变量，它们有着不同的特征，常量和变量的主要区别如下。 </p>

<p>（1）常量的值不可以修改，任何尝试修改常量的操作都会导致编译错误。而变量可以通过赋值来改变值。 </p>

<p>（2）常量定义以后就不可以修改，所以常量在定义时必须初始化。变量可以在定义时暂不进行初始化。常量初始化的时候必须直接复制常量初始化的示例代码如下： </p>



<pre>
const char a = "test" //正确 
char p; 
p="test"; 
const test = p; //错误，常量必须直接赋值 
</pre>



<p>（3）常量值的地址不允许赋给非常量指针。 </p>

<p>（4）<strong>常量在编译的时候，可以以立即数形式编译进指令</strong>，比起使用内存的变量执行效率更高。 </p>

<p>（5）常量本身没有地址属性（除字符串常量等），而变量有地址属性。所以常量只能用做右值，而变量左值、右值都可以。 </p>

<p> </p>

<p>常量是不可以改变值的量，变量是可以改变值的量，常量在定义时必须初始化，变量可以在定义时不初始化。常量不可以寻址，它的地址不允许赋给非常量指针，变量可以寻址。常量有相对较高的编译执行效率。</p>



<p>操作符优先级决定了表达式运算的次序，操作符优先级越高，则运算次序越靠前。 </p>

<p>在所有的优先级中，有3个是从右至左结合的，分别是单目运算符、条件运算符、赋值运算符。其他的操作符都是从左至右结合。</p>

<p>逻辑与和逻辑或操作符在使用时，总是先计算它的左操作数，然后再计算右操作数。只有在靠左操作数的值无法确定该逻辑表达式的结果时，才会去求解右操作数。这种求值方式也被称为<strong>“短路求值（short-circuit evaluation）”</strong>。</p>

<p>前自增操作使其操作数加1，操作结果是修改后的值。同样，前自减操作使其操作数的值减1。这两种操作符的后置形式同样对其操作数执行加1（或减1）的操作，但后置形式在操作后表达式的结果是操作数原来的、未修改的值。也就是说，前自增自减操作返回左值，也就是对象本身，而后自增自减操作返回的是右值。</p>
<p></p>
<pre>
	int m,n,i=3,j=8;
	m=++i;//i=i+1;m=i;
	n=j++;//n=j;j=j+1;
</pre>
<p>i,j都有自增1，而对于m,n的值，可按就近原则去理解，m=++i，先要加再赋值，n=j++，先赋值再加。</p>
<p>按表达式的结合性，赋值运算符是右结合，从右边开始计算，但后置却明显违背了这一规则，编译器的特殊处理是，使用一临时变量达到右结合：int temp=j;j=j+1;n=temp;</p>
<p>变量的自增自减是修改变量的值，指针的自增自减是修改指针的指向地址。</p>
<p>变量有两个值：一个是内存块的首地址，一个是内存块的一串二进制码按数据类型的编码解码规则解码出来的数据值。</p>
<p>如果数据值也是一个地址值，那这个变量就是指针变量。</p>
<p>引用是一个特殊的常量指针，在C++中使用。</p>
<p>C中变量为程序提供了可以操作的有名字的存储区。变量的主要意义有以下两点。 </p>

<p>变量代表分配了一块存储区； </p>

<p>变量代表这个存储区的名称。</p>

<p></p>

<p>左值可以出现在赋值语句的左边或右边，也就是说左值可以当右值使用。右值只能出现在赋值的右边，不能出现在赋值语句的左边。左值表示程序中必须有一个特定的名字引用到这个值。右值表示程序中没有一个特定的名字引用到这个值。 </p>

<p>变量是左值，因此可以出现在赋值语句的左边。数字字面值是右值，因此不能被赋值。实际上，左值是一个存储地址，也就是一块内存存储数据所要操作的地址。而右值是一个具体的数据或者数值，也就是该内存存储的数据内容。只有左值和右值都是单一变量的时候二者才可以相互交换位置，因为变量具有固定的内存地址。 </p>

<p>左值和右值的示例代码如下： </p>

<pre>
int a = 1;                     // 变量a是一个左值 
char str[] = "hello, world";   // 数组成员str[i]是左值 
"hello, world";                // 这个表达式是一个数据内容，它是一个右值 
string("hello, world");        // 这也是一个右值 
</pre>

<p>注意：有些操作符，例如赋值，要求其中的一个操作数必须是左值。结果，可以使用左值的上下文比右值更广。左值出现的上下文决定了左值是如何使用的。 </p>

<p>变量是左值，可以出现在赋值语句的左边。数字字面值是右值，不能被赋值。</p>

<p>如果变量在定义的时候没有被初始化，它的值将是不确定的，这也是程序员在使用变量时需要考虑到的一点，不确定的值有可能导致程序出现错误。一般来说，编程者为了保证程序的稳定性，尽量做到将所有的变量都进行初始化。</p>

<p>声明用于向程序表明变量的类型和名称。定义也是一种声明，当定义变量时编程者声明了它的类型和名称。也可以通过使用extern关键字声明变量名但是不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern，示例代码如下。 </p>

<p>extern int a; //声明但是未定义a </p>

<p>int b; //定义b</p>

<p>注意：extern声明不是定义，也不会分配存储空间。它只是说明变量定义在程序的其他地方（只是一个名字的引入）。含有初始化的extern声明被当做是定义，程序中变量可以声明多次，但只能定义一次。 </p>

<p>变量的定义用于为变量分配存储空间，还可以给变量初始化。在一个程序中，变量有且只有一个定义，定义变量的示例代码如下。 </p>

<p></p>
<pre>
int a; 
int b; 
int c; //定义3个整型变量a,b,c 
int d,e,f; //同时定义3个整型变量 
int g = 10; //定义变量g并且初始化 
</pre>



<p>对于C/C++语言，因为多是开发操作系统的底层技术，所以内存分配非常关键。下面从多方面解释内存分配方式： </p>

<p>（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如，全局变量和static变量。 </p>

<p>（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 </p>

<p>（3）从堆上分配，亦称动态内存分配。程序在运行的时候使用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p>

<p><strong>链接性linkage，链接器linker就是用来链接库和多文件的，所以链接性是指是否允许其可以被其它文件访问。</strong></p>

<p>在C语言中，每个变量有两个属性：</p>

<p>1 类型：变量所存储的数据类型</p>

<p>2 存储类型：变量所存储的区域：</p>

<p>标准的变量定义：</p>

<p>存储类型   数据类型   变量名；</p>

<p>存储类型：</p>

<p>1 自动变量：auto</p>

<p>2 寄存器变量：register</p>

<p>3 外部变量：extern</p>

<p>4 静态变量：static</p>



<p>字符串常量存储在内存中，赋值给一个字符指针的字符串变量存储在一个称为数据段的内存区域里（其他字面量只是代码的一部分），new给一个指针的字符串常量存储在堆中，赋值给一个字符数组的字符串常量存储在栈中。</p>

<p>字符串作为字符数组传递时不需要指定长度。因为字符串操作的结束是依据‘\0’</p>

<p>指针指向的内容还是一个指针，称为多级指针 </p>

<p>如有定义：char *string[10]; </p>

<p>     string是一个数组，数组元素可以通过指针来访问。如果p是指向数组string的某一个元素，那么p指向的内容是一个指向字符的指针，因此p就是一个多级指针。Name也是一个多级指针，不过是一个常指针</p>

<p></p>
<pre>
等价于a[i][j]的表达式
*(a[i] + j)
(*(a + i))[j]
*((*(a + i)) + j)
*(&a[0][0] + 5 * i + j)
</pre>

<p>全局变量和局部变量的主要区别是什么？使用全局变量有什么好处？有什么坏处？ </p>

<p>局部变量是函数内部或语句块中定义的变量，当函数调用时局部变量被生成，函数执行结束时局部变量被消亡。全局变量是在所有函数外定义的变量它可以一直生存到整个程序执行结束。所有定义在该变量后面的函数都能使用该全局变量。使用全局变量可以加强函数之间的联系。函数之间的信息交互不用通过参数传递。但全局变量也破坏的函数的独立性。用同样参数对同一个函数的多次调用可能因为执行时全局变量值不一样而导致函数执行的结果不同。 </p>

<p>变量定义和变量声明有什么区别？ </p>

<p>变量定义和变量声明的最主要的区别在于有没有分配空间。变量定义要为所定义的变量分配空间，而变量声明仅指出本源文件中的程序用到了某个变量（仅指使用关键字extern），该变量的类型是什么。至于该变量的定义可能出现在其他源文件中，也可能出现在本源文件中尚未编译到的部分。 </p>

<p>为什么不同的函数中可以有同名的局部变量？为什么这些同名的变量不会产生二义性？ </p>

<p>局部变量的生命周期是在对应的函数的执行期间。函数调用时，系统会分配一块内存空间（称为一个帧），所有的局部变量都存储在这块空间中。当函数执行结束时，系统回收这块空间，这些变量就消失了。每个函数有自己的存储局部变量的空间，每个函数只能访问自己的帧及全局变量。所以不同的函数可以有同样的局部变量名，而不会有二义性。 </p>

<p>静态的局部变量和普通的局部变量有什么不同？ </p>

<p>普通的局部变量随函数的执行而生成，函数执行的结束而消亡。静态的局部变量在该函数第一次执行时生成，到整个程序执行结束时消亡。当再次执行该函数时，其他的局部变量又重新被生成了，而静态局部变量不重新生成。当函数用到静态的局部变量时，还是到第一次为该静态局部变量分配的空间中进行操作。这样，函数上一次执行时的某些信息可以被用在下一次函数执行中。 </p>

<p>如何让一个全局变量或全局函数成为某一源文件独享的全局变量或函数？ </p>

<p>将该全局变量或全局函数设为静态的。 </p>

<p>如何引用同一个project中的另一个源文件中的全局变量？ </p>

<p>用外部变量声明。如果源文件A中定义了一个全局变量x，源文件B也要用这个x，那么在源文件B中可以写一个外部变量声明：extern x; </p>

<p>什么是模块的内部状态？内部状态是怎样保存的？ </p>

<p>模块的内部状态就是模块内多个函数需要共享的信息，这些信息与其他模块中的函数无关。内部状态通常被表示为源文件中的全局变量，以方便模块中的函数共享。 </p>

<p>定义变量时没有赋初值，然后直接引用（用作右值）该变量是危险的！！！</p>

<p>一个标识符能被存取的程序部分，称为标识符的作用域。</p>

<p>标识符的作用域与程序块有关。所谓的程序块是带有声明的复合语句。</p>

<p>声明一个不在本模块作用范围内的全局变量。如：</p>

<p>       extern  int  num;</p>

<p>       num为某一个全局变量。</p>

<p>用途：</p>

<p>在某函数中引用了一个声明在本函数后的全局变量时，需要在函数内用extern声明此全局变量。</p>

<p>当一个程序有多个源文件组成时，用extern可引用另一文件中的全局变量。</p>
<p>多级指针的应用：可以用指向指针的指针访问指针数组的元素。如int** p; 解引用*p的内容还是一个地址,**p才是具体值;</p>


<p>标识符的存储类别决定了标识符在内存中存在的时间。作用域是指标识符在程序中可以被引用的范围。</p>



<p>malloc()函数的功能是在内存的动态存储区中分配size个字节的连续空间，它的返回值指向所分配的那一段空间的起始地址，若分配失败，则返回一个空指针（0）。</p>

<p>void *malloc(unsigned int size);</p>

<p>void *calloc(unsigned int n, unsigned int size);</p>

<p>*calloc()的功能是在内存的动态存储区中分配n个长度为size个字节的连续空间，它的返回值是指向所分配空间的起始地址，若分配失败，则返回一个空指针（0）。</p>

<p>当今的操作系统都会给应用程序的每一个进程分配独立的“虚拟地址空间”。</p>
<p>程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到合适的物理内存地址上。这样一来，只要操作系统处理好虚拟地址到物理地址的映射关系，就可以保证不同的程序最终访问不同的区域，从而达到内存地址空间的隔离。</p>

<p>物理地址存在于物理内存中，同理，虚拟地址存在于虚拟地址空间中。要进行数据访问，必须由操作系统将虚拟地址转化为物理地址。我们在C语言和C++中看到的地址都是虚拟地址。用户是看不到物理地址的，物理地址由操作系统统一管理。</p>
<p>C语言中malloc()大体的实现是，从操作系统一次性地取得比较大的内存，然后将这些内存“零售”给应用程序。</p>



<p>计算机系统中存在着几种不同层次的内存管理层面，其中每层都可能覆盖原先的（较低的）层面。</p>

<p>首先是操作系统内核提供了最为基础的内存分配服务。然后是编译器的默认运行库也会建立起它自己的内存分配服务，如C++中的operator new和C中的mallowc，这一层是建立在操作系统的本地分配服务基础上的。</p>

<p>根据基本数据类型声明的变量可以告诉编译器以下信息：
<p>1 需要的内存空间；
<p>2 取值的范围；
<p>3 可以执行的操作（如可以使用什么运算符，使用运算符的规则及达到的效果）；


<p>内存中存储数据，可以有多种模型来帮助理解数据的组织。</p>


<p>为何使用指针？
<p>1 管理堆中的数据；
<p>2 访问类的成员数据和成员函数；
<p>3 按引用将变量传递给函数；



<p>老式编译器当分配堆内内存失败时，会返回NULL指针，而较新的编译器都会引发异常。</p>

<p>使用完分配的内存区域后，必须对指针调用delete，将内存归还给堆。别忘了，指针本身为局部变量，这不同于它指向的内存；当声明指针的函数返回时，指针将不再在作用域中，因此被丢弃。然而，使用new运算符分配的内存不会自动释放，这些内存将不可用，这被称为内存泄露，因为在程序结束前，内存不会归还给堆，就像内存从计算机中漏掉了。</p>



<p>int *pBuffer = NULL</p>

<p>NULL是一个预处理器宏，将被转换为0(int值)或0L(long值)。</p>



<p>常量类型：</p>

<p>1 const声明的常量；</p>

<p>2 constxpr声明的常量表达式；</p>

<p>3 enum声明的枚举常量；</p>

<p>4 #define定义的常量（已摒弃，不推荐）</p>

<p>5 字面常量</p>



<p>malloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。</p>

<p>void* 类型表示未确定类型的指针。C、C++规定，void* 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<p><strong>类型未确定，即无法确定对应内存空间的长度和解码方案，强制类型转换，即重新确定长度和解码方案。</strong>。</p>
<p>一般需和free函数配对使用。</p>

<p>malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。</p>

<p>指针类型的值用来表示某个量在内存储器中的地址；</p>

<p>整数：正数以原码保存，负数与补码存储；</p>

<p>实型：在内存中占4个字节，是按照指数形式存储的，分为小数部分与指数部分。</p>

<p>小数部分：用二进制表示；</p>

<p>指数部分：用2的幂次来表示；</p>

<p>字符型数据：按其对应的ASCII码来存储，而所有的ASCII代码值在内存中也是以二进制形式存放的，与整形在内存中存储的方式很相似，所以两类之间的转换也比较方便；</p>

<p>左结合：逻辑非!、按位取反~、负号-、自加1++、自减1--、取地址&、指针所指内容*、函数说明type、长度计算sizeof、条件运算符?:、联合操作=+=-=等；</p>

<p>符号&，当其操作数是一目还是二目时，其操作是不同的（返回操作数的地址）；当其操作数时二目时，操作数类型不同时，进行的也是不同的操作（如按位与、逻辑与）；</p>

<p>&和|对操作数进行求值运算，&&和||只是判断逻辑关系；&&和||在判断左操作数就能确定结果的情况下就不再对右操作数求值；</p>

<p>在编程中，左值位于赋值运算符的左侧，右值位于赋值运算符的右侧。</p>

<p>变量和常量都是按其相关的类型存储在内存空间内的，不过变量是可以寻址的而常量不可以寻址。对于每一个变量都有两个相关值：地址值和数据值：</p>

<p>1 数据值：存储在其内存地址中的数据，也称为变量的右值；</p>

<p>2 地址值：存储数据值的那块内存的地址，也称为变量的左值；</p>

<p>如以下代码：</p>

<p>int a = 3;</p>

<p>a = a + 5;</p>

<p>在a=a+5中，变量a同时出现在赋值操作符的左边和右边。右边的实例被读取，与其相关联的内存中的数据值被读出，左边的a用作写入。表达式a+5的值将要存储在a的位置值所指向的内存区中，原来的数据值会被覆盖。即在赋值操作符右边的a+5为右值（数据值，供读入）。达边的a为右值（地址值，供写入）。</p>



<p>malloc()函数接受一个参数：所需的内存字节数。malloc()函数会找到合适的空闲内存块，这样的内存块是匿名的。也就是说，malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用这个指针变量访问这块内存。</p>

<p>malloc()函数返回的是一个void通用指针，可以通过强制类型转换来转换为特定的指针类型。</p>

<p>calloc()函数接受两个参数，第一个参数是所需的存储单元数量，第二个参数是存储单元的大小（以字节为单位）。另外，callo()函数会把块中的所有位都设置为0.</p>


<p>c语言中的数据和代码是需要存放才可以使用的，C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。</p>

<p>数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。</p>

<p>CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，<strong>当源文件被编译和链接成可执行程序后，它们都会被替换成地址</strong>。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。</p>

<p>然而指针也是一种变量，他里面装的就是所指数据或者代码的地址。所以它可以指变量，也可以指函数。</p>

<p>两个指针指向同一个位置：</p>

<p>p2 = p1;</p>

<p>或</p>

<p>p2 = &*p1;</p>


<p>下面到底哪个是数组指针，哪个是指针数组呢：</p>

<p>int *p1[10];</p>

<p>int (*p2)[10];</p>

<p>“[]”的优先级比“*”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。</p>

<p>Node *head 是定义一个指向Node结构体变量的指针。</p>

<p>Node *&head实际上应该写成 (Node *)&head，其中&head是取变量head的地址，然后将此地址再转换为Node结构体类型的地址。在此表达式中，head的数据类型不一定是Node结构体数据的数据，它可以是任何类型的，与Node *无关。它仅仅用于取它的首地址。</p>

<p>可以操作头节点，所以head是引用。</p>

<p>指针虽然可以突破区块的限制，但如果指针指向的是一个复合数据类型，如果想更改复合数据类型内的元素的值时，需要进一步去引用。也就是p* &head的写法。</p>

<p>常量指针也是对数据的一种保护，但实质保护的不是指针本身，还是指针指向的数据不能通过指针去修改。</p>



<p>指针有性能优势，当做为函数参数时，在函数调用时，并不需要另行开辟内存空间，也就不需要另行对参数进行初始化或赋值，这是会浪费时间的，与此同时，也节省和空间。使用指针也是对局部空间的一种突破。另外，可以突破静态数组事先需要确定大小的限制，使用指针申请堆内存可以在运行时根据需要申请堆内存变量数量。</p>


<p>所有变量的作用域都开始于变量的声明处，换句话说，变量必须先声明再使用。</p>

<p>变量的操作：</p>

<p>1 declaration</p>

<p>2 assignment</p>

<p>2.1 initialization</p>

<p>2.2 modification</p>



<p>声明指针为什么需要声明类型，原因之一就是当指针运算产生偏转或读取数据时，它知道按不同的类型需要读取多少内存或偏转多少位置？</p>


<p>类型包含内存空间、解码的方式以及可以使用的操作。</p>
<p>变量：类型、名称、地址、值</p>

<p>指针变量：类型、名称、地址、值（地址）</p>

<p>地址就是变量在计算机内部的名称。</p>

<p>在C中，可以用&运算符访问变量的地址；</p>

<p>可以用*来获得储存在地址上的值；</p>

<p>普通变量把值作为基本量，把地址作为通过&运算符获得的派生量；</p>

<p>指针变量把地址作为基本量，把值作为通过*运算符获得的派生量；</p>

<p>typedef比#define更灵活。typedef由编译器解释，只能用于类型，不能用于值。能提高程序的移植性。</p>
<p>typedef用于将复合类型声明进行简写。</p>

<p></p>
<pre>
char * string; 
typedef char * STRING; STRING是一个类型，该类型是指向char的指针；
STRING name, sign;
相当于
char * name, * sign;
typedef {double x; double y;} rect;
rect r1 = {3.0, 6.0};
rect r2;
以上代码可以翻译成：
typedef {double x; double y;} r1 = {3.0,6.0};
typedef {double x; double y;} r2;
r2 = r1;
</pre>

<p>使用typedef时记住，typedef并没有创建新的类型，它只是为某个已存在的类型增加了一个方便使用的标签。可以把它理解为一个可移植数据的工具。因为C是强类型语言。</p>




<p>关键字extern声明，表明该变量或函数已定义在别处。</p>


<p>extern:用于声明全局变量，声明的变量再此声明后或其它文件中有声明并定义。</p>



<p>没有初始化的值可能是垃圾值或0值或void值；</p>



<p>与变量相关的概念</p>

<p>1 名字，编译后就是地址，运行时操作系统再关连的是虚拟地址；</p>

<p>2 地址</p>

<p>3 值、左值、右值</p>

<p>普通变量把值作为基本量，把地址作为通过&运算符获得的派生量；</p>

<p>指针变量把地址作为基本量，把值作为通过*运算符获得的派生量；</p>

<p>4 类型，基本类型、复合类型</p>

<p>5 值的初始化</p>

<p>6 存续期</p>

<p>7 作用域</p>

<p>8 文件链接</p>

<p>char *p = “test”;</p>

<p>p[2] = 'p';//不允许</p>

<p>因为“test”做为字面量存储在BBS内存区，返回一个常量指针给p，常量不能被修改，所以不能再被赋值的，编译器会自动把它定义为常量指针</p>



<p>左值有可修改的左值，不可修改左值；</p>

<p>标识符的作用域scope和链接表明了程序的哪些部分可以使用它。取决于标识符所在的位置以及关键字static.</p>

<p>存储期表明了数据在内存中保留了多少时间。</p>

<p>存储期：程序执行期、函数执行期；</p>

<p>C变量的作用域有块作用域、函数作用域、函数原型作用域、文件作用域。</p>

<p>block scope、function scope、function prototype scope、file scope、<p>如果你想要将将参数传递给一个函数而不复制它们，又或者希望函数对参数的修改能够对调用者可见。</p>

<p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C对象有4种存储期：静态存储期、线程存储期、自动存留期、动态分配存储期。</p>

<p>对于文件作用域变量，关键字static表明了其链接属性，而非存储期。</p>

<p>malloc()返回一个指向指定字节数内存块的指针。这块内存被free()函数释放后便可重复使用，free()函数以该内存块的地址作为参数。</p>



<p>多处声明，一处定义；</p>

<p>extern int i; //声明外部整型变量</p>

<p>char * f();  //声明函数</p>

<p>int j; //声明和定义变量</p>

<p>int k = 11 //声明和定义变量</p>

<p>定义整型常量，前面是0时，表示是8进制，前面是0x时，表示16进制，包括0-9,a,b,c,d,e,f共15个符号。后面可以跟u，l或ul，u表示无符号整数，l表示长整形。</p>

<p>指针可以指向基本类型对象，也可以指向自定义类型的对象；</p>



<p>指针作用：在函数内部访问在函数外部定义的大块数据，如数组。</p>

<p>更重要的是能够动态地为变量分配存储空间。</p>

<p>这种功能使程序可以根据实际的输入，调整自己的内存使用量。因为预先不知道将动态创建多少个变量，所以首选方法是使用指针。</p>



<p>变量是一段连续内存单元的首地址的命名，这个首地址也可以赋值给一个指针。</p>

<p>指针的声明和定义与变量有相似性，因为指针变量也是一个变量：</p>

<p>int * i;</p>

<p>i是指针，与变量一样，声明和定义是同时进行的，此时也分配了一个内存空间（所有指针都是一个字长大小的空间）。在初始化之前，此时i中存储的值是一个随机的垃圾值，如果未做初始化即对指针做解引用操作，将引发不可预见的错误。就如果普通变量未做初始化即用之做操作会引发错误一样。</p>

<p>指针主要有三个方面的作用：</p>

<p>1 间接访问；</p>

<p>2 允许在函数间共享内存空间；可以让参数作为返回值（参数一般是作为函数输入的）；</p>

<p>3 动态变量, such as dynamic array；the operator: new delete malloc free;</p>

<p>指针的类型同样确定了指针指向的一段连续的内存单元的长度；</p>

<p>当指针执行与整数i的加减运算时，就会引起指针的偏移，偏移的长度是i*数据类型的长度；</p>


<p>变量：直接返回内存单元对应的值，不用考虑其地址；</p>

<p>指针变量：其值是一个地址，解引用返回地址对应的值；</p>

<p>lvalue是一个持续存在的地址。</p>

<p>在访问一个内存单元时，除了使用名字以外，还可以直接使用地址。C++的地址类型支持这种访问方法。C++的地址类型有两种，指针和引用。</p>

<p>NULL是零值的符号化定义；</p>

<p>引用就是一个单元的别名，也就是一个单元会有多于一个的名字。</p>

<p>malloc函数的参数是以字节计的内存大小，所以程序员需要自己计算待分配单元的字节数。</p>

<p>malloc函数的返回值是无类型指针void *，而程序往往要将它转换为合适的指针类型。</p>

<p>new的参数是待分配单元的数目，它自动计算要分配类型的字节数；如q = new double[10];</p>

<p>new能自动返回正确的指针类型，不必对返回指针进行类型转换。</p>

<p>new可以直接初始化，如q = new double(2.2);</p>

<hr />
<p><h4>Lvalues & Rvalues</h4></p>
<p>Consider an assignment statement.Its purpose to store a value at a memory location. Data object is a general term for a region of data storage that can be used to hold values. The C standard uses just the term object for this concept. One way to identify an object is by using the name of a variable. But, as you will eventually learn, there are other was to identify an object. For example, you could specify an element of an array, a member of a structure, or use a pointer expression that involves the address of the object. C uses the term lvalue to mean any such name or expression that identifies a particular data object. Object refers to the actual data storage, but an lvalue is a label used to indentify, or locate, that storage.
<p> referred to an address in memory;
<p>be used on the left side of an assignment operator; but a const varible can't. so lvalue can be named modifiable lvalue.
<p>rvalue refers to quantities that can be assigned to modifiable lvalues but which are not themselves lvalues.
<p>rvalue can be constants, variables, or any other expression that yields a value,such as a function call.
<p>const variable ,non-modifiable, can be used on the right ise of an expression.
<p>rvalue doesn't represent a specific memory location and you can't assign to it. It's just a temporary value the program calculates, and then discards when it's finished with it.


<h4>2</h4>


<p>If a computer has 1 million bytes of memory, its memory locations range from 0 to 999,999. Among other things, memory locations are used for storing the values of variables. Suppose a variable num has the value 36 and this value is stored at memory location 5000. We say the storage address (or, simply, the address) of num is 5000.</p>

<p>The operator &, when applied to a variable, returns the address of the variable. For example, suppose num is stored at address 5000. Then the value of &num is 5000.</p>

<p>The term pointer is used to refer to an address in memory. A pointer variable is one that can hold the address of  a memory location.</p>

<p>An abstract data type is one that allows a user to manipulate the data type without any knowledge of how the data type is represented in the computer. In other words, as far as the user is concerned, all he needs to know are the operations that can be performed on the data type. The person who is implementing the data type is free to change its implementation without affecting the users.</p>




<p>对于程序中使用到的常量、变量的类型要事先进行定义才能使用，这是保证程序可靠性的手段之一。早期的一些计算机程序设计语言不要求对变量的类型进行定义，因此，一个变量的类型在程序运行期间是不确定的，这将会降低程序的可靠性。</p>



<p>表达式p++ 是表示将指针p往后移动一个字节吗？	</p>

<p>不是。表达式p++ 是表示将指针p往后移动一个元素所占的存储单元（一个或多个字节），而到底是几个字节要由p所指示的元素本身的数据类型所决定。例如：int *p1; char *p2; 此时，p1++表示p1往后移动两个字节，而p2++表示p2往后移动一个字节。</p>

<p>什么是空指针？	</p>

<p>空指针与同类型的其它所有指针都不相同, 也与任何对象或函数的指针都不相等。也就是说, 用取地址操作符&永远也不能得到空指针, 同样对 malloc() 的成功调用也不会返回空指针, 除非调用失败, malloc() 才返回空指针。</p>

<p>实际上，空指针表示“未分配”或者“尚未指向任何地方”的指针。它在概念上不同于未初始化的指针。因为，空指针可以确保不指向任何对象或函数，而未初始化指针则可能指向任何不确定的地方。</p>

<p>C语言中的NULL是代表的什么？	</p>

<p>NULL是C语言中定义的预处理宏，它一般代表0 或者 ((void *)0)，用于表示一个空指针。在C程序中，NULL实际上和0完全等价的。需要注意的是：NULL只能用作指针常量来使用。</p>


定义性声明:需要建立存储空间的(如：int a; )声明。

引用性声明:不需建立存储空间的声明（extern a；)。

声明包括定义，但并非所有的声明都是定义。对“int a;” 而言，它既是声明，又是定义。而对“extern a;” 而言，它是声明而不是定义。








</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>

<!--
_____________________________________________________________________________________

1 段落替换
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])


------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________

4 把第和章两个字去掉
第(\S*)章
------------------
$1
_____________________________________________________________________________________

7 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/
_____________________________________________________________________________________

8
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
9 将标注序号更改为上标，红色，需一个个替换，英文html中有[1]
(\[\d\])
------------------
<sup>$1</sup>
_____________________________________________________________________________________
10 替换章不是以1-9。?！…”“结尾的段落
([^1-90。?！…”：？“章])</p>
<p>
------------------
$1
-->


