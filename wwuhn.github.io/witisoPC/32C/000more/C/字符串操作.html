<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript">
function goTopEx(){
	var obj=document.getElementById("goTopBtn");
	function getScrollTop(){
			return document.documentElement.scrollTop;
		}
	function setScrollTop(value){
			document.documentElement.scrollTop=value;
		}    
	window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
	obj.onclick=function(){
		var goTop=setInterval(scrollMove,10);
		function scrollMove(){
				setScrollTop(getScrollTop()/111);
				if(getScrollTop()<1)clearInterval(goTop);
			}
	}
}

 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>字符串操作</title>

<style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.6em;
}
P{
margin:16px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;
}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 105px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 30px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 80px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 55px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 
img{
border:0;
}
.picsay{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
}
.code0{
color:red;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:0em;
}
.code2{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:2em;
}
.code4{
color:blue;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:2em;
}
</style>
</head>

<body>

<div class="container">

<p>字符串用数组表示：</p>
<p>char str[10];</p>
<p>使用字符数组来标记字符串称为“C风格字符串”。但是使用字符数组来表示字符串有很多不方便的地方：</p>
<p>1 修改困难：如str的初始化和赋值都要通过逐个字符赋值操作；</p>
<p>2 长度限制：如str的长度最多就是10，而且最后一个元素还要用“\0”字符数组结果标记；</p>
<p>3 粒度太小、不直观：</p>
<p>C++不仅支持C风格字符串的使用，还引入string类的概念，该类提供丰富的接口：</p>
<h3>&nbsp;</h3>
<p>#include &quot;stdafx.h&quot;<br />
  #include &lt;iostream&gt;<br />
  #include &lt;string&gt;<br />
  using namespace std;<br />
  int main(int argc, char* argv[])<br />
  {<br />
  string str1 ;<br />
  string str2 = &quot;Your name is :&quot; ;<br />
  cout&lt;&lt;&quot;Enter you name is:&quot;&lt;&lt;endl;<br />
  cin&gt;&gt;str1 ;<br />
  cout&lt;&lt;str2&lt;&lt;&quot; &quot;&lt;&lt;str1&lt;&lt;endl;<br />
  cout&lt;&lt;str1.size()&lt;&lt;endl;<br />
  string str3 = str1 + str2;<br />
  cout&lt;&lt;str3 ;<br />
  cin.get();<br />
  return 0 ;<br />
  }</p>
<p>&nbsp;          </p>
<p>string类与C风格的char*字符串：</p>
<p>const char*字符串可以通过赋值的方式直接转换为string类，而string类也提供了一个方法，使得string类可以快速地转换为const char*类型字符串。这个方法就是c_str()函数。此函数没有参数，当string对象调用该函数时，返回的是指向字符串的指针。如：</p>

<p class="code2">const char * s;</p>
<p class="code2">string str("hello");</p>
<p class="code2">s = str.c_str();</p>
<h4>示例</h4>
<p class="code0">#include &lt;iostream&gt;</p>

<p class="code0">#include &lt;string&gt;</p>

<p class="code0">using namespace std;</p>

<p class="code0">void main()</p>
<p class="code0">{</p>
<p class="code2">string str(&quot;</p>

<p class="code2">hellow world!&quot;);</p>

<p class="code2">const char *str1;</p>

<p class="code2">char str2[20];</p>

<p class="code2">str1 = str.c_str();    //转换为const char *</p>
<p class="code2">count&lt;&lt;str1 &lt;&lt; endl;</p>

<p class="code2">strcpy(str2,str1);     //转换为 char*</p>
<p class="code2">str2[4] = '* ';</p>

<p class="code2">cout&lt;&lt; str2 &lt;&lt; endl;</p>

<p class="code0">}
<p>编译、运行后得到如下结果：</p>

<p class="code0">hellow world!</p>

<p class="code0">hell* world!</p>
<p>一： C风格字符串连接<br />
#include &lt;iostream&gt;<br />
using namespace std;<br />
<br />
int main()<br />
{<br />
 const char *str = &quot;hello &quot;;<br />
 const char *str2 = &quot;world&quot;;<br />
 const size_t len =  strlen(str)+strlen(str2);<br />
 char *n_str = new char[len+1];<br />
 strcpy(n_str,str);<br />
 strcat(n_str,str2);<br />
  cout&lt;&lt;n_str&lt;&lt;endl;<br />
 delete [] n_str;<br />
 return 0;<br />
}<br />
<br />
二|：C++ string类型字符串<br />
#include &lt;iostream&gt;<br />
#include &lt;string&gt;<br />
using namespace std;<br />
<br />
int main()<br />
{<br />
 const string str=&quot;hello &quot;;<br />
 const string str2=&quot;world&quot;;<br />
 string n_str;<br />
 n_str = str;<br />
 n_str +=str2;<br />
  cout&lt;&lt;n_str&lt;&lt;endl;<br />
 return 0;<br />
}</p>
<h4>示例</h4>
<p class="code0">CString m_str1 = "abcdef";</p>
<p class="code0">CString m_str2 = "deq";</p>
<p class="code0">int index = m_str1.Find(m_str2);</p>
<p class="code0">if(index >= 0){</p>
<p class="code2">...finded</p>
<p class="code0">}else{</p>
<p class="code2">...no find</p>
<p class="code0">}</p>

<p>m_str.TrimLeft();</p>

<p>m_str.TrimRight();</p>

<p>VC定义一个字符串变量：</p>
<p>1 recordsDlg.h : </p>
<p>CString m_docx;</p>
<p>CString m_xlsx;</p>
<p>2 recordsDlg.cpp : </p>
<p>m_docx = _T(""); <p>
<p>m_xlsx = "F:\\Website\\notes\\notes.xlsx";</p>
<br />
<p>先用SetSel选中指定范围的文字，然后再调用GetSelText获取选中部分的文字。SetSel(0, -1); // 选中全部文字SetSel(-1, -1); // 选中文字结尾处。</p>
<p>&nbsp;</p>
<h2> 访问字符串中的字符</h2>
<p>string 字符串也可以像字符串数组一样按照下标来访问其中的每一个字符。string 字符串的起始下标仍是从 0 开始。请看下面的代码：</p>
#include <iostream>
#include <string>
using namespace std;
<pre>
int main(){
    string s1 ;
    s1 = "1234567890";
    for(int i=0, len=s1.length(); i&lt;len; i++)
        cout&lt;&lt;s1[i]&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    s1[5] = '5';
    cout&lt;&lt;s1&lt;&lt;endl;
    return 0;
}
</pre>

<p>运行结果：<br />
  1 2 3 4 5 6 7 8 9 0<br />
  1234557890</p>
<p>本例中定义了一个 string 变量 s1，并赋值 &quot;1234567890&quot;，之后用 for 循环遍历输出每一个字符。借助下标，除了能够访问每个字符，也可以修改每个字符。</p>
<h2> 字符串的拼接</h2>
<p>有了 string 类，我们可以使用”+“或”+=“运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。<br />
    <br />
  用”+“来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个 char 字符。请看下面的例子：</p>
<pre>
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1, s2, s3;
    s1 = "first";
    s2 = "second";
    s3 = s1 + s2;
    cout&lt;&lt; s3 &lt;&lt;endl;
	&lt;&lt; s2 &lt;&lt;endl;
    s1 += "third";
    cout&lt;&lt; s1 &lt;&lt;endl;
    s1 += 'a';
    cout&lt;&lt; s1 &lt;&lt;endl;
    return 0;
}

运行结果：<br />  firstsecond<br />  secondfirst<br />  firstthird<br />  firstthirda
</pre>
<p>string提供字符串的功能，使用时需要引用头文件&lt;string&gt;。string和vector类似，vector是对数组的封装，而string是对字符串的封装。</p>
<p>从面向对象的角度来说，C风格字符串是以难以操纵的，所以STL里提供了面向对象的string封装。</p>
<p>string内部仍然是维护一个char型数组，并且也是以0结尾的。对外提供了字符串操作常用的函数，如append,clear,at,length等操作。 </p>
<p>&nbsp;</p>
<h4>string和CString</h4>
<p>CString 是MFC或者ATL中的实现，string是C++标准库中的实现。</p>
<p>string和CString均是字符串模板类，string为标准模板类（STL）定义的字符串类，已经纳入C++标准之中；</p>
<p>CString（typedef CStringT<TCHAR, StrTraitMFC<TCHAR>> CString）为Visual C++中最常用的字符串类，继承自CSimpleStringT类，主要应用在MFC和ATL编程中，主要数据类型有char(应用于ANSI)，wchar_t(unicode)，TCHAR(ANSI与unicode均可)；</p>
<p>char*为C编程中最常用的字符串指针，一般以’\0’为结束标志；</p>

<p>在MFC、ATL中使用字符串尽量使用CString，毕竟都是微软的孩子，各方面都比其它更有优势，而在非微软平台上或对移植性要求较高的场合推荐使用string，标准模板库提供了那么强大的泛型算法，没必要再自己去造车轮。</p>

<p>（1）CString 类是微软的visual c++提供的MFC里面的一个类，所以只有支持MFC的工程才可以使用。如在linux上的工程就不能用CString了，只能用标准C++中的 string类了。另外，因为string类是在c++标准库中，所以它被封装在了std命名空间中，使用之前需要声明using namespace std;而CString类并不在std命名空间中，因为它不是c++的标准库，只是微软的一个封装库。这点看来用string类的程序的移植性更好。</p>
<p>（2）string类既是一个标准c++的类库，同时也是STL（Standard Template Library,标准模版库）中的类库，所以支持Iterator操作。</p>
<p>（3）CString类和string类提供的方法接口并不完全相同，所以不要糊里糊涂的认为某个类中怎么没有另外一个类中的方法。</p>
<p>（4）他们和char*之间的转换方法也不一样。</p>
<p>string是语言的东西，是c++语言的。CString是VC++ IDE内嵌的，是MFC的。CString离开VC++不能用，string 在任何支持C++的IDE中都能用。</p>
<h2>&lt;string.h&gt;</h2>
<p>&lt;string.h&gt;是C版本的头文件，包含比如strcpy、strcat之类的字符串处理函数。</p>
<h2><a name="t1" id="t1"></a>&lt;cstring&gt;</h2>
<p>在C++标准化(1998年)过程中，为了兼容以前，标准化组织将所有这些文件都进行了新的定义，加入到了标准库中，加入后的文件名就新增了一个&quot;c&quot;前缀并且去掉了.h的后缀名，所以string.h头文件成了cstring头文件。但是其实现却是相同的或是兼容以前的，这就是&lt;cstring&gt;的来源，不要觉得又多了一个东西。相当于标准库组织给它盖了个章，说“你也是我的标准程序库的一份子了”。</p>
<h2><a name="t2" id="t2"></a>&lt;string&gt;</h2>
<p>&lt;string&gt;是C++标准定义的头文件，它定义了一个string的字符串类，里面包含了string类的各种操作，如s.size(),s.erase(),s.insert()等。但&lt;string&gt;又包含了老的C版本的字符串操作如strcpy、strcat等，这就相当于，在&lt;string&gt;的文件中除了定义自己的string类之外，还加了一个#include&lt;string.h&gt;一句包含了C版本的字符串操作。</p>
<h4><a id="cb_post_title_url" href="http://www.cnblogs.com/lidabo/archive/2012/08/27/2658528.html">C 风格字符串，C++string类，MFC，CString类的区别。</a></h4>

    <p>字符串，顾名思义是由字符组成的字符串，在标准C，标准C++，MFC中字符串这一功能的实现是不相同的，C++完全兼容了C。</p>
    <p>1.标准C中的字符串</p>
<p>在标准C中没有string这样的数据类型，C中的字符串是有char类型的字符数组或者char类型的字符指针来实现的。例如：</p>
<p>char name[26]=&quot;This is a C-style string&quot;;或者</p>
<p>char *name=&quot;This is a C-style string&quot;;</p>
<p>类型的字符串以\0为结束标记，所占内存是实际子符长度+1，其初始化和赋值都要逐个字符的赋值，修改不辨，粒度太小，很不直观，是程序员分散了一些软件的高级层面问题，如算法，抽象数据类型或软件构架。char    *没有构造函数，仅能由指针赋值，而且是一个极其危险的操作，在声明char   *的时候如果没有赋初值，建议先初始化为NULL，以免出现悬浮指针或者指向地址不明的指针，否则，出错会让你很爽!</p>
<p>标准C中是没有string类型，但是在C中有string.h头文件，需要注意的是此string.h中的string非彼string，&lt;string.h&gt;头文件中定义了一些我们经常用到的操作字符串的函数，如复制函数strcpy，连接字符串strcat，比较字符串strcmp，这些函数的操作对象都是指向char   *的字符串。</p>
<p>2.标准C++中的string类</p>
<p>C++支持C风格字符串的使用，而且引入了string类的概念，string为标准模板类STL定义的字符串，几乎可以从所有的字符串构造出来。</p>
<p>string字符串类的都文件是&lt;string&gt;,并且要和using　namespace std;   一起使用。头文件&lt;string&gt;和头文件&lt;string.h&gt;没有任何关系，前者是标准C++中的模板库类，后者是标准C中的包含常用C字符串处理函数的头文件，如strcmp，前者并非是后者的升级版。</p>
<p>要深刻理解标准C++中string是一个类，如在标准C中定义如下：char * pt=NULL;     这无疑是正确的，但是在标准C++中定义 string   *pt=NULL；这样做编译器不会有警告和错误，但是运行是就会有异常。这是因为string作为一个类，定义类的对象时要调用其构造函数的，上面的例子既没有调用其构造函数，还把指针赋值为NULL,很明显就会出错的。正确的方法是是new操作符，C++中的new不同于C中的malloc，   new不但会分配一块内存，还调用类的构造函数。string *pt=new(&quot;this is a c++-style   string&quot;);或者不用指针string str;系统自动调用默认的构造函数，构造一个string类的对象。</p>
<p>3. MFC中的CString类。</p>
<p>MFC中的字符串类是CString，封装了string的东西，并增加了一些接口，在功能上完全兼容string类，而一些标准的C/C++不能直接对CString类进行操作，CString   类是微软的visual   c++提供的MFC里面的一个类，所以只有支持MFC的工程才可以使用。如在linux上的工程就不能用CString了，只能用标准C++中的   string类了。另外，因为string类是在c++标准库中，所以它被封装在了std命名空间中，使用之前需要声明using namespace   std;而CString类并不在std命名空间中，因为它不是c++的标准库，只是微软的一个封装库。这点看来用string类的程序的移植性更好。CString和string提供的接口方法不同，对char*的转换也不同。下面的转换内容来自CSDNBLOG:http://blog.csdn.net/bitxinhai/article/details/2292014</p>
<p>4.1 CString 和string的转换</p>
<p>stringstr=&quot;ksarea&quot;;<br />
      CStringcstr(str.c_str());    //或者CString cstr(str.data());初始化时才行<br />
      cstr=str.c_str();或者cstr=str.data();<br />
      str=cstr.GetBuffer(0);//CString -&gt; string<br />
      cstr.format(&quot;%s&quot;,str.c_str());    //string-&gt;CString<br />
      cstr.format(&quot;%s&quot;,str.data());    //string-&gt;CString<br />
      str=LPCSTR(cstr);//CString-&gt;string<br />
      /*c_str()和data()区别是：前者返回带'/0'的字符串，后者则返回不带'/0'的字符串*/</p>
<p><strong>4.2.CString</strong><strong>和int的转换</strong>int i=123;<br />
      CStringstr;<br />
      str.format(&quot;%d&quot;,i);    //int-&gt;CString其他的基本类型转化类似<br />
      i=atoi(str);//CString-&gt;int还有(atof,atol)<strong><br />
<br />
4.3.char*</strong><strong>和CString的转换</strong>CString cstr=&quot;ksarea&quot;;<br />
      char* ptemp=cstr.getbuffer(0);<br />
      char* str;<br />
      strcpy(str,ptemp);//CString-&gt;char*<br />
      cstr.releasebuffer(-1);<br />
      char*str=&quot;lovesha&quot;;<br />
      CStringcstr=str;//char*-&gt;CString
	  
	  <p>string类型不能直接赋值给CString。至于int与float、string与char*之间的转化可以使用强制转化，或者标准库函数进行。对于CString与其他类型的转化方法很多，但其实都殊途同归，朝着一个方向即将类型首先转化为char*类型，因为char*是不同类型之间的桥梁。得到char*类型，转化为其他类型就非常容易了。这篇文章：   http://hi.baidu.com/sage_haokun/blog/item/a44b9733aa14d812ebc4afbc.html   ，还不错，主要讲述CString和string的区别，感兴趣的可以去瞅一下。</p>
  </div>
</div>
<p>&nbsp;</p>
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>

<!--
_____________________________________________________________________________________

1 段落替换：
\s*</p>

<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])
------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
[\s*</p>\s*]
[\s*<p>\s*]
------------------
</p>

<p>

<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
-->