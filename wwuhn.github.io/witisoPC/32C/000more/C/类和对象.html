<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script language="javascript"> 
//bg_even("表格ID属性名","奇数行背景色","偶数行背景色","鼠标经过背景色","点击后背景色");
function bg_even(o,a,b,c,d){
        var t=document.getElementById(o).getElementsByTagName("tr");
        for(var i=0;i<t.length;i++){
                t[i].style.backgroundColor=(t[i].sectionRowIndex%2==0)?a:b;
                t[i].onclick=function(){
                        if(this.x!="1"){
                                this.x="1";
                                this.style.backgroundColor=d;
                        }else{
                                this.x="0";
                                this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                        }
                }
                t[i].onmouseover=function(){
                        if(this.x!="1")this.style.backgroundColor=c;
                }
                t[i].onmouseout=function(){
                        if(this.x!="1")this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                }
        }
}

 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>类和对象</title>

<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body> 
<div id="container">
<!--
<table id="tbrowser">
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
-->

<!--
height="*\w*"
width="*\w*"
</p>
<p>
-->

<p>类是一种复杂的数据类型，它是将不同类型的数据和对这些数据相关的操作封装在一起的集合体。因此在C++的类定义中不仅可以有数据，即数据成员，还可以有对数据进行操作的函数，即类的成员函数。类具有高度的抽象性，类中的数据具有隐藏性，类还具有封装性。类是一种用户自定义的类型，是一种类型的实现。把同类的事物根据不同的特征分成许多具体的个体，这些个体称为“对象”。</p>
<p>类的结构是用来确定一类对象的行为的，而这些行为是通过类的内部数据结构和相关的操作来确定的，这些行为通过一种操作接口来描述。</p>
<p>类的定义格式一般分为说明部分和实现部分。说明部分是用来说明该类中的成员，包含数据成员的说明和成员函数的说明。成员函数是用来对数据成员进行操作的，又称为“方法”。实现部分是用来对成员函数定义。概括地说，说明部分将告诉使用者“十什么”，而实现部分是告诉使用者“怎么干”。如：</p>
<p></p>
<pre>
class classname
{
private:
    &lt;私有数据成员和成员函数的说明&gt;;
protected:
    &lt;保护数据成员和成员函数的说明&gt;;
public:
    &lt;公有数据成员和成员函数的说明&gt;; //外部接口 
}；
</pre>
<p>有些类，如果实现部分较小，可以将说明部分和实现部分合并在一起，都放在类内定义。如果有些成员函数在类内进行了声明，而实现部分放在了类外，则需要类外定义的部分。</p>
<p>类名::函数名(参数列表)</p>
<p>::称为作用域运算符，也称作用域分辨符，它是用来表示某个成员函数是属于哪个类的。</p>
<p>protected限定友元函数和派生类可以访问；</p>
<p>对象成员的访问</p>
<p>对象名.数据成员；</p>
<p>对象名.成员函数名()</p>
<p>&nbsp;</p>
<p>*对象指针名.数据成员名</p>
<p>对象指针名-&gt;数据成员名</p>

<p>类class是对结构体struct的增强，也是用于自定义类型。</p>
<p></p>
<pre>
struct Object
{
    int a;
    int b;
    double c;
};
class Object
{
    public:
    int a;
    int b;
    double c;
};
</pre>
<p>对成员函数的调用方法和成员变量差不多，也是用点号或用箭头。</p>
<p>Object obj;</p>
<p>obj.Test();</p>
<p>Object* p = &amp;obj;</p>
<p>p-&gt;Test();</p>
<p>类的分离式写法</p>
<p>可以把成员函数的定义写在类体之外，遵循以下步骤：1 在类里保留成员函数的声明；2 在类外定义该成员函数，函数名字前面加上类名的范围前缀。如：</p>
<pre>
class Object	// 写到头文件，如declar.h
{
    public:
    int x;
    void Test();
};
void Object::Test()	// 写到实现文件，如imple.cpp
{
    ...
}
int main()	//写到main.cpp，并在内包含declar.h
{
    Object obj;
    obj.Test();
}
</pre>
<p>通常，它们分别写在头文件（.h）和源文件（.cpp）中；</p>
<p>构造函数是类的一种特殊的成员函数，1 函数名与类名相同；2 没有返回值；3 不能直接调用，在创建对象时系统自动调用； </p>
<p></p>
<pre>
class Circle
{
    Circle()
    {
        x = y = 0;
        radius = 1;
    }
public:
    int x, y;
    int radus;
};
</pre>
<p>构造函数也可以重载，这意味着一个类可以有多个构造函数，只是它们的参数列表不同就可以；</p>
<p>析构是构造的反过程，表示的是对象的销毁过程。构造函数是在对象创建时被调用；析构函数则是在对象被销毁时被调用。对于有些对象来说，在它的生命周期中申请了一些资源，那么当它的生命斯结束时，必须记得释放和归还这些资源。1 名称固定：类名前加~; 2 没的返回值；3 不能带参数； </p>
<p></p>
<p>面向对象设计有3个主要特征：封装、继承和多态。继承使得一个类可以从现有类中派生，而不必重新定义一个新类。继承的实质就是用已有的数据类型创建新的数据类型，交保留已有数据类型的特点。在既有类基础上创建新类，新类包含了旧类的数据成员和成员函数，并且可以在新类中添加新的数据成员和成员函数。旧类被称为基类或父类，新类被称为派生类和子类。</p>
<p></p>
<pre>
class 派生类名称标识符:[继承方式] 基类名标识符
{
[:访问控制修饰符:]
    [成员声明列表]
} 
</pre>
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>


<!--
_____________________________________________________________________________________

1 段落替换：
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])
------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
[\s*</p>\s*]
[\s*<p>\s*]
------------------
</p>

<p>

<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
-->

