<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>C和C++的区别和联系</h4>

<p>关于C和C++的区别是面试中经常会被问到的问题，本着即将面试的心态，进行知识整理，并对小知识点进行扩展；</p>

<p>C/C++的联系：</p>

<p>C++是C的超集，兼容大部分C的语法的结构；</p>

<p>联系嘛我只能想到这个，毕竟cplusplus嘛！</p>

<p>C/C++区别：</p>

<p>第一点就应该想到C是面向过程的语言，而C++是面向对象的语言，一般简历上第一条都是熟悉C/C++基本语法，了解C++面向对象思想，那么，请问什么是面向对象？</p>

<p>C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还有new/delete关键字；（关于malooc/free与new/delete的不同又可以说一大堆，最后的扩展_1部分列出十大区别）；</p>

<p>接下来就不得不谈到C中的struct和C++的类，C++的类是C所没有的，但是C中的struct是可以在C++中正常使用的，并且C++对struct进行了进一步的扩展，使struct在C++中可以和class一样当做类使用，而唯一和class不同的地方在于struct的成员默认访问修饰符是public,而class默认的是private;</p>

<p>C++支持函数重载，而C不支持函数重载，而C++支持重载的依仗就在于C++的名字修饰与C不同，例如在C++中函数int fun(int ,int)经过名字修饰之后变为 _fun_int_int ,而C是_fun，一般是这样的，所以C++才会支持不同的参数调用不同的函数；</p>

<p>C++中有引用，而C没有；这样就不得不提一下引用和指针的区别（文后扩展_2）;</p>

<p>当然还有C++全部变量的默认链接属性是外链接，而C是内连接；</p>

<p>C 中用const修饰的变量不可以用在定义数组时的大小，但是C++用const修饰的变量可以（如果不进行&,解引用的操作的话，是存放在符号表的，不开辟内存）；</p>

<p>当然还有局部变量的声明规则不同，多态，C++特有输入输出流之类的，很多，下面就不再列出来了；</p>

<p>小知识点补充扩展</p>

<p>扩展_1: 细数malloc/free和new/delete的十点区别</p>

<p>1.malloc是从堆上开辟空间，而new是从自由存储区开辟；（自由存储区是C++抽象出来的概念，不仅可以是堆，还可以是静态存储区）；</p>

<p>2.malloc/free是函数，而new/delete是关键字；</p>

<p>3.malloc对开辟的空间大小需要严格指定，而new只需要对象名；</p>

<p>4.malloc开辟的空间即可以给单个对象用也可以给数组用，释放的方式都是free()；而new开辟对象数组用的是new[size] ,释放的的时候是 delete[](尽管内置类型可能不会引起问题，但是自定义类型的话，delete[]需要知道有多少个对象，而这个计数就被放在这块空间的头部);</p>

<p>5.返回值问题，malloc开辟成功返回void*，需要强转，失败返回NULL，new成功返回对象指针，失败抛出异常（这就可能会提到C++的new_handler机制），虽然为了最大程度的兼容C，C++的new也支持失败返回NULL，但是一般不被使用，大家可以了解一下；</p>

<p>6.是否调用构造和析构，这点应该放在前面，new和free不但负责开辟空间，还会调用对象的构造函数和析构函数；</p>

<p>7.最好了解一下new的三种表达形式（new运算符，operator new(); placement new();）还有定位new表达式的使用；</p>

<p>8.是否可以相互调用，new的实现可以用malloc，malloc的实现不可以使用new；</p>

<p>9.是否可以被重载，我们可以重载自己的operator new/delete，但是不可以重载new/delete/malloc/free;</p>

<p>10.malloc开辟的内存如果太小，想要换一块大一点的，可以调用relloc实现，但是new没有直观的方法来改变；</p>

<p>第十点其实前面已经提到，当new中的底层实现如果获取不到更多的内存，会触发new_handler机制，留有一个set_new_handler句柄，看看用户是否设置了这个句柄，如果设置了就去执行，句柄的目的是看看能不能尝试着从操作系统释放点内存，找点内存，如果实在不行就抛出bad_alloc异常；而malloc就没有这种尝试了；——-</p>

<p>扩展_2 指针和引用的区别</p>

<p>1.指针有自己的一块空间，而引用只是一个别名；</p>

<p>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>

<p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</p>

<p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>

<p>5.可以有const指针，但是没有const引用；</p>

<p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p>

<p>7.指针可以有多级指针（**p），而引用至于一级；</p>

<p>8.指针和引用使用++运算符的意义不一样；</p>

<p>扩展_3 常见关键字的作用</p>

<p>**1.static 关键字：**</p>

<p>修饰全局变量时，会将变量的链接属性变为内部链接属性，并且变量的存储位置变为全局静态区；</p>

<p>修饰局部变量，改变局部变量的存储位置为静态存储区，改变局部变量的生命周期为整个程序开始到结束；</p>

<p>修饰类的成员变量和函数：属于类而不属于对象，属于所有实例类；</p>

<p>**2.const关键字**</p>

<p>修饰全局变量：C/C++略有不同，在上文已经提到，即C++的const修饰的全局变量可以作为属组的初始化的大小，而C不可以；同时变量的值不能被修改；C++利用const的这一属性，代替C中的define进行全局常量的定义；扩展_4会就 define，const，inline进行对比和分析；</p>

<p>修饰局部变量:代表局部变量的值不能被修改；</p>

<p>修饰指针：这个是经常问道的，我举的例子可能不全面，但是是比较</p>

<p>常见的例子：</p>

<p>cons t int *p; //修饰的是p所指向的内容不能被改变，p可以；</p>

<p>int const *p; //和上面是一样的；</p>

<p>int* const p; //修饰的p指针不能改变；</p>

<p>修饰类的成员变量：必须在初始化列表初始化，除此之外，必须在初始化列表初始化的还有，引用类型的数据成员，没有默认构造函数的对象成员，如果存在继承关系，如果父类没有默认的构造函数，则也必须在初始化列表中被初始化，初始化列表对数据成员的初始化顺序是按照数据成员的声明顺序严格执行的；</p>

<p>修饰类的成员函数：一般放在成员函数的最后面，修饰的是类的成员函数中的隐藏参数this指针，代表不可以通过this指针修改类的数据成员，声明形式例如：</p>

<p>Base::void fun() const;</p>

<p>关于const还有一个问题就是传参和赋值的问题，一般来说，const修饰的变量是安全的，没有const修饰的变量是不安全的，一般在传参的时候，非const修饰的的变量可以传给const修饰的，而const修饰的不可以传给非const修饰的形参，这就相当于把安全的东西交给了不安全的人；而赋值的话更不用说了，const修饰的不可以传给没有const修饰的变量；</p>

<p>**3.volatile**</p>

<p>volatile一般修饰变量，而它存在的原因是因为，我们的程序在进行编译的时候，编译器会进行一系列的优化，比如，某个变量被修饰为const的，编译器就认为，这个值是只读的，就会在寄存器中保存这个变量的值，每次需要的时候从寄存器直接读取，但是有时候，我们可能会在不经意间修改了这个变量，比如说我们去了这个变量的地址，然后强行改变这个变量在内存中的值，那么编译器并不知道，读取还是从寄存器中读取，这就造成了结果的不匹配，而volatile声明的变量就会告诉编译器，这个变量随时会改变，需要每次都从内从中读取，就是不需要优化，从而避免了这个问题，其实，volatile应用更多的场景是多线程对共享资源的访问的时候，避免编译器的优化，而造成多线程之间的通信不匹配！</p>

<p>explicit关键字</p>

<p>首先需要了解什么是隐式转换，即在你没有进行显示的强转的情况下，赋值运算符左右两个类型不一致的对象进行了类型转换；或者函数传参的时候进行了类型转换； 而explicit关键字存在的目的就是禁止类的构造函数进行隐式的类型转换，常见的就是string类的对象就可以隐式类型转换，比如：</p>

<p>strig s = "hello world";</p>

<p>因为string 有一个单参的char*构造函数，所有可以用hello world构造一个string对象，然后调用string 类的拷贝构造函数；有时候我们并不希望这种不是我们预期的情况发生，所以，我们可以在类的构造函数之前+explicit关键字。禁止隐式转换；</p>

<p>---希望读者提建议继续补充！（补充文章中讲到的所有内容的不足之处）</p>

<p>扩展_4 define /const/inline 对比和分析</p>

<p>define作用于程序的预处理阶段，而预处理阶段做的主要工作为下面几个方面：宏替换，去注释以及条件编译； define起作用的地方就在宏替换阶段，只是单纯的将宏替换为代码，例如：</p>

<p>#define Add(a+b) a+b</p>

<p>下面这段代码用到了这个宏：</p>

<p>int main()</p>

<p>{</p>

<p>int a = 1; //如果char a = '1';</p>

<p>int b = 2;</p>

<p>cout&lt;&lt;Add(a+b);</p>

<p>/* 替换为cout&lt;&lt;1+2; */</p>

<p>return 0;</p>

<p>从上面这个例子我们可以看出define的缺点很明显，首先，define只是单纯的代码替换，不会进行类型的检查，再者，我们上面的宏定义也很粗糙，严格点应该定义为: #define Add(a,b) (a)+(b) C++中一般建议使用const，枚举定义常量，这样就会有类型检查； 而宏定义也可以定义出和函数一样的功能： #define Swap(type，a,b) {type tmp, tmp = a; a = b; b = tmp;} 其实就算这样写，也还是存在上面提到的问题，并且这样还不能进行调试，因为宏在预处理阶段就替换了；</p>

<p>于是C++中又提供了一个inline内联关键字，可以实现和define相同的功能，并且支持类型检查和调试，一般声明在函数的定义的前面，不过， inline只是对编译器的一种建议，一般如果代码在3-5行左右，且没有复杂的逻辑结构，例如循环啊，递归啊，就可以声明为inline，inline也是在函数调用的地方替换代码块，所以代码太长的话，容易造成程序膨胀，那么inline为什么可以支持调试呢？</p>

<p>其实支持调试也只是在dbug模式下，inline真正起作用是在release模式，正好和assert相反；</p>

<p>提到inline,就不得不提friend友元；被一个类中声明为友元的非本类函数和类，可以访问本类的私有成员，这个关键字的存在感觉有些破坏类的封装性，而且，友元属性不能被传递和继承；（但是实际中在有些编译器下友元函数被子类继承了，我也很纳闷，读者可以自己验证一下，</p>



<p style='float:right;'>本页共76段，4544个字符，10886 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
