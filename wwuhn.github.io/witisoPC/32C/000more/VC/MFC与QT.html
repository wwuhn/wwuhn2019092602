<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>MFC与QT</h3>

<p>2016年06月28日
</p>

<p>QT使用的编译器是MinGW，即Linux下的GCC移植到windows的版本；MFC使用的编译器是Visual C++
</p>

<p>QT的应用主要在Linux下，但是它本身是跨平台的，也支持其他操作系统，是现在比较著名的界面库，著名的KDE就是使用QT开发的。MFC是提供给VC的，但是它主要是代码库，不像VCL和编译器挂钩很多，但是MFC主要是对windows API的封装，所以只能用于windows平台。
</p>

<p>1 开发速度
</p>

<p>整体来说可能MFC会快捷一些，因为windows平台的开发工具大多很智能，因为立足于windows的开发人群很广，从菜鸟到专业人士，但是QT由于基于Linux，可用的开发工具不多，大都比较专业，多是第三方产品，而且集成度不大，第三方库也没有MFC的多，从这一点MFC略胜一筹，但是QT自从被Nokia收购后，官方发布了跨平台集成开发环境QTCreator，所以之后走向就不好说了，个人总体感觉QT Creator和VS。net差距比较大，还需改进。
</p>

<p>但是从库本身来说QT集成的功能较MFC庞大，而且使用的封装技术信号和槽也是比较受到赞许的，比如QT Script为QT提供嵌入式脚本，QT界面库支持CSS，所以QT做出来的界面比MFC要好，而且比较容易，MFC就需要借助第三方库了。因为MFC是浅层封装（最新的2008 sp1加入了BCG的高级界面库，可能有所改善）windows SDK，以降低使用windows SDK引起的开发效率的降低，和开发难度的增加。所以QT库是比MFC优秀的，两个库都经受了时间的考验，稳定性都很高，Bug几乎没有
</p>

<p>2 运行效率
</p>

<p>MFC由于其浅层封装的特点，所以运行效率是比较高的，加上vc对windows的针对性优化，整体性能是比较高的，但是如果加入第三方库就不敢保证了。QT因为库比较庞大，封装层次较深，所以运行效率较MFC为低，但是在现在的机器配置下，C#大家都不介意了，这些会引起人们的介意吗？
</p>

<p>3 应用范围，现在windows的普及范围谁能比过，所以MFC的客户量比较多，QT主要是Linux下的开发人员在使用，但MFC也只是得益于windows（感觉又是一次捆绑战略），MFC不支持嵌入式开发（主要指手机平台），但是QT有对应的模块。
</p>

<p>4 学习难度
</p>

<p>QT的封装哲学比较明晰，和系统隔离的比较好，所以个人感觉门槛不高。
</p>

<p>MFC较难精通，因为深入开发之后SDK还是要了解的，否则程序感觉比较儿童化，呵呵。
</p>

<p>最近用了一段时间Qt，觉得网上这篇文章讲述Qt与MFC之间的区别很到位，分享一下。
</p>

<p>----------------------------------原文----------------------------------------------------
</p>

<p>我曾经使用过QT和MFC来开发过软件，我想和大家分享我使用他们时所体会的不同之处。
</p>

<p>我并非一个职业作家，这篇文章可能看起来不如专业的杂志和网站上的那么条理清晰。但是，我在这里是用我自己的语言来表达我自己的经验，希望能和你分享。英语比不是我的母语，所以可能会有一些用词古怪，词句错误之处，请发信给我，我可以改正他们。
</p>

<p>本文不想假装客观公正，我只想表述我使用的经验。文中不会逐条的列举Qt和MFC各自的优缺点。我在使用MFC之前就已经使用Qt这个事实可能影响了我的客观性。
</p>

<p>文章从实用主义的观点出发：我的老板给我一份软件的规划说明，并且让我来开发。其中一些我用Qt来开发，而另外一些我使用MFC来开发。
</p>

<p>MFC（微软基础类库）是专门为windows设计的一个用于开发图形用户界面的类库。MFC或多或少使用了面向对象的方法包装了Win32的API，正因如此，这些API有时是C++，有时是C，甚至是C和C＋＋的混合体。
</p>

<p>Qt这个C++的图形库由Trolltech在1994年左右开发。它可以运行在Windows、Mac OSX、Unix，还有像Sharp Zaurus这类嵌入式系统中。Qt是完全面向对象的。Document/View model MFC编程需要使用Document/View模式以及模板(template)，如果不使用的话，编程将变得异常困难。而且，模板(template)设定了固定的结构，若所需结构乃模板未定义之结构，则编程难已。例如，划分一区域使显示两个视图(view)于两个文档(document)。还有一个经常的问题是：模板(template)创建了视图(view)却无法访问(access)它，文档（document）要做完所有事情，但是这经常会出现问题。 (这种数据和视图分开的设计模式也是一种不错的模式，不应该成为否定MFC的理由）。Qt不强制使用任何设计模式。如果你认为恰当，使用Document/view没有任何问题。不使用也没有任何问题。
</p>

<p>伪对象 vs 真对象
</p>

<p>归根结底，Qt和MFC的差异在于其设计的差异。MFC的根本目的是访问包装起来的用C语言写的windows的API。 这绝非好的面向对象的设计模式，在很多地方，你必须提供一个包含15个成员的C语言的struct，但是其中只有一个与你所期望的相关，或者必须用旧式的参数来调用你的函数。MFC还有许多让人摸不着头脑的地方，函数名没有任何的连续性。比如，如果你创建了一个graphical类，直到调用了creat()以后该类才会被创建。然而对dialogs，必须要等到OnInitDialog()才能创建这个对象。奇怪的是到了views，创建该类的函数名竟然成了OnInitUpdate()，你自己创建一个类用他们的方式调用它，你的程序崩溃了。
</p>

<p>比如说有一个dialog包含CEdit控件，如果没有调用DoModal()你就不能使用GetWindowText()。否则将会莫名其妙的失败。总之，MFC充满了丈二和尚摸不着头脑的事情，并且，这种错误很难调试。 （诚然，MFC是为了封装Window API。用MFC比WinowsAPI会简单些，但确实有些函数的调用时机、先后顺序，如果不是用过一段时间，确实可能因此导致问题）
</p>

<p>Qt恰恰相反，它的架构明显是经过精心设计的面向对象的。Qt因此在命名，继承、类的组织等方面保持了优秀的一致性。你只需要提供唯一一个方法的参数，仅此一个。在不同的类中调用方式也是有很强的连贯性。返回值也很有逻辑性。所有一切达到了简单和强大的和谐统一。一旦你使用了其中一个类，其他的类也就触类旁通，因为他们是一致的。在Qt中可以利用Edit控件，用C++创建类的方法来创建自己的QLineEdit。永远可以马上访问任何的方法，不管它是显示还是隐藏。在这里没有迷局，一切都按照你认为的简单的方式来运作。
</p>

<p>消息循环
</p>

<p>MFC是事件驱动的架构。要执行任何操作，都必须是对特定的消息作出响应。Windows对应用程序发送的信息数以千计，遗憾的是，要分清楚这些纷繁芜杂的消息是很困难的，并且关于这方面的文档并不能很好的解决这些问题。
</p>

<p>Qt的消息机制是建立在SIGNAL()发送和SLOT()接受的基础上的。这个机制是对象间建立联系的核心机制。利用SIGNAL()可以传递任何的参数。他的功能非常的强大。可以直接大传递信号给SLOT()，因此可以清楚的理解要发生的事情。一个类所发送的信号的数量通常非常的小(4或者5)，并且文档也非常的齐全。这让你感觉到一切尽在掌握之中。SIGNAL/SLOT机制类似于Java中listener机制，不过这种机制更加轻量级，功能更齐全。（这种机制确实貌似简单清晰了一些）
</p>

<p>创建界面
</p>

<p>MFC无法创建大小动态可变的子窗口，必须重新手动修改代码来改变窗口的位置（这恰好解释了为什么windows里的dialog是不可以改变的）这个问题在软件进行国际化翻译的时候更加严重，因为许多国家表达相同意思需要更长的词汇和句子，必须要对每个语言的版本重新修改自己的软件。
</p>

<p>在Qt中，任何东西都可以手动的敲出来，因为它很简单：为了得到一个button，可以这样些button = new PushButton( "buttonName"， MyParentName )；如果想在按下某个按钮以后想调用某断代码的执行，可以这样写：connect( button， SIGNAL( clicked() )， qApp， SLOT( action() ) )；Qt拥有非常简单而又不失强大的layout机制，以至于不使用它就是在浪费时间了。
</p>

<p>Qt还提供了一个图形用户工具，Qt Designer，可以用来帮助建立用户界面。可以修改所使用的任何控件的属性。不用将他们放在严格的位置，可以通过layout完美的组织他们。
</p>

<p>这个工具所产生的代码我们是可以实际上阅读并且可以理解的。生成的代码单独放在一个文件里，在编程的同时，你可以随心所欲的多次重新生成用户界面。
</p>

<p>Qt Designer可以让你完成许多在MFC中不可能完成的任务，比如用预先填好的生成listview，在每个tab上用不同的view来使用tab 控制。 （界面方面Qt确实很好很强大）
</p>

<p>帮助文档
</p>

<p>用户选择图形开发环境的时候，帮助文档是否周全是左右其选择的重要因素。Visual的开发环境的帮助文档MSDN(这个还要单独掏钱购买)非常的庞大，有10个CDROM光盘。他包罗万象，涵盖广泛。但是难免有泥沙俱下，主题模糊，关键信息不突出的遗憾。其链接设计的也很糟糕，通过链接很难从一个类跳转到其父类或者子类以及相关的类。如果你搜索一个关键字，不管是Visual C++， Visual J++， Visual Basic，只要包含这些关键字的信息统统的返回来。
</p>

<p>Qt的文档设计的相当优秀。你可以到doc.tolltech.com上面一睹芳容。Qt的文档完备且详细的覆盖了Qt的方方面面，竟然仅有18M。每一个类和方法都被详尽描述，巨细靡遗，举例充实。通过Trolltech公司提供的链接或者是Qt Assistant工具，可以方便的从一个类或者方法跳转到其他的类。文档还包含了一个初学者教程和一些典型应用的例子。同时还提供了FAQ和邮件列表，方便通过Internet或者用户群来查阅。如果你购买了授权，在一天之内你将会得到Trolltech公司的技术支持。实际上，Qt优秀的帮助文档使得寻求外部帮助的机会大大减少。Tolltech公司的一个宗旨是：有如此优秀的Qt产品以及其帮助文档，技术支持是多余的。
</p>

<p>(MSDN用熟了很好用，很全面，相关的背景知识，例子都能找到。而且网上还有丰富的例程可以参考。仅凭Qt的帮助文档绝对不足以解决所有问题，而网上我只找了个Qt中文论坛，提过几个问题，有的给出了解决办法，有的也没人回答，还要靠自己试)
</p>

<p>Unicode
</p>

<p>使用MFC，如果要显示unicode，在编译链接的时候必须用到特殊的参数(和改变可执行文件执行的入口)，必须在每个string前面加上T，将char修改成TCHAR，每个字符串处理函数(strcpy()， strdup()， strcat()……)都要改变成另外的函数名。更令人恼火的是支持Unicode的软件竟然不能和不支持Unicode的DLL一起工作。当使用外部DLL来开发的时候
</p>

<p>这是个很严重的问题，但是你毫无选择。
</p>

<p>使用Qt，字符串用QString来处理，其本身是与生俱来的Unicode。不需要改变什么东西。不要在编译/链接时候增添参数，不要修改代码，只需要使用QString就可以了。QSting类功能强大，你可以广泛的使用它，并且不要担心Unicode问题。这使得转换为Unicode非常的方便。QSting提供了转换为char* 和UTF8的函数。显然，MFC的CString的设计相比于Qt的QString设计有着巨大的不同。CString以char*为基础提供了很少的功能。它的优点是当需要char* 类型的时候，可以直接使用CString类型。乍看起来这个好像是个优点，其实实质上还是有很大的缺陷的，特别是可以直接修改char * 而不要更新类。在转变为Unicode的时候这个也碰到很大的麻烦。（CString随编译选项可以是Unicode版）相反，QString在内部以unicode存储string，需要时提供char* 功能。实际上很少用到char* ，因为整个Qt的API用文本的方式响应QString参数。QString还附带许多其他的功能，比如自动分享QString的内容。这是一个非常强大的类，你会喜欢在很多地方用它的。
</p>

<p>国际化
</p>

<p>使用MFC是可以国际化的，但是需要将每一个字符串放在一个字符串表中，在代码中到处使用LoadString(IDENTIFIET)。然后转化这些资源到DLL中，翻译字符串到所需要的语言，改变图形界面，然后调用程序使用这个DLL。整个过程是如此的繁琐，可谓牵一发而动全身。考虑的事情要面面俱到。
</p>

<p>使用Qt的时候，只需要将字符串置于函数tr()中，在程序开发中这算是举手之劳。可以直接在代码中改变字符串的参考。Qt Linguist，Qt的一个工具，能够提取所有待翻译的string并按照友好的界面显示出来。这个用户界面非常适合翻译，使用字典，显示字符串内容，恰当的unicode显示，快捷方式冲突检测，检测未翻译的字符串，检测字符串修改情况，功能齐全。这个软件可以供没有任何编程经验的翻译者使用。同时该软件在GPL的版权下发布，可以按照你的需求来修改它。翻译以后的文档保存在XML中，适合软件复用的原则。为软件增加一种新的语言版本仅仅是用Qt Linguist产生一个新的文件而已。（这点Qt做的很不错。）
</p>

<p>resources问题
</p>

<p>使用MFC，一部分开发过程要依靠“resources”，在很多的案例中开发者必须使用他们。这样会导致如下的后果：出了Visual Studio，你很难使用其他的工具来完成开发。 资源编辑器仅有有限的功能，比如：通过Dialog编辑器不可能改变所有的属性，一些属性可以改变，另一些属性则不可能改变。(译者注：下面还有两条陈述MFC缺点的实例，但我感觉这些已经够说明问题了，暂时删节不译)
</p>

<p>然而Qt并没有资源的概念，这就解决了以上所提到的问题。Qt提供了一个脚本使得能将编入你的代码。对于界面设计，Qt Designer则创建了可读的代码。 (Qt Designer设计界面很不错)
</p>

<p>价格
</p>

<p>一旦你购买了Visual Studio，你将免费的获得MFC SDK。Qt在Unix上是可以免费获得其遵守GPL版权的版本(译者注:现在在windows 上也可以免费获得其GPL版本)。如果要开发不公开源代码的软件，必须购买Qt的授权。在特定平台下，每个开发者购买一个永久性授权，并获得一年的技术支持。(译者注：后面关于购买价格等问题删去，因为价格不固定，如果有疑问请到官方网站查询价格)
</p>

<p>发布
</p>

<p>在发布基于MFC的软件时，必须依靠存在于客户电脑上的MFC。但是这是不安全的，同样是MFC42.dll，可以基于相同的库得到3个不同的版本。通常，需要检查是否拥有正确的MFC42.dll版本，如果不是，就升级它。但是升级MFC42.dll会改变很多软件的行为。这让我感到很不舒服，如果用户在安装我的软件以后导致其机器死机该怎么办？
</p>

<p>Qt则没有这个风险，因为Qt压根就没有“升级整个系统”这个概念。（如果不是一个版本的Qt，还是会有问题的）
</p>

<p>速度
</p>

<p>MFC是专为Windows设计的，而Qt是跨平台的。所以MFC编写的程序的运行速度、响应时间都优于Qt。
</p>



<p style='float:right;'>本页共55段，6401个字符，15698 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
