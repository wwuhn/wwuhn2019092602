<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>MFC的API函数大全</h4>

<p>
</p>

<p>目录
</p>

<p>API函数大全... 1
</p>

<p>1.API之网络函数... 1
</p>

<p>2. API之消息函数... 1
</p>

<p>3. API之文件处理函数... 2
</p>

<p>4. API之打印函数... 5
</p>

<p>5. API之文本和字体函数... 7
</p>

<p>6. API之菜单函数... 8
</p>

<p>7. API之位图、图标和光栅运算函数... 9
</p>

<p>8. API之绘图函数... 11
</p>

<p>9. API之设备场景函数... 14
</p>

<p>10. API之硬件与系统函数... 16
</p>

<p>11. API之进程和线程函数... 18
</p>

<p>API函数大全
</p>

<p>1.API之网络函数
</p>

<p>WNetAddConnection 创建同一个网络资源的永久性连接
</p>

<p>WNetAddConnection2创建同一个网络资源的连接
</p>

<p>WNetAddConnection3创建同一个网络资源的连接
</p>

<p>WNetCancelConnection结束一个网络连接
</p>

<p>WNetCancelConnection2结束一个网络连接
</p>

<p>WNetCloseEnum 结束一次枚举操作
</p>

<p>WNetConnectionDialog启动一个标准对话框，以便建立同网络资源的连接
</p>

<p>WNetDisconnectDialog启动一个标准对话框，以便断开同网络资源的连接
</p>

<p>WNetEnumResource 枚举网络资源
</p>

<p>WNetGetConnection 获取本地或已连接的一个资源的网络名称
</p>

<p>WNetGetLastError 获取网络错误的扩展错误信息
</p>

<p>WNetGetUniversalName获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称
</p>

<p>WNetGetUser 获取一个网络资源用以连接的名字
</p>

<p>WNetOpenEnum 启动对网络资源进行枚举的过程
</p>

<p>2. API之消息函数
</p>

<p>BroadcastSystemMessage将一条系统消息广播给系统中所有的顶级窗口
</p>

<p>GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置
</p>

<p>GetMessageTime 取得消息队列中上一条消息处理完毕时的时间
</p>

<p>PostMessage 将一条消息投递到指定窗口的消息队列
</p>

<p>PostThreadMessage 将一条消息投递给应用程序
</p>

<p>RegisterWindowMessage获取分配给一个字串标识符的消息编号
</p>

<p>ReplyMessage 答复一个消息
</p>

<p>SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口
</p>

<p>SendMessageCallback将一条消息发给窗口
</p>

<p>SendMessageTimeout向窗口发送一条消息
</p>

<p>SendNotifyMessage 向窗口发送一条消息
</p>

<p>3. API之文件处理函数
</p>

<p>CloseHandle 关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等
</p>

<p>CompareFileTime 对比两个文件的时间
</p>

<p>CopyFile 复制文件
</p>

<p>CreateDirectory 创建一个新目录
</p>

<p>CreateFile 打开和创建文件、管道、邮槽、通信服务、设备以及控制台
</p>

<p>CreateFileMapping 创建一个新的文件映射对象
</p>

<p>DeleteFile 删除指定文件
</p>

<p>DeviceIoControl 对设备执行指定的操作
</p>

<p>DosDateTimeToFileTime将DOS日期和时间值转换成一个 win32 FILETIME 值
</p>

<p>FileTimeToDosDateTime将一个 win32 FILETIME 值转换成DOS日期和时间值
</p>

<p>FileTimeToLocalFileTime将一个FILETIME结构转换成本地时间
</p>

<p>FileTimeToSystemTime根据一个FILETIME结构的内容，装载一个SYSTEMTIME结构
</p>

<p>FindClose 关闭由FindFirstFile函数创建的一个搜索句柄
</p>

<p>FindFirstFile 根据文件名查找文件
</p>

<p>FindNextFile 根据调用FindFirstFile函数时指定的一个文件名查找下一个文件
</p>

<p>FlushFileBuffers 针对指定的文件句柄，刷新内部文件缓冲区
</p>

<p>FlushViewOfFile 将写入文件映射缓冲区的所有数据都刷新到磁盘
</p>

<p>GetBinaryType 判断文件是否可以执行
</p>

<p>GetCompressedFileSize判断一个压缩文件在磁盘上实际占据的字节数
</p>

<p>GetCurrentDirectory在一个缓冲区中装载当前目录
</p>

<p>GetDiskFreeSpace 获取与一个磁盘的组织有关的信息，以及了解剩余空间的容量
</p>

<p>GetDiskFreeSpaceEx获取与一个磁盘的组织以及剩余空间容量有关的信息
</p>

<p>GetDriveType 判断一个磁盘驱动器的类型
</p>

<p>GetExpandedName 取得一个压缩文件的全名
</p>

<p>GetFileAttributes 判断指定文件的属性
</p>

<p>GetFileInformationByHandle这个函数提供了获取文件信息的一种机制
</p>

<p>GetFileSize 判断文件长度
</p>

<p>GetFileTime 取得指定文件的时间信息
</p>

<p>GetFileType 在给出文件句柄的前提下，判断文件类型
</p>

<p>GetFileVersionInfo从支持版本标记的一个模块里获取文件版本信息
</p>

<p>GetFileVersionInfoSize针对包含了版本资源的一个文件，判断容纳文件版本信息需要一个多大的缓冲区
</p>

<p>GetFullPathName 获取指定文件的完整路径名
</p>

<p>GetLogicalDrives 判断系统中存在哪些逻辑驱动器字母
</p>

<p>GetLogicalDriveStrings获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径
</p>

<p>GetOverlappedResult判断一个重叠操作当前的状态
</p>

<p>GetPrivateProfileInt为初始化文件（.ini文件）中指定的条目获取一个整数值
</p>

<p>GetPrivateProfileSection获取指定小节（在.ini文件中）所有项名和值的一个列表
</p>

<p>GetPrivateProfileString为初始化文件中指定的条目取得字串
</p>

<p>GetProfileInt 取得win.ini初始化文件中指定条目的一个整数值
</p>

<p>GetProfileSection 获取指定小节（在win.ini文件中）所有项名和值的一个列表
</p>

<p>GetProfileString 为win.ini初始化文件中指定的条目取得字串
</p>

<p>GetShortPathName 获取指定文件的短路径名
</p>

<p>GetSystemDirectory取得Windows系统目录（即System目录）的完整路径名
</p>

<p>GetTempFileName 这个函数包含了一个临时文件的名字，它可由应用程序使用
</p>

<p>GetTempPath 获取为临时文件指定的路径
</p>

<p>GetVolumeInformation获取与一个磁盘卷有关的信息
</p>

<p>GetWindowsDirectory获取Windows目录的完整路径名
</p>

<p>hread 参考lread
</p>

<p>hwrite 参考lwrite函数
</p>

<p>lclose 关闭指定的文件
</p>

<p>lcreat 创建一个文件
</p>

<p>llseek 设置文件中进行读写的当前位置
</p>

<p>LockFile 锁定文件的某一部分，使其不与其他应用程序共享
</p>

<p>LockFileEx 与LockFile相似，只是它提供了更多的功能
</p>

<p>lopen 以二进制模式打开指定的文件
</p>

<p>lread 将文件中的数据读入内存缓冲区
</p>

<p>lwrite 将数据从内存缓冲区写入一个文件
</p>

<p>LZClose 关闭由LZOpenFile 或 LZInit函数打开的一个文件
</p>

<p>LZCopy 复制一个文件
</p>

<p>LZInit 这个函数用于初始化内部缓冲区
</p>

<p>LZOpenFile 该函数能执行大量不同的文件处理，而且兼容于压缩文件
</p>

<p>LZRead 将数据从文件读入内存缓冲区
</p>

<p>LZSeek 设置一个文件中进行读写的当前位置
</p>

<p>MapViewOfFile 将一个文件映射对象映射到当前应用程序的地址空间
</p>

<p>MoveFile 移动文件
</p>

<p>OpenFile 这个函数能执行大量不同的文件操作
</p>

<p>OpenFileMapping 打开一个现成的文件映射对象
</p>

<p>QueryDosDevice 在Windows NT中，DOS设备名会映射成NT系统设备名。该函数可判断当前的设备映射情况
</p>

<p>ReadFile 从文件中读出数据
</p>

<p>ReadFileEx 与ReadFile相似，只是它只能用于异步读操作，并包含了一个完整的回调
</p>

<p>RegCloseKey 关闭系统注册表中的一个项（或键）
</p>

<p>RegConnectRegistry访问远程系统的部分注册表
</p>

<p>RegCreateKey 在指定的项下创建或打开一个项
</p>

<p>RegCreateKeyEx 在指定项下创建新项的更复杂的方式。在Win32环境中建议使用这个函数
</p>

<p>RegDeleteKey 删除现有项下方一个指定的子项
</p>

<p>RegDeleteValue 删除指定项下方的一个值
</p>

<p>RegEnumKey 枚举指定项的子项。在Win32环境中应使用RegEnumKeyEx
</p>

<p>RegEnumKeyEx 枚举指定项下方的子项
</p>

<p>RegEnumValue 枚举指定项的值
</p>

<p>RegFlushKey 将对项和它的子项作出的改动实际写入磁盘
</p>

<p>RegGetKeySecurity 获取与一个注册表项有关的安全信息
</p>

<p>RegLoadKey 从以前用RegSaveKey函数创建的一个文件里装载注册表信息
</p>

<p>RegNotifyChangeKeyValue注册表项或它的任何一个子项发生变化时，用这个函数提供一种通知机制
</p>

<p>RegOpenKey 打开一个现有的注册表项
</p>

<p>RegOpenKeyEx 打开一个现有的项。在win32下推荐使用这个函数
</p>

<p>RegQueryInfoKey 获取与一个项有关的信息
</p>

<p>RegQueryValue 取得指定项或子项的默认（未命名）值
</p>

<p>RegQueryValueEx 获取一个项的设置值
</p>

<p>RegReplaceKey 用一个磁盘文件保存的信息替换注册表信息；并创建一个备份，在其中包含当前注册表信息
</p>

<p>RegRestoreKey 从一个磁盘文件恢复注册表信息
</p>

<p>RegSaveKey 将一个项以及它的所有子项都保存到一个磁盘文件
</p>

<p>RegSetKeySecurity 设置指定项的安全特性
</p>

<p>RegSetValue 设置指定项或子项的默认值
</p>

<p>RegSetValueEx 设置指定项的值
</p>

<p>RegUnLoadKey 卸载指定的项以及它的所有子项
</p>

<p>RemoveDirectory 删除指定目录
</p>

<p>SearchPath 查找指定文件
</p>

<p>SetCurrentDirectory设置当前目录
</p>

<p>SetEndOfFile 针对一个打开的文件，将当前文件位置设为文件末尾
</p>

<p>SetFileAttributes 设置文件属性
</p>

<p>SetFilePointer 在一个文件中设置当前的读写位置
</p>

<p>SetFileTime 设置文件的创建、访问及上次修改时间
</p>

<p>SetHandleCount 这个函数不必在win32下使用；即使使用，也不会有任何效果
</p>

<p>SetVolumeLabel 设置一个磁盘的卷标（Label）
</p>

<p>SystemTimeToFileTime根据一个FILETIME结构的内容，载入一个SYSTEMTIME结构
</p>

<p>UnlockFile 解除对一个文件的锁定
</p>

<p>UnlockFileEx 解除对一个文件的锁定
</p>

<p>UnmapViewOfFile 在当前应用程序的内存地址空间解除对一个文件映射对象的映射
</p>

<p>VerFindFile 用这个函数决定一个文件应安装到哪里
</p>

<p>VerInstallFile 用这个函数安装一个文件
</p>

<p>VerLanguageName 这个函数能根据16位语言代码获取一种语言的名称
</p>

<p>VerQueryValue 这个函数用于从版本资源中获取信息
</p>

<p>WriteFile 将数据写入一个文件
</p>

<p>WriteFileEx 与WriteFile类似，只是它只能用于异步写操作，并包括了一个完整的回调
</p>

<p>WritePrivateProfileSection为一个初始化文件（.ini）中指定的小节设置所有项名和值
</p>

<p>WritePrivateProfileString在初始化文件指定小节内设置一个字串
</p>

<p>WriteProfileSection为Win.ini初始化文件中一个指定的小节设置所有项名和值
</p>

<p>WriteProfileString在Win.ini初始化文件指定小节内设置一个字串
</p>

<p>4. API之打印函数
</p>

<p>AbortDoc 取消一份文档的打印
</p>

<p>AbortPrinter 删除与一台打印机关联在一起的缓冲文件
</p>

<p>AddForm 为打印机的表单列表添加一个新表单
</p>

<p>AddJob 用于获取一个有效的路径名，以便用它为作业创建一个后台打印文件。它也会为作业分配一个作业编号
</p>

<p>AddMonitor 为系统添加一个打印机监视器
</p>

<p>AddPort 启动“添加端口”对话框，允许用户在系统可用端口列表中加入一个新端口
</p>

<p>AddPrinter 在系统中添加一台新打印机
</p>

<p>AddPrinterConnection连接指定的打印机
</p>

<p>AddPrinterDriver 为指定的系统添加一个打印驱动程序
</p>

<p>AddPrintProcessor 为指定的系统添加一个打印处理器
</p>

<p>AddPrintProvidor 为系统添加一个打印供应商
</p>

<p>AdvancedDocumentProperties启动打印机文档设置对话框
</p>

<p>ClosePrinter 关闭一个打开的打印机对象
</p>

<p>ConfigurePort 针对指定的端口，启动一个端口配置对话框
</p>

<p>ConnectToPrinterDlg启动连接打印机对话框，用它同访问网络的打印机连接
</p>

<p>DeleteForm 从打印机可用表单列表中删除一个表单
</p>

<p>DeleteMonitor 删除指定的打印监视器
</p>

<p>DeletePort 启动“删除端口”对话框，允许用户从当前系统删除一个端口
</p>

<p>DeletePrinter 将指定的打印机标志为从系统中删除
</p>

<p>DeletePrinterConnection删除与指定打印机的连接
</p>

<p>DeletePrinterDriver从系统删除一个打印机驱动程序
</p>

<p>DeletePrintProcessor从指定系统删除一个打印处理器
</p>

<p>DeletePrintProvidor从系统中删除一个打印供应商
</p>

<p>DeviceCapabilities利用这个函数可获得与一个设备的能力有关的信息
</p>

<p>DocumentProperties打印机配置控制函数
</p>

<p>EndDocAPI 结束一个成功的打印作业
</p>

<p>EndDocPrinter 在后台打印程序的级别指定一个文档的结束
</p>

<p>EndPage 用这个函数完成一个页面的打印，并准备设备场景，以便打印下一个页
</p>

<p>EndPagePrinter 指定一个页在打印作业中的结尾
</p>

<p>EnumForms 枚举一台打印机可用的表单
</p>

<p>EnumJobs 枚举打印队列中的作业
</p>

<p>EnumMonitors 枚举可用的打印监视器
</p>

<p>EnumPorts 枚举一个系统可用的端口
</p>

<p>EnumPrinterDrivers枚举指定系统中已安装的打印机驱动程序
</p>

<p>EnumPrinters 枚举系统中安装的打印机
</p>

<p>EnumPrintProcessorDatatypes枚举由一个打印处理器支持的数据类型
</p>

<p>EnumPrintProcessors枚举系统中可用的打印处理器
</p>

<p>Escape 设备控制函数
</p>

<p>FindClosePrinterChangeNotification关闭用FindFirstPrinterChangeNotification函数获取的一个打印机通告对象
</p>

<p>FindFirstPrinterChangeNotification创建一个新的改变通告对象，以便我们注意打印机状态的各种变化
</p>

<p>FindNextPrinterChangeNotification用这个函数判断触发一次打印机改变通告信号的原因
</p>

<p>FreePrinterNotifyInfo释放由FindNextPrinterChangeNotification函数分配的一个缓冲区
</p>

<p>GetForm 取得与指定表单有关的信息
</p>

<p>GetJob 获取与指定作业有关的信息
</p>

<p>GetPrinter 取得与指定打印机有关的信息
</p>

<p>GetPrinterData 为打印机设置注册表配置信息
</p>

<p>GetPrinterDriver 针对指定的打印机，获取与打印机驱动程序有关的信息
</p>

<p>GetPrinterDriverDirectory判断指定系统中包含了打印机驱动程序的目录是什么
</p>

<p>GetPrintProcessorDirectory判断指定系统中包含了打印机处理器驱动程序及文件的目录
</p>

<p>OpenPrinter 打开指定的打印机，并获取打印机的句柄
</p>

<p>PrinterMessageBox 在拥有指定打印作业的系统上显示一个打印机出错消息框
</p>

<p>PrinterProperties 启动打印机属性对话框，以便对打印机进行配置
</p>

<p>ReadPrinter 从打印机读入数据
</p>

<p>ResetDC 重设一个设备场景
</p>

<p>ResetPrinter 改变指定打印机的默认数据类型及文档设置
</p>

<p>ScheduleJob 提交一个要打印的作业
</p>

<p>SetAbortProc 为Windows指定取消函数的地址
</p>

<p>SetForm 为指定的表单设置信息
</p>

<p>SetJob 对一个打印作业的状态进行控制
</p>

<p>SetPrinter 对一台打印机的状态进行控制
</p>

<p>SetPrinterData 设置打印机的注册表配置信息
</p>

<p>StartDoc 开始一个打印作业
</p>

<p>StartDocPrinter 在后台打印的级别启动一个新文档
</p>

<p>StartPage 打印一个新页前要先调用这个函数
</p>

<p>StartPagePrinter 在打印作业中指定一个新页的开始
</p>

<p>WritePrinter 将发送目录中的数据写入打印机
</p>

<p>5. API之文本和字体函数
</p>

<p>AddFontResource 在Windows系统中添加一种字体资源
</p>

<p>CreateFont 用指定的属性创建一种逻辑字体
</p>

<p>CreateFontIndirect用指定的属性创建一种逻辑字体
</p>

<p>CreateScalableFontResource为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统
</p>

<p>DrawText 将文本描绘到指定的矩形中
</p>

<p>DrawTextEx 与DrawText相似，只是加入了更多的功能
</p>

<p>EnumFontFamilies 列举指定设备可用的字体
</p>

<p>EnumFontFamiliesEx列举指定设备可用的字体
</p>

<p>EnumFonts 列举指定设备可用的字体
</p>

<p>ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数
</p>

<p>GetAspectRatioFilterEx用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小
</p>

<p>GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小
</p>

<p>GetCharABCWidthsFloat查询一种字体中一个或多个字符的A-B-C尺寸
</p>

<p>GetCharacterPlacement该函数用于了解如何用一个给定的字符显示一个字串
</p>

<p>GetCharWidth 调查字体中一个或多个字符的宽度
</p>

<p>GetFontData 接收一种可缩放字体文件的数据
</p>

<p>GetFontLanguageInfo返回目前选入指定设备场景中的字体的信息
</p>

<p>GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息
</p>

<p>GetKerningPairs 取得指定字体的字距信息
</p>

<p>GetOutlineTextMetrics接收与TureType字体内部特征有关的详细信息
</p>

<p>GetRasterizerCaps 了解系统是否有能力支持可缩放的字体
</p>

<p>GetTabbedTextExtent判断一个字串占据的范围，同时考虑制表站扩充的因素
</p>

<p>GetTextAlign 接收一个设备场景当前的文本对齐标志
</p>

<p>GetTextCharacterExtra判断额外字符间距的当前值
</p>

<p>GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符
</p>

<p>GetTextCharsetInfo获取与当前选定字体的字符集有关的详细信息
</p>

<p>GetTextColor 判断当前字体颜色。通常也称为“前景色”
</p>

<p>GetTextExtentExPoint判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息
</p>

<p>GetTextExtentPoint判断一个字串的大小（范围）
</p>

<p>GetTextFace 获取一种字体的字样名
</p>

<p>GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息
</p>

<p>GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态
</p>

<p>PolyTextOut 描绘一系列字串
</p>

<p>RemoveFontResource从Windows系统中删除一种字体资源
</p>

<p>SetMapperFlagsWindows对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体
</p>

<p>SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置
</p>

<p>SetTextCharacterExtra描绘文本的时候，指定要在字符间插入的额外间距
</p>

<p>SetTextColor 设置当前文本颜色。这种颜色也称为“前景色”
</p>

<p>SetTextJustification通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理
</p>

<p>TabbedTextOut 支持制表站的一个文本描绘函数
</p>

<p>TextOut 文本绘图函数
</p>

<p>6. API之菜单函数
</p>

<p>AppendMenu 在指定的菜单里添加一个菜单项
</p>

<p>CheckMenuItem 复选或撤消复选指定的菜单条目
</p>

<p>CheckMenuRadioItem指定一个菜单条目被复选成“单选”项目
</p>

<p>CreateMenu 创建新菜单
</p>

<p>CreatePopupMenu 创建一个空的弹出式菜单
</p>

<p>DeleteMenu 删除指定的菜单条目
</p>

<p>DestroyMenu 删除指定的菜单
</p>

<p>DrawMenuBar 为指定的窗口重画菜单
</p>

<p>EnableMenuItem 允许或禁止指定的菜单条目
</p>

<p>GetMenu 取得窗口中一个菜单的句柄
</p>

<p>GetMenuCheckMarkDimensions返回一个菜单复选符的大小
</p>

<p>GetMenuContextHelpId取得一个菜单的帮助场景ID
</p>

<p>GetMenuDefaultItem判断菜单中的哪个条目是默认条目
</p>

<p>GetMenuItemCount 返回菜单中条目（菜单项）的数量
</p>

<p>GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID
</p>

<p>GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息
</p>

<p>GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息
</p>

<p>GetMenuState 取得与指定菜单条目状态有关的信息
</p>

<p>GetMenuString 取得指定菜单条目的字串
</p>

<p>GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置
</p>

<p>GetSystemMenu 取得指定窗口的系统菜单的句柄
</p>

<p>HiliteMenuItem 控制顶级菜单条目的加亮显示状态
</p>

<p>InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动
</p>

<p>InsertMenuItem 插入一个新菜单条目
</p>

<p>IsMenu 判断指定的句柄是否为一个菜单的句柄
</p>

<p>LoadMenu 从指定的模块或应用程序实例中载入一个菜单
</p>

<p>LoadMenuIndirect 载入一个菜单
</p>

<p>MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点
</p>

<p>ModifyMenu 改变菜单条目
</p>

<p>RemoveMenu 删除指定的菜单条目
</p>

<p>SetMenu 设置窗口菜单
</p>

<p>SetMenuContextHelpId设置一个菜单的帮助场景ID
</p>

<p>SetMenuDefaultItem将一个菜单条目设为默认条目
</p>

<p>SetMenuItemBitmaps设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√）
</p>

<p>SetMenuItemInfo 为一个菜单条目设置指定的信息
</p>

<p>TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单
</p>

<p>TrackPopupMenuEx 与TrackPopupMenu相似，只是它提供了额外的功能
</p>

<p>7. API之位图、图标和光栅运算函数
</p>

<p>BitBlt 将一幅位图从一个设备场景复制到另一个
</p>

<p>CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序
</p>

<p>CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作
</p>

<p>CreateBitmap 按照规定的格式创建一幅与设备有关位图
</p>

<p>CreateBitmapIndirect创建一幅与设备有关位图
</p>

<p>CreateCompatibleBitmap创建一幅与设备有关位图，它与指定的设备场景兼容
</p>

<p>CreateCursor 创建一个鼠标指针
</p>

<p>CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图
</p>

<p>CreateDIBSection 创建一个DIBSection
</p>

<p>CreateIcon 创建一个图标
</p>

<p>CreateIconIndirect创建一个图标
</p>

<p>DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源
</p>

<p>DestroyIcon 清除图标
</p>

<p>DrawIcon 在指定的位置画一个图标
</p>

<p>DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能
</p>

<p>ExtractAssociatedIcon判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之
</p>

<p>ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来
</p>

<p>GetBitmapBits 将来自位图的二进制位复制到一个缓冲区
</p>

<p>GetBitmapDimensionEx取得一幅位图的宽度和高度
</p>

<p>GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息
</p>

<p>GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里
</p>

<p>GetIconInfo 取得与图标有关的信息
</p>

<p>GetStretchBltMode 判断StretchBlt 和 StretchDIBits函数采用的伸缩模式
</p>

<p>LoadBitmap 从指定的模块或应用程序实例中载入一幅位图
</p>

<p>LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针
</p>

<p>LoadCursorFromFile在一个指针文件或一个动画指针文件的基础上创建一个指针
</p>

<p>LoadIcon 从指定的模块或应用程序实例中载入一个图标
</p>

<p>LoadImage 载入一个位图、图标或指针
</p>

<p>MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理
</p>

<p>PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景
</p>

<p>PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理
</p>

<p>SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图
</p>

<p>SetBitmapDimensionEx设置一幅位图的宽度。以一毫米的十分之一为单位
</p>

<p>SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息
</p>

<p>SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里
</p>

<p>SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备
</p>

<p>SetStretchBltMode 指定StretchBlt 和 StretchDIBits函数的伸缩模式
</p>

<p>StretchBlt 将一幅位图从一个设备场景复制到另一个
</p>

<p>StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景
</p>

<p>8. API之绘图函数
</p>

<p>AbortPath 抛弃选入指定设备场景中的所有路径。也取消目前正在进行的任何路径的创建工作
</p>

<p>AngleArc 用一个连接弧画一条线
</p>

<p>Arc 画一个圆弧
</p>

<p>BeginPath 启动一个路径分支
</p>

<p>CancelDC 取消另一个线程里的长时间绘图操作
</p>

<p>Chord 画一个弦
</p>

<p>CloseEnhMetaFile 关闭指定的增强型图元文件设备场景，并将新建的图元文件返回一个句柄
</p>

<p>CloseFigure 描绘到一个路径时，关闭当前打开的图形
</p>

<p>CloseMetaFile 关闭指定的图元文件设备场景，并向新建的图元文件返回一个句柄
</p>

<p>CopyEnhMetaFile 制作指定增强型图元文件的一个副本（拷贝）
</p>

<p>CopyMetaFile 制作指定（标准）图元文件的一个副本
</p>

<p>CreateBrushIndirect在一个LOGBRUSH数据结构的基础上创建一个刷子
</p>

<p>CreateDIBPatternBrush用一幅与设备无关的位图创建一个刷子，以便指定刷子样式（图案）
</p>

<p>CreateEnhMetaFile 创建一个增强型的图元文件设备场景
</p>

<p>CreateHatchBrush 创建带有阴影图案的一个刷子
</p>

<p>CreateMetaFile 创建一个图元文件设备场景
</p>

<p>CreatePatternBrush用指定了刷子图案的一幅位图创建一个刷子
</p>

<p>CreatePen 用指定的样式、宽度和颜色创建一个画笔
</p>

<p>CreatePenIndirect 根据指定的LOGPEN结构创建一个画笔
</p>

<p>CreateSolidBrush 用纯色创建一个刷子
</p>

<p>DeleteEnhMetaFile 删除指定的增强型图元文件
</p>

<p>DeleteMetaFile 删除指定的图元文件
</p>

<p>DeleteObject 删除GDI对象，对象使用的所有系统资源都会被释放
</p>

<p>DrawEdge 用指定的样式描绘一个矩形的边框
</p>

<p>DrawEscape 换码（Escape）函数将数据直接发至显示设备驱动程序
</p>

<p>DrawFocusRect 画一个焦点矩形
</p>

<p>DrawFrameControl 描绘一个标准控件
</p>

<p>DrawState 为一幅图象或绘图操作应用各式各样的效果
</p>

<p>Ellipse 描绘一个椭圆，由指定的矩形围绕
</p>

<p>EndPath 停止定义一个路径
</p>

<p>EnumEnhMetaFile 针对一个增强型图元文件，列举其中单独的图元文件记录
</p>

<p>EnumMetaFile 为一个标准的windows图元文件枚举单独的图元文件记录
</p>

<p>EnumObjects 枚举可随同指定设备场景使用的画笔和刷子
</p>

<p>ExtCreatePen 创建一个扩展画笔（装饰或几何）
</p>

<p>ExtFloodFill 在指定的设备场景里，用当前选择的刷子填充一个区域
</p>

<p>FillPath 关闭路径中任何打开的图形，并用当前刷子填充
</p>

<p>FillRect 用指定的刷子填充一个矩形
</p>

<p>FlattenPath 将一个路径中的所有曲线都转换成线段
</p>

<p>FloodFill 用当前选定的刷子在指定的设备场景中填充一个区域
</p>

<p>FrameRect 用指定的刷子围绕一个矩形画一个边框
</p>

<p>GdiComment 为指定的增强型图元文件设备场景添加一条注释信息
</p>

<p>GdiFlush 执行任何未决的绘图操作
</p>

<p>GdiGetBatchLimit 判断有多少个GDI绘图命令位于队列中
</p>

<p>GdiSetBatchLimit 指定有多少个GDI绘图命令能够进入队列
</p>

<p>GetArcDirection 画圆弧的时候，判断当前采用的绘图方向
</p>

<p>GetBkColor 取得指定设备场景当前的背景颜色
</p>

<p>GetBkMode 针对指定的设备场景，取得当前的背景填充模式
</p>

<p>GetBrushOrgEx 判断指定设备场景中当前选定刷子起点
</p>

<p>GetCurrentObject 获得指定类型的当前选定对象
</p>

<p>GetCurrentPositionEx在指定的设备场景中取得当前的画笔位置
</p>

<p>GetEnhMetaFile 取得磁盘文件中包含的一个增强型图元文件的图元文件句柄
</p>

<p>GetEnhMetaFileBits将指定的增强型图元文件复制到一个内存缓冲区里
</p>

<p>GetEnhMetaFileDescription返回对一个增强型图元文件的说明
</p>

<p>GetEnhMetaFileHeader取得增强型图元文件的图元文件头
</p>

<p>GetEnhMetaFilePaletteEntries取得增强型图元文件的全部或部分调色板
</p>

<p>GetMetaFile 取得包含在一个磁盘文件中的图元文件的图元文件句柄
</p>

<p>GetMetaFileBitsEx 将指定的图元文件复制到一个内存缓冲区
</p>

<p>GetMiterLimit 取得设备场景的斜率限制（Miter）设置
</p>

<p>GetNearestColor 根据设备的显示能力，取得与指定颜色最接近的一种纯色
</p>

<p>GetObjectAPI 取得对指定对象进行说明的一个结构
</p>

<p>GetObjectType 判断由指定句柄引用的GDI对象的类型
</p>

<p>GetPath 取得对当前路径进行定义的一系列数据
</p>

<p>GetPixel 在指定的设备场景中取得一个像素的RGB值
</p>

<p>GetPolyFillMode 针对指定的设备场景，获得多边形填充模式
</p>

<p>GetROP2 针对指定的设备场景，取得当前的绘图模式
</p>

<p>GetStockObject 取得一个固有对象（Stock）
</p>

<p>GetSysColorBrush 为任何一种标准系统颜色取得一个刷子
</p>

<p>GetWinMetaFileBits通过在一个缓冲区中填充用于标准图元文件的数据，将一个增强型图元文件转换成标准windows图元文件
</p>

<p>InvertRect 通过反转每个像素的值，从而反转一个设备场景中指定的矩形
</p>

<p>LineDDA 枚举指定线段中的所有点
</p>

<p>LineTo 用当前画笔画一条线，从当前位置连到一个指定的点
</p>

<p>MoveToEx 为指定的设备场景指定一个新的当前画笔位置
</p>

<p>PaintDesk 在指定的设备场景中描绘桌面墙纸图案
</p>

<p>PathToRegion 将当前选定的路径转换到一个区域里
</p>

<p>Pie 画一个饼图
</p>

<p>PlayEnhMetaFile 在指定的设备场景中画一个增强型图元文件
</p>

<p>PlayEnhMetaFileRecord回放单独一条增强型图元文件记录
</p>

<p>PlayMetaFile 在指定的设备场景中回放一个图元文件
</p>

<p>PlayMetaFileRecord回放来自图元文件的单条记录
</p>

<p>PolyBezier 描绘一条或多条贝塞尔（Bezier）曲线
</p>

<p>PolyDraw 描绘一条复杂的曲线，由线段及贝塞尔曲线组成
</p>

<p>Polygon 描绘一个多边形
</p>

<p>Polyline 用当前画笔描绘一系列线段
</p>

<p>PolyPolygon 用当前选定画笔描绘两个或多个多边形
</p>

<p>PolyPolyline 用当前选定画笔描绘两个或多个多边形
</p>

<p>Rectangle 用当前选定的画笔描绘矩形，并用当前选定的刷子填充
</p>

<p>RoundRect 用当前选定的画笔画一个圆角矩形，并用当前选定的刷子在其中填充
</p>

<p>SelectClipPath 将设备场景当前的路径合并到剪切区域里
</p>

<p>SelectObject 为当前设备场景选择图形对象
</p>

<p>SetArcDirection 设置圆弧的描绘方向
</p>

<p>SetBkColor 为指定的设备场景设置背景颜色
</p>

<p>SetBkMode 指定阴影刷子、虚线画笔以及字符中的空隙的填充方式
</p>

<p>SetBrushOrgEx 为指定的设备场景设置当前选定刷子的起点
</p>

<p>SetEnhMetaFileBits用指定内存缓冲区内包含的数据创建一个增强型图元文件
</p>

<p>SetMetaFileBitsEx 用包含在指定内存缓冲区内的数据结构创建一个图元文件
</p>

<p>SetMiterLimit 设置设备场景当前的斜率限制
</p>

<p>SetPixel 在指定的设备场景中设置一个像素的RGB值
</p>

<p>SetPixelV 在指定的设备场景中设置一个像素的RGB值
</p>

<p>SetPolyFillMode 设置多边形的填充模式
</p>

<p>SetROP2 设置指定设备场景的绘图模式。与vb的DrawMode属性完全一致
</p>

<p>SetWinMetaFileBits将一个标准Windows图元文件转换成增强型图元文件
</p>

<p>StrokeAndFillPath 针对指定的设备场景，关闭路径上打开的所有区域
</p>

<p>StrokePath 用当前画笔描绘一个路径的轮廓。打开的图形不会被这个函数关闭
</p>

<p>UnrealizeObject 将一个刷子对象选入设备场景之前，如刷子的起点准备用
</p>

<p>SetBrushOrgEx修改，则必须先调用本函数
</p>

<p>WidenPath 根据选定画笔的宽度，重新定义当前选定的路径
</p>

<p>9. API之设备场景函数
</p>

<p>CombineRgn 将两个区域组合为一个新区域
</p>

<p>CombineTransform 驱动世界转换。它相当于依顺序进行两次转换
</p>

<p>CreateCompatibleDC创建一个与特定设备场景一致的内存设备场景
</p>

<p>CreateDC 为专门设备创建设备场景
</p>

<p>CreateEllipticRgn 创建一个椭圆
</p>

<p>CreateEllipticRgnIndirect创建一个内切于特定矩形的椭圆区域
</p>

<p>CreateIC 为专用设备创建一个信息场景
</p>

<p>CreatePolygonRgn 创建一个由一系列点围成的区域
</p>

<p>CreatePolyPolygonRgn创建由多个多边形构成的区域。每个多边形都应是封闭的
</p>

<p>CreateRectRgn 创建一个矩形区域
</p>

<p>CreateRectRgnIndirect创建一个矩形区域
</p>

<p>CreateRoundRectRgn创建一个圆角矩形
</p>

<p>DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源
</p>

<p>DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标
</p>

<p>EqualRgn 确定两个区域是否相等
</p>

<p>ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图
</p>

<p>ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域
</p>

<p>ExtCreateRegion 根据世界转换修改区域
</p>

<p>ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区
</p>

<p>FillRgn 用指定刷子填充指定区域
</p>

<p>FrameRgn 用指定刷子围绕指定区域画一个外框
</p>

<p>GetBoundsRect 获取指定设备场景的边界矩形
</p>

<p>GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形
</p>

<p>GetClipRgn 获取设备场景当前剪裁区
</p>

<p>GetDC 获取指定窗口的设备场景
</p>

<p>GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项
</p>

<p>GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示）
</p>

<p>GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息
</p>

<p>GetGraphicsMode 确定是否允许增强图形模式（世界转换）
</p>

<p>GetMapMode 为特定设备场景调入映象模式
</p>

<p>GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区
</p>

<p>GetRgnBox 获取完全包含指定区域的最小矩形
</p>

<p>GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新
</p>

<p>GetViewportExtEx 获取设备场景视口（viewport）范围
</p>

<p>GetViewportOrgEx 获取设备场景视口起点
</p>

<p>GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景
</p>

<p>GetWindowExtEx 获取指定设备场景的窗口范围
</p>

<p>GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点
</p>

<p>GetWindowRgn 获取窗口区域
</p>

<p>GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换
</p>

<p>IntersectClipRect 为指定设备定义一个新的剪裁区
</p>

<p>InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画
</p>

<p>InvertRgn 通过颠倒每个像素值反转设备场景指定区域
</p>

<p>LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标
</p>

<p>ModifyWorldTransform根据指定的模式修改世界转换
</p>

<p>OffsetClipRgn 按指定量平移设备场景剪裁区
</p>

<p>OffsetRgn 按指定偏移量平移指定区域
</p>

<p>OffsetViewportOrgEx平移设备场景视口区域
</p>

<p>OffsetWindowOrgEx 平移指定设备场景窗口起点
</p>

<p>PaintRgn 用当前刷子背景色填充指定区域
</p>

<p>PtInRegion 确定点是否在指定区域内
</p>

<p>PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内）
</p>

<p>RectInRegion 确定矩形是否有部分在指定区域内
</p>

<p>RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内）
</p>

<p>ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景
</p>

<p>RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景
</p>

<p>SaveDC 将指定设备场景状态保存到Windows设备场景堆栈
</p>

<p>ScaleViewportExtEx缩放设备场景视口的范围
</p>

<p>ScaleWindowExtEx 缩放指定设备场景窗口范围
</p>

<p>ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形
</p>

<p>SelectClipRgn 为指定设备场景选择新的剪裁区
</p>

<p>SetBoundsRect 设置指定设备场景的边界矩形
</p>

<p>SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换）
</p>

<p>SetMapMode 设置指定设备场景的映射模式
</p>

<p>SetRectRgn 设置区域为指定的矩形
</p>

<p>SetViewportExtEx 设置设备场景视口范围
</p>

<p>SetViewportOrgEx 设置设备场景视口起点
</p>

<p>SetWindowExtEx 设置指定设备场景窗口范围
</p>

<p>SetWindowOrgEx 设置指定设备场景窗口起点
</p>

<p>SetWindowRgn 设置窗口区域
</p>

<p>SetWorldTransform 设置世界转换
</p>

<p>ValidateRgn 激活窗口中指定区域，把它从刷新区移走
</p>

<p>WindowFromDC 取回与某一设备场景相关的窗口的句柄
</p>

<p>10. API之硬件与系统函数
</p>

<p>ActivateKeyboardLayout激活一个新的键盘布局。键盘布局定义了按键在一种物理性键盘上的位置与含义
</p>

<p>Beep 用于生成简单的声音
</p>

<p>CharToOem 将一个字串从ANSI字符集转换到OEM字符集
</p>

<p>ClipCursor 将指针限制到指定区域
</p>

<p>ConvertDefaultLocale将一个特殊的地方标识符转换成真实的地方ID
</p>

<p>CreateCaret 根据指定的信息创建一个插入符（光标），并将它选定为指定窗口的默认插入符
</p>

<p>DestroyCaret 清除（破坏）一个插入符
</p>

<p>EnumCalendarInfo 枚举在指定“地方”环境中可用的日历信息
</p>

<p>EnumDateFormats 列举指定的“当地”设置中可用的长、短日期格式
</p>

<p>EnumSystemCodePages枚举系统中已安装或支持的代码页
</p>

<p>EnumSystemLocales 枚举系统已经安装或提供支持的“地方”设置
</p>

<p>EnumTimeFormats 枚举一个指定的地方适用的时间格式
</p>

<p>ExitWindowsEx 退出windows，并用特定的选项重新启动
</p>

<p>ExpandEnvironmentStrings扩充环境字串
</p>

<p>FreeEnvironmentStrings翻译指定的环境字串块
</p>

<p>GetACP 判断目前正在生效的ANSI代码页
</p>

<p>GetAsyncKeyState 判断函数调用时指定虚拟键的状态
</p>

<p>GetCaretBlinkTime 判断插入符光标的闪烁频率
</p>

<p>GetCaretPos 判断插入符的当前位置
</p>

<p>GetClipCursor 取得一个矩形，用于描述目前为鼠标指针规定的剪切区域
</p>

<p>GetCommandLine 获得指向当前命令行缓冲区的一个指针
</p>

<p>GetComputerName 取得这台计算机的名称
</p>

<p>GetCPInfo 取得与指定代码页有关的信息
</p>

<p>GetCurrencyFormat 针对指定的“地方”设置，根据货币格式格式化一个数字
</p>

<p>GetCursor 获取目前选择的鼠标指针的句柄
</p>

<p>GetCursorPos 获取鼠标指针的当前位置
</p>

<p>GetDateFormat 针对指定的“当地”格式，对一个系统日期进行格式化
</p>

<p>GetDoubleClickTime判断连续两次鼠标单击之间会被处理成双击事件的间隔时间
</p>

<p>GetEnvironmentStrings为包含了当前环境字串设置的一个内存块分配和返回一个句柄
</p>

<p>GetEnvironmentVariable取得一个环境变量的值
</p>

<p>GetInputState 判断是否存在任何待决（等待处理）的鼠标或键盘事件
</p>

<p>GetKBCodePage 由GetOEMCP取代，两者功能完全相同
</p>

<p>GetKeyboardLayout 取得一个句柄，描述指定应用程序的键盘布局
</p>

<p>GetKeyboardLayoutList获得系统适用的所有键盘布局的一个列表
</p>

<p>GetKeyboardLayoutName取得当前活动键盘布局的名称
</p>

<p>GetKeyboardState 取得键盘上每个虚拟键当前的状态
</p>

<p>GetKeyboardType 了解与正在使用的键盘有关的信息
</p>

<p>GetKeyNameText 在给出扫描码的前提下，判断键名
</p>

<p>GetKeyState 针对已处理过的按键，在最近一次输入信息时，判断指定虚拟键的状态
</p>

<p>GetLastError 针对之前调用的api函数，用这个函数取得扩展错误信息
</p>

<p>GetLocaleInfo 取得与指定“地方”有关的信息
</p>

<p>GetLocalTime 取得本地日期和时间
</p>

<p>GetNumberFormat 针对指定的“地方”，按特定的格式格式化一个数字
</p>

<p>GetOEMCP 判断在OEM和ANSI字符集间转换的windows代码页
</p>

<p>GetQueueStatus 判断应用程序消息队列中待决（等待处理）的消息类型
</p>

<p>GetSysColor 判断指定windows显示对象的颜色
</p>

<p>GetSystemDefaultLangID取得系统的默认语言ID
</p>

<p>GetSystemDefaultLCID取得当前的默认系统“地方”
</p>

<p>GetSystemInfo 取得与底层硬件平台有关的信息
</p>

<p>GetSystemMetrics 返回与windows环境有关的信息
</p>

<p>GetSystemPowerStatus获得与当前系统电源状态有关的信息
</p>

<p>GetSystemTime 取得当前系统时间，这个时间采用的是“协同世界时间”（即UTC，也叫做GMT）格式
</p>

<p>GetSystemTimeAdjustment使内部系统时钟与一个外部的时钟信号源同步
</p>

<p>GetThreadLocale 取得当前线程的地方ID
</p>

<p>GetTickCount 用于获取自windows启动以来经历的时间长度（毫秒）
</p>

<p>GetTimeFormat 针对当前指定的“地方”，按特定的格式格式化一个系统时间
</p>

<p>GetTimeZoneInformation取得与系统时区设置有关的信息
</p>

<p>GetUserDefaultLangID为当前用户取得默认语言ID
</p>

<p>GetUserDefaultLCID取得当前用户的默认“地方”设置
</p>

<p>GetUserName 取得当前用户的名字
</p>

<p>GetVersion 判断当前运行的Windows和DOS版本
</p>

<p>GetVersionEx 取得与平台和操作系统有关的版本信息
</p>

<p>HideCaret 在指定的窗口隐藏插入符（光标）
</p>

<p>IsValidCodePage 判断一个代码页是否有效
</p>

<p>IsValidLocale 判断地方标识符是否有效
</p>

<p>keybd_event 这个函数模拟了键盘行动
</p>

<p>LoadKeyboardLayout载入一个键盘布局
</p>

<p>MapVirtualKey 根据指定的映射类型，执行不同的扫描码和字符转换
</p>

<p>MapVirtualKeyEx 根据指定的映射类型，执行不同的扫描码和字符转换
</p>

<p>MessageBeep 播放一个系统声音。系统声音的分配方案是在控制面板里决定的
</p>

<p>mouse_event 模拟一次鼠标事件
</p>

<p>OemKeyScan 判断OEM字符集中的一个ASCII字符的扫描码和Shift键状态
</p>

<p>OemToChar 将OEM字符集的一个字串转换到ANSI字符集
</p>

<p>SetCaretBlinkTime 指定插入符（光标）的闪烁频率
</p>

<p>SetCaretPos 指定插入符的位置
</p>

<p>SetComputerName 设置新的计算机名
</p>

<p>SetCursor 将指定的鼠标指针设为当前指针
</p>

<p>SetCursorPos 设置指针的位置
</p>

<p>SetDoubleClickTime设置连续两次鼠标单击之间能使系统认为是双击事件的间隔时间
</p>

<p>SetEnvironmentVariable将一个环境变量设为指定的值
</p>

<p>SetKeyboardState 设置每个虚拟键当前在键盘上的状态
</p>

<p>SetLocaleInfo 改变用户“地方”设置信息
</p>

<p>SetLocalTime 设置当前地方时间
</p>

<p>SetSysColors 设置指定窗口显示对象的颜色
</p>

<p>SetSystemCursor 改变任何一个标准系统指针
</p>

<p>SetSystemTime 设置当前系统时间
</p>

<p>SetSystemTimeAdjustment定时添加一个校准值使内部系统时钟与一个外部的时钟信号源同步
</p>

<p>SetThreadLocale 为当前线程设置地方
</p>

<p>SetTimeZoneInformation设置系统时区信息
</p>

<p>ShowCaret 在指定的窗口里显示插入符（光标）
</p>

<p>ShowCursor 控制鼠标指针的可视性
</p>

<p>SwapMouseButton 决定是否互换鼠标左右键的功能
</p>

<p>SystemParametersInfo获取和设置数量众多的windows系统参数
</p>

<p>SystemTimeToTzSpecificLocalTime将系统时间转换成地方时间
</p>

<p>ToAscii 根据当前的扫描码和键盘信息，将一个虚拟键转换成ASCII字符
</p>

<p>ToUnicode 根据当前的扫描码和键盘信息，将一个虚拟键转换成Unicode字符
</p>

<p>UnloadKeyboardLayout卸载指定的键盘布局
</p>

<p>VkKeyScan 针对Windows字符集中一个ASCII字符，判断虚拟键码和Shift键的状态
</p>

<p>11. API之进程和线程函数
</p>

<p>CancelWaitableTimer这个函数用于取消一个可以等待下去的计时器操作
</p>

<p>CallNamedPipe 这个函数由一个希望通过管道通信的一个客户进程调用
</p>

<p>ConnectNamedPipe 指示一台服务器等待下去，直至客户机同一个命名管道连接
</p>

<p>CreateEvent 创建一个事件对象
</p>

<p>CreateMailslot 创建一个邮路。返回的句柄由邮路服务器使用（收件人）
</p>

<p>CreateMutex 创建一个互斥体（MUTEX）
</p>

<p>CreateNamedPipe 创建一个命名管道。返回的句柄由管道的服务器端使用
</p>

<p>CreatePipe 创建一个匿名管道
</p>

<p>CreateProcess 创建一个新进程（比如执行一个程序）
</p>

<p>CreateSemaphore 创建一个新的信号机
</p>

<p>CreateWaitableTimer创建一个可等待的计时器对象
</p>

<p>DisconnectNamedPipe断开一个客户与一个命名管道的连接
</p>

<p>DuplicateHandle 在指出一个现有系统对象当前句柄的情况下，为那个对象创建一个新句柄
</p>

<p>ExitProcess 中止一个进程
</p>

<p>FindCloseChangeNotification关闭一个改动通知对象
</p>

<p>FindExecutable 查找与一个指定文件关联在一起的程序的文件名
</p>

<p>FindFirstChangeNotification创建一个文件通知对象。该对象用于监视文件系统发生的变化
</p>

<p>FindNextChangeNotification重设一个文件改变通知对象，令其继续监视下一次变化
</p>

<p>FreeLibrary 释放指定的动态链接库
</p>

<p>GetCurrentProcess 获取当前进程的一个伪句柄
</p>

<p>GetCurrentProcessId获取当前进程一个唯一的标识符
</p>

<p>GetCurrentThread 获取当前线程的一个伪句柄
</p>

<p>GetCurrentThreadId获取当前线程一个唯一的线程标识符
</p>

<p>GetExitCodeProces 获取一个已中断进程的退出代码
</p>

<p>GetExitCodeThread 获取一个已中止线程的退出代码
</p>

<p>GetHandleInformation获取与一个系统对象句柄有关的信息
</p>

<p>GetMailslotInfo 获取与一个邮路有关的信息
</p>

<p>GetModuleFileName 获取一个已装载模板的完整路径名称
</p>

<p>GetModuleHandle 获取一个应用程序或动态链接库的模块句柄
</p>

<p>GetPriorityClass 获取特定进程的优先级别
</p>

<p>GetProcessShutdownParameters调查系统关闭时一个指定的进程相对于其它进程的关闭早迟情况
</p>

<p>GetProcessTimes 获取与一个进程的经过时间有关的信息
</p>

<p>GetProcessWorkingSetSize了解一个应用程序在运行过程中实际向它交付了多大容量的内存
</p>

<p>GetSartupInfo 获取一个进程的启动信息
</p>

<p>GetThreadPriority 获取特定线程的优先级别
</p>

<p>GetTheardTimes 获取与一个线程的经过时间有关的信息
</p>

<p>GetWindowThreadProcessId获取与指定窗口关联在一起的一个进程和线程标识符
</p>

<p>LoadLibrary 载入指定的动态链接库，并将它映射到当前进程使用的地址空间
</p>

<p>LoadLibraryEx 装载指定的动态链接库，并为当前进程把它映射到地址空间
</p>

<p>LoadModule 载入一个Windows应用程序，并在指定的环境中运行
</p>

<p>MsgWaitForMultipleObjects等侯单个对象或一系列对象发出信号。如返回条件已经满足，则立即返回
</p>

<p>SetPriorityClass 设置一个进程的优先级别
</p>

<p>SetProcessShutdownParameters在系统关闭期间，为指定进程设置他相对于其它程序的关闭顺序
</p>

<p>SetProcessWorkingSetSize设置操作系统实际划分给进程使用的内存容量
</p>

<p>SetThreadPriority 设定线程的优先级别
</p>

<p>ShellExecute 查找与指定文件关联在一起的程序的文件名
</p>

<p>TerminateProcess 结束一个进程
</p>

<p>WinExec 运行指定的程序
</p>



<p style='float:right;'>本页共678段，22248个字符，44626 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
