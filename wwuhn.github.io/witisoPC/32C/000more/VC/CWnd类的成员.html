<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>CWnd类的成员</h4>

<p>初始化
</p>

<p>对话框项函数
</p>

<p>初始化消息处理函数
</p>

<p>窗口状态函数
</p>

<p>数据绑定函数
</p>

<p>系统消息处理函数
</p>

<p>窗口大小和位置
</p>

<p>菜单函数
</p>

<p>一般消息处理函数
</p>

<p>窗口访问函数
</p>

<p>工具提示函数
</p>

<p>控件消息处理函数
</p>

<p>更新/绘图函数
</p>

<p>定时器函数
</p>

<p>输入消息处理函数
</p>

<p>坐标映射函数
</p>

<p>警告函数
</p>

<p>非客户区消息处理函数
</p>

<p>窗口文本函数
</p>

<p>窗口消息函数
</p>

<p>MDI消息处理函数
</p>

<p>滚动函数
</p>

<p>剪贴板函数
</p>

<p>剪贴板消息处理函数
</p>

<p>拖放函数
</p>

<p>OLE控件
</p>

<p>菜单循环通知
</p>

<p>插字符号函数
</p>

<p>可重载函数
</p>

<p>下面提供CWnd的函数,以供参考和查阅。
</p>

<p>1.数据成员
</p>

<p>m_hWnd
</p>

<p>指明与这个CWnd对象相关联的HWND句柄
</p>

<p>2.构造和析构
</p>

<p>CWnd
</p>

<p>构造一个CWnd对象
</p>

<p>DestroyWindow
</p>

<p>销毁相关联的Windows窗口
</p>

<p>3.初始化
</p>

<p>Create
</p>

<p>创建并初始化与CWnd对象相关联的子窗口
</p>

<p>PreCreateWindow
</p>

<p>在与CWnd对象相关联的窗口被创建之前调用
</p>

<p>CalcWindowRect
</p>

<p>调用这个函数以计算窗口客户区的矩形
</p>

<p>GetStyle
</p>

<p>返回当前的窗口风格
</p>

<p>GetExStyle
</p>

<p>返回窗口的扩展风格
</p>

<p>Attach
</p>

<p>将Windows句柄与CWnd对象相连接
</p>

<p>Detach
</p>

<p>将一个Windows句柄从CWnd对象上分离并返回这个句柄
</p>

<p>PreSubclassWindow
</p>

<p>在调用SubclassWindow之前，允许其它必要的子类化工作
</p>

<p>SubclassWindow
</p>

<p>将窗口与CWnd对象相连接，并使它通过CWnd的消息映射转发消息
</p>

<p>UnsubclassWindow
</p>

<p>将窗口与CWnd对象分离
</p>

<p>FromHandle
</p>

<p>当给定一个窗口的句柄时，返回CWnd对象的指针。如果没有CWnd对象与这个句柄相连接，则创建一个临时的CWnd对象并与之相连接
</p>

<p>FromHandlePermanent
</p>

<p>当给定一个窗口的句柄时，返回CWnd对象的指针。如果没有CWnd 对象与这个句柄相连接，则返回NULL
</p>

<p>DeleteTempMap
</p>

<p>CWinApp的空闲处理函数自动调用这个函数，清除由FromHandle创建的任何临时CWnd对象
</p>

<p>GetSafeHwnd
</p>

<p>返回m_hWnd，如果该指针为NULL，则返回NULL
</p>

<p>CreateEx
</p>

<p>创建一个Windows的可重叠窗口、弹出窗口或子窗口，并把它连接到一个CWnd对象上
</p>

<p>CreateControl
</p>

<p>创建一个OLE控件，该控件在MFC程序中由一个CWnd对象代表
</p>

<p>4.窗口状态函数
</p>

<p>IsWindowEnabled
</p>

<p>确定一个窗口是否允许鼠标和键盘输入
</p>

<p>EnableWindow
</p>

<p>允许或禁止鼠标和键盘输入
</p>

<p>GetActiveWindow
</p>

<p>获得激活的窗口
</p>

<p>SetActiveWindow
</p>

<p>激活窗口
</p>

<p>GetCapture
</p>

<p>获得捕获鼠标的CWnd
</p>

<p>SetCapture
</p>

<p>使随后的鼠标输入都被发送到这个CWnd
</p>

<p>GetFocus
</p>

<p>获得当前具有输入焦点的CWnd
</p>

<p>SetFocus
</p>

<p>要求输入焦点
</p>

<p>GetDesktopWindow
</p>

<p>获得Windows的桌面窗口
</p>

<p>GetForegroundWindow
</p>

<p>返回前台窗口的指针（顶层窗口，用户正在其中工作）
</p>

<p>SetForegroundWindow
</p>

<p>使创建窗口的线程变为前台并激活窗口
</p>

<p>GetIcon
</p>

<p>获得图标的句柄
</p>

<p>SetIcon
</p>

<p>设置指定图标的句柄
</p>

<p>GetWindowContextHelpId
</p>

<p>获得帮助上下文的标识符
</p>

<p>SetWindowContextHelpId
</p>

<p>设置帮助上下文的标识符
</p>

<p>ModifyStyle
</p>

<p>修改当前的窗口风格
</p>

<p>ModifyStyleEx
</p>

<p>修改窗口的扩展风格
</p>

<p>5.窗口大小和位置
</p>

<p>GetWindowPlacement
</p>

<p>获得窗口的显示状态以及正常（还原）的、最大化和最小化的位置
</p>

<p>SetWindowPlacement
</p>

<p>设置窗口的显示状态以及正常（还原）的、最大化和最小化的位置
</p>

<p>GetWindowRgn
</p>

<p>获得窗口的窗口区域的一个拷贝
</p>

<p>SetWindowRgn
</p>

<p>设置窗口的区域
</p>

<p>IsIconic
</p>

<p>确定CWnd是否被最小化（图标化）
</p>

<p>IsZoomed
</p>

<p>确定CWnd是否被最大化
</p>

<p>MoveWindow
</p>

<p>改变CWnd的位置和大小
</p>

<p>SetWindowPos
</p>

<p>改变子窗口、弹出窗口和顶层窗口的大小、位置以及顺序
</p>

<p>ArrangeIconicWindows
</p>

<p>排列所有最小化（图标化）的子窗口
</p>

<p>BringWindowToTop
</p>

<p>使CWnd到达重叠窗口堆栈的顶部
</p>

<p>GetWindowRect
</p>

<p>获得CWnd的屏幕坐标
</p>

<p>GetClientRect
</p>

<p>获得CWnd客户区域的大小
</p>

<p>6.窗口访问函数
</p>

<p>ChildWindowFromPoint
</p>

<p>确定哪个子窗口包含指定的点，如果有的话
</p>

<p>FindWindow
</p>

<p>返回由窗口名或窗口类标识的窗口的句柄
</p>

<p>GetNextWindow
</p>

<p>返回窗口管理器列表中的下一个（或前一个）窗口
</p>

<p>GetOwner
</p>

<p>获得CWnd的拥有者的指针
</p>

<p>SetOwner
</p>

<p>改变CWnd的拥有者
</p>

<p>GetTopWindow
</p>

<p>返回CWnd所属的第一个子窗口
</p>

<p>GetWindow
</p>

<p>返回与窗口有特定关系的窗口
</p>

<p>GetLastActivePopup
</p>

<p>确定CWnd拥有的弹出窗口是否最近被激活
</p>

<p>IsChild
</p>

<p>指明CWnd是指定窗口的一个子窗口还是其它子对象
</p>

<p>GetParent
</p>

<p>获得CWnd的父窗口（如果有）
</p>

<p>GetSafeOwner
</p>

<p>获得给定窗口的安全拥有者
</p>

<p>SetParent
</p>

<p>改变父窗口
</p>

<p>WindowFromPoint
</p>

<p>标明包含给定点的窗口
</p>

<p>GetDlgItem
</p>

<p>获得指定的对话框中具有指定ID的控件
</p>

<p>GetDlgCtrlID
</p>

<p>如果CWnd是一个子窗口，则用这个函数来返回它的ID值
</p>

<p>SetDlgCtrlID
</p>

<p>为窗口（可以是任意子窗口，不仅是对话框中的控件）设置窗口ID或控件ID
</p>

<p>GetDescendantWindow
</p>

<p>搜索所有子窗口并返回具有指定ID的窗口
</p>

<p>GetParentFrame
</p>

<p>获得CWnd对象的父框架窗口
</p>

<p>SendMessageToDescendants
</p>

<p>将消息发送给窗口的所有子窗口
</p>

<p>GetTopLevelParent
</p>

<p>获得窗口的顶层父窗口
</p>

<p>GetTopLevelOwner
</p>

<p>获得顶层窗口
</p>

<p>GetParentOwner
</p>

<p>返回子窗口的父窗口的指针
</p>

<p>GetTopLevelFrame
</p>

<p>获得窗口的顶层框架窗口
</p>

<p>UpdateDialogControls
</p>

<p>调用这个函数以更新对话框按钮和其它控件的状态
</p>

<p>UpdateData
</p>

<p>初始化对话框或获得对话框中的数据
</p>

<p>CenterWindow
</p>

<p>将窗口设置到父窗口的中央
</p>

<p>7.更新/绘图函数
</p>

<p>BeginPaint
</p>

<p>为绘图准备CWnd
</p>

<p>EndPaint
</p>

<p>标志着绘图结束
</p>

<p>Print
</p>

<p>在指定的设备环境中画出当前窗口
</p>

<p>PrintClient
</p>

<p>在指定的设备环境（通常是打印机设备环境）中画出任何窗口
</p>

<p>LockWindowUpdate
</p>

<p>禁止或恢复在给定窗口中的绘图
</p>

<p>UnlockWindowUpdate
</p>

<p>解锁用CWnd::LockWindowUpdate锁定的窗口
</p>

<p>GetDC
</p>

<p>获得客户区的设备环境
</p>

<p>GetDCEx
</p>

<p>获得客户区的显示设备环境，允许在绘图的时候进行剪裁
</p>

<p>RedrawWindow
</p>

<p>更新客户区中的指定矩形或区域
</p>

<p>GetWindowDC
</p>

<p>获得整个窗口的显示环境，包括标题条、菜单和滚动条
</p>

<p>ReleaseDC
</p>

<p>是否客户和窗口设备环境，使其它应用程序能够使用它们
</p>

<p>UpdateWindow
</p>

<p>更新客户区
</p>

<p>SetRedraw
</p>

<p>使CWnd的变化能够被重画，或者禁止重画发生的变化
</p>

<p>GetUpdateRect
</p>

<p>获得完全封闭了CWnd中更新区域的最小矩形的坐标
</p>

<p>GetUpdateRgn
</p>

<p>获得CWnd的更新区域
</p>

<p>Invalidate
</p>

<p>使整个客户区无效
</p>

<p>InvalidateRect
</p>

<p>在当前的更新区域中加入给定的矩形，使客户区的给定矩形无效
</p>

<p>InvalidateRgn
</p>

<p>在当前的更新区域中加入给定的区域，使客户区的给定区域无效
</p>

<p>ValidateRect
</p>

<p>在当前的更新区域中删除给定的矩形，使客户区的给定矩形有效
</p>

<p>ValidateRgn
</p>

<p>在当前的更新区域中删除给定的区域，使客户区的给定区域有效
</p>

<p>ShowWindow
</p>

<p>显示或隐藏窗口
</p>

<p>IsWindowVisible
</p>

<p>确定窗口是否可见
</p>

<p>ShowOwnedPopups
</p>

<p>显示或隐藏该窗口拥有的所有弹出窗口
</p>

<p>EnableScrollBar
</p>

<p>允许或禁止滚动条的一个或两个箭头
</p>

<p>8.坐标映射函数
</p>

<p>MapWindowPoints
</p>

<p>将一些坐标从CWnd的坐标空间转换（映射）到其它窗口的坐标空间
</p>

<p>ClientToScreen
</p>

<p>将给定点或显示器上矩形的客户区坐标转换为屏幕坐标
</p>

<p>ScreenToClient
</p>

<p>将给定点或显示器上矩形的屏幕坐标转换为客户坐标
</p>

<p>9.窗口文本函数
</p>

<p>SetWindowText
</p>

<p>将窗口的文本或标题文字（如果有）设为指定的文本
</p>

<p>GetWindowText
</p>

<p>返回窗口的文本或标题文字（如果有）
</p>

<p>GetWindowTextLength
</p>

<p>返回窗口文本或标题文字的长度
</p>

<p>SetFont
</p>

<p>设置当前字体
</p>

<p>GetFont
</p>

<p>获得当前字体
</p>

<p>10.滚动函数
</p>

<p>GetScrollPos
</p>

<p>获得滚动块的当前位置
</p>

<p>GetScrollRange
</p>

<p>复制指定滚动条的最大和最小滚动条位置
</p>

<p>ScrollWindow
</p>

<p>滚动客户区的内容
</p>

<p>ScrollWindowEx
</p>

<p>滚动客户区的内容，与ScrollWindow类似，还有其它功能
</p>

<p>GetScrollInfo
</p>

<p>获得SCROLLINFO结构维护的滚动条信息
</p>

<p>GetScrollLimit
</p>

<p>获得滚动条的限制
</p>

<p>SetScrollInfo
</p>

<p>设置滚动条信息
</p>

<p>SetScrollPos
</p>

<p>设置滚动块的当前位置，如果指定，并重画滚动条以反映新的位置
</p>

<p>SetScrollRange
</p>

<p>设置指定滚动条的最小和最大位置值
</p>

<p>ShowScrollBar
</p>

<p>显示或隐藏滚动条
</p>

<p>EnableScrollBarCtrl
</p>

<p>允许或禁止一个滚动条控件
</p>

<p>GetScrollBarCtrl
</p>

<p>返回滚动条控件
</p>

<p>RepositionBars
</p>

<p>重新设定客户区中控制条的位置
</p>

<p>11.拖放函数
</p>

<p>DragAcceptFiles
</p>

<p>指明该窗口将接收拖来的文件
</p>

<p>12.插字符号函数
</p>

<p>CreateCaret
</p>

<p>为系统插字符创建一个新的形状并获得它的所有权
</p>

<p>CreateSolidCaret
</p>

<p>为系统插字符创建一个实心块并获得它的所有权
</p>

<p>CreateGrayCaret
</p>

<p>为系统插字符创建一个灰色块并获得它的所有权
</p>

<p>GetCaretPos
</p>

<p>获得插字符当前位置的客户区坐标
</p>

<p>SetCaretPos
</p>

<p>将插字符移动到指定的位置
</p>

<p>HideCaret
</p>

<p>通过将插字符移出显示屏幕而隐藏它
</p>

<p>ShowCaret
</p>

<p>在插字符的当前位置显示插字符。一旦被显示，插字符就会自动闪烁
</p>

<p>13.对话框项函数
</p>

<p>CheckDlgButton
</p>

<p>在按钮控件旁放置或者清除检查标记
</p>

<p>CheckRadioButton
</p>

<p>选中指定的单项按钮并清除指定的按钮组中其它所有单项按钮的检查标记
</p>

<p>GetCheckedRadioButton
</p>

<p>返回一组按钮中当前选中的单项按钮的ID
</p>

<p>DlgDirList
</p>

<p>用文件或目录列表填充一个列表框
</p>

<p>DlgDirListComboBox
</p>

<p>用文件或目录列表填充一个组合框中的列表框
</p>

<p>DlgDirSelect
</p>

<p>获得列表框的当前选择
</p>

<p>DlgDirSelectComboBox
</p>

<p>获得组合框中列表框的当前选择
</p>

<p>GetDlgItemInt
</p>

<p>将给定对话框中控件的文本转换为整数
</p>

<p>GetDlgItemText
</p>

<p>获得与控件相关的标题或文本
</p>

<p>GetNextDlgGroupItem
</p>

<p>在一组控件内搜索下一个（或上一个）控件
</p>

<p>GetNextDlgTabItem
</p>

<p>获得指定的控件之后（或之前）具有WS_TABSTOP风格的第一个控件
</p>

<p>IsDlgButtonChecked
</p>

<p>确定按钮控件是否有检查标记
</p>

<p>IsDialogMessage
</p>

<p>确定给定的消息是否是送往无模式对话框的，如果是，则处理它
</p>

<p>SendDlgItemMessage
</p>

<p>向指定的控件发送一条消息
</p>

<p>SetDlgItemInt
</p>

<p>将控件的文本设为代表一个整数的字符串
</p>

<p>SetDlgItemText
</p>

<p>设置指定的对话框中的控件的标题或文本
</p>

<p>SubclassDlgItem
</p>

<p>将一个Windows控件与CWnd对象连接，然后使它通过CWnd的消息映射转发消息
</p>

<p>ExecuteDlgInit
</p>

<p>初始化对话框资源
</p>

<p>RunModalLoop
</p>

<p>获得、转换或分派来自模式窗口的消息
</p>

<p>ContinueModal
</p>

<p>继续一个窗口的模式状态
</p>

<p>EndModalLoop
</p>

<p>结束一个窗口的模式状态
</p>

<p>14.数据绑定函数
</p>

<p>BindDefaultProperty
</p>

<p>像类型库中标记的那样，将调用对象的缺省的简单移动属性和与数据源控件相关的游标绑定在一起
</p>

<p>BindProperty
</p>

<p>将一个游标移动属性与数据移动控件绑定在一起，然后在MFC的绑定管理器中注册这种联系
</p>

<p>GetDSCCursor
</p>

<p>获得游标的指针，该游标是通过数据源控件的DataSource、UserName、Password和SQL属性定义的
</p>

<p>15.菜单函数
</p>

<p>GetMenu
</p>

<p>获得指定菜单的指针
</p>

<p>SetMenu
</p>

<p>将菜单设为指定的菜单
</p>

<p>DrawMenuBar
</p>

<p>重画菜单条
</p>

<p>GetSystemMenu
</p>

<p>允许应用程序访问控制菜单，用于拷贝和修改
</p>

<p>HiliteMenuItem
</p>

<p>加亮显示一个顶层（菜单条）菜单项，或者取消加亮显示
</p>

<p>16.工具提示函数
</p>

<p>EnableToolTips
</p>

<p>允许工具提示控件
</p>

<p>CancelToolTips
</p>

<p>禁止工具提示控件
</p>

<p>FilterToolTipMessage
</p>

<p>获得与对话框中控件相关的标题和文本
</p>

<p>OnToolHitTest
</p>

<p>确定一个点是否位于指定工具的边界矩形之中并获得工具的信息
</p>

<p>17.定时器函数
</p>

<p>SetTimer
</p>

<p>安装一个系统定时器，当它被激活时，发送一个WM_TIMER消息
</p>

<p>KillTimer
</p>

<p>销毁一个系统定时器
</p>

<p>18.警告函数
</p>

<p>FlashWindow
</p>

<p>使窗口闪烁一次
</p>

<p>MessageBox
</p>

<p>创建并显示一个窗口，其中包含了应用程序提供的消息和标题
</p>

<p>19.窗口消息函数
</p>

<p>GetCurrentMessage
</p>

<p>返回这个窗口当前处理的消息的指针。只应该在OnMessage消息处理函数内部调用
</p>

<p>Default
</p>

<p>调用缺省的窗口过程，它提供了对应用程序没有处理的任何窗口消息的缺省处理
</p>

<p>PreTranslateMessage
</p>

<p>在消息被发送到Windows函数TranslateMessage和DispatchMessage之前，CWinApp使用这个函数来过滤窗口消息
</p>

<p>SendMessage
</p>

<p>向CWnd对象发送一个消息，直到这条消息被处理之后才返回
</p>

<p>PostMessage
</p>

<p>将一条消息放入应用程序的消息队列，然后不等窗口处理这条消息直接返回
</p>

<p>SendNotifyMessage
</p>

<p>将一条消息发送到窗口并尽快返回，返回的速度取决于该窗口是否是由调用线程所创建
</p>

<p>20.剪贴板函数
</p>

<p>ChangeClipboardChain
</p>

<p>将CWnd从剪贴板观察器的链中清除
</p>

<p>SetClipboardViewer
</p>

<p>将CWnd加入一个窗口链，每当剪贴板的内容发生变化时，就会通知这些窗口
</p>

<p>OpenClipboard
</p>

<p>打开剪贴板。其它应用程序将不能修改剪贴板，直到调用Windows的CloseClipboard函数
</p>

<p>GetClipboardOwner
</p>

<p>获得指向剪贴板的当前拥有者的指针
</p>

<p>GetOpenClipboardWindow
</p>

<p>获得当前打开剪贴板的窗口的指针
</p>

<p>GetClipboardViewer
</p>

<p>获得剪贴板观察器链中的第一个窗口的指针
</p>

<p>21.OLE控件
</p>

<p>SetProperty
</p>

<p>设置OLE控件的属性
</p>

<p>OnAmbientProperty
</p>

<p>实现周围属性值
</p>

<p>GetControlUnknown
</p>

<p>获得指向未知OLE控件的指针
</p>

<p>GetProperty
</p>

<p>获得OLE控件的属性
</p>

<p>InvokeHelper
</p>

<p>激活OLE控件的方法或属性
</p>

<p>22.可重载函数
</p>

<p>WindowProc
</p>

<p>为CWnd对象提供了窗口过程。缺省的窗口过程通过消息映射分派消息
</p>

<p>DefWindowProc
</p>

<p>调用缺省的窗口过程，它提供了对应用程序没有处理的任何窗口消息的缺省处理
</p>

<p>PostNcDestroy
</p>

<p>这个虚拟函数在窗口被销毁以后被缺省的OnNcDestroy函数所调用
</p>

<p>OnNotify
</p>

<p>框架调用这个函数以通知父窗口，在它的一个控件发生了一个事件，或该控件需要消息
</p>

<p>OnChildNotify
</p>

<p>父窗口调用这个函数，给被通知的控件一个响应控件通知消息的机会
</p>

<p>DoDataExchange
</p>

<p>用于对话框数据交换和校验。由UpdateData调用
</p>

<p>23.初始化消息处理函数
</p>

<p>OnInitMenu
</p>

<p>当菜单要被激活时调用这个函数
</p>

<p>OnInitMenuPopup
</p>

<p>当弹出菜单要被激活时调用这个函数
</p>

<p>24.系统消息处理函数
</p>

<p>OnSysChar
</p>

<p>当一次击键被转换为系统字符消息时调用这个函数
</p>

<p>OnSysCommand
</p>

<p>当用户从控制菜单中选择命令，或者当用户选择了最大化或最小化按钮时，调用这个函数
</p>

<p>OnSysDeadChar
</p>

<p>当一次击键被转换为系统死键（例如重音字符）消息时调用这个函数
</p>

<p>OnSysKeyDown
</p>

<p>当用户按住ALT键并按下其它键时调用这个函数
</p>

<p>OnSysKeyUp
</p>

<p>当用户放开一个键，而此时ALT键被按下，则调用这个函数
</p>

<p>OnCompacting
</p>

<p>当Windows检测到系统内存很少时，就调用这个函数
</p>

<p>OnDevModeChange
</p>

<p>当用户改变了设备模式设置时，就为顶层窗口调用这个函数
</p>

<p>OnFontChange
</p>

<p>当字体资源池发生变化时调用这个函数
</p>

<p>OnPaletteIsChanging
</p>

<p>当应用程序将要实现其逻辑调色板时通知其它应用程序
</p>

<p>OnPaletteChanged
</p>

<p>调用这个函数时使用调色板的所有窗口能够实现它们的逻辑调色板并更新它们的客户区
</p>

<p>OnSysColorChange
</p>

<p>当系统颜色设置发生改变时为所有的顶层窗口调用这个函数
</p>

<p>OnWindowPosChanging
</p>

<p>由于调用了SetWindowPos函数或其它的窗口管理函数，因而窗口的大小、位置和次序将要发生变化时，就调用这个函数
</p>

<p>OnWindowPosChanged
</p>

<p>由于调用了SetWindowPos函数或其它的窗口管理函数，因而当窗口的大小、位置和次序发生了变化时，就调用这个函数
</p>

<p>OnDropFiles
</p>

<p>当用户在注册为可以接收拖放文件的窗口上方释放鼠标左键时，这个函数就被调用
</p>

<p>OnSpoolerStatus
</p>

<p>每当一个作业被加入或移出打印管理器的队列时，打印管理器就调用这个函数
</p>

<p>OnTimeChange
</p>

<p>在系统时间改变之后，为所有的顶层窗口调用这个函数
</p>

<p>OnWinIniChange
</p>

<p>在Windows的初始化文件WIN.INI改变之后为所有的顶层窗口调用这个函数
</p>

<p>25.一般消息处理函数
</p>

<p>OnCommand
</p>

<p>当用户选择了一个命令时调用这个函数
</p>

<p>OnActivate
</p>

<p>当CWnd要被激活或退出激活状态时调用这个函数
</p>

<p>OnActivateApp
</p>

<p>当应用程序要被激活或退出激活状态时调用这个函数
</p>

<p>26.一般消息处理函数
</p>

<p>OnCancelMode
</p>

<p>调用这个函数以允许CWnd取消任何内部模式，比如鼠标捕获状态
</p>

<p>OnChildActivate
</p>

<p>当CWnd的大小和位置发生变化或者CWnd被激活时，就为多文档界面（MDI）的子窗口调用这个函数
</p>

<p>OnClose
</p>

<p>调用这个函数，作为关闭CWnd的信号
</p>

<p>OnCopyData
</p>

<p>从一个应用程序复制数据到另一个应用程序
</p>

<p>OnCreate
</p>

<p>作为窗口创建过程的一部分来调用
</p>

<p>OnCtlColor
</p>

<p>如果CWnd是一个控件的父窗口，当控件要被重画时就调用这个函数
</p>

<p>OnDestroy
</p>

<p>当CWnd要被销毁时就调用这个函数
</p>

<p>OnEnable
</p>

<p>当CWnd被允许或禁止时调用这个函数
</p>

<p>OnEndSession
</p>

<p>当会话将要结束时调用这个函数
</p>

<p>OnEnterIdle
</p>

<p>调用这个函数以通知应用程序的主窗口过程，模式对话框或菜单正在进入空闲状态
</p>

<p>OnEraseBkgnd
</p>

<p>当需要擦除窗口的背景时调用这个函数
</p>

<p>OnGetMinMaxInfo
</p>

<p>每当Windows需要知道最大化的位置和大小，或者最小或最大跟踪尺寸时，就调用这个函数
</p>

<p>OnIconEraseBkgnd
</p>

<p>当CWnd被最小化（图标化），并且在画出图标之前，必须填充图标的背景时调用这个函数
</p>

<p>OnKillFocus
</p>

<p>当CWnd失去输入焦点时立即调用这个函数
</p>

<p>OnMenuChar
</p>

<p>当用户按下一个菜单助记字符，但是不能与当前菜单中任何预定义的助记符相匹配时，就调用这个函数
</p>

<p>OnMenuSelect
</p>

<p>当用户选择了一个菜单项时就调用这个函数
</p>

<p>OnMove
</p>

<p>当CWnd的位置发生变化时调用这个函数
</p>

<p>OnMoving
</p>

<p>指明用户正在移动CWnd对象
</p>

<p>OnDeviceChange
</p>

<p>通知应用程序或设备驱动程序，设备或计算机的硬件配置发生了变化
</p>

<p>OnStyleChanged
</p>

<p>指明Windows的::SetWindowLong函数已经改变了一个或多个窗口风格
</p>

<p>OnStyleChanging
</p>

<p>指明Windows的::SetWindowLong函数将要改变一个或多个窗口风格
</p>

<p>OnPaint
</p>

<p>调用这个函数以重画窗口的一部分
</p>

<p>OnParentNotify
</p>

<p>当创建或销毁一个子窗口，或者当用户在子窗口上方点击了鼠标键时调用这个函数
</p>

<p>OnQueryDragIcon
</p>

<p>当一个最小化（图标化）的CWnd要被用户拖拉时就调用这个函数
</p>

<p>OnQueryEndSession
</p>

<p>当用户选择结束Windows会话时就调用这个函数
</p>

<p>OnQueryNewPalette
</p>

<p>通知CWnd它将接收输入焦点
</p>

<p>OnQueryOpen
</p>

<p>当CWnd是一个图标并且用户请求打开这个图标时就调用这个函数
</p>

<p>27.一般消息处理函数
</p>

<p>OnSetFocus
</p>

<p>当CWnd获得输入焦点时调用这个函数
</p>

<p>OnShowWindow
</p>

<p>当CWnd被隐藏或显示时调用这个函数
</p>

<p>OnSize
</p>

<p>当CWnd的大小被改变以后调用这个函数
</p>

<p>OnSizing
</p>

<p>指明用户正在改变矩形的大小
</p>

<p>OnStyleChanged
</p>

<p>指明窗口的一个或多个风格已经被改变
</p>

<p>OnStyleChanging
</p>

<p>指明窗口的一个或多个风格将被改变
</p>

<p>28.控件消息处理函数
</p>

<p>OnCharToItem
</p>

<p>这个函数被具有LBS_WANTKEYBOARDINPUT风格的子列表框调用，用以响应WM_CHAR消息
</p>

<p>OnCompareItem
</p>

<p>调用这个函数以确定排序的自画组合框或列表框中新项的相对位置
</p>

<p>OnDeleteItem
</p>

<p>当一个自画子列表框或组合框中将被销毁时，或者从控件中删除项时调用这个函数
</p>

<p>OnDrawItem
</p>

<p>当自画子按钮控件、组合框控件、列表框控件或菜单的可视部分需要被画出时调用这个函数
</p>

<p>OnDSCNotify
</p>

<p>在响应数据源控件引发的事件时调用，该事件是当与数据源控件绑定的控件修改或将要修改游标时产生的
</p>

<p>OnGetDlgCode
</p>

<p>为控件调用这个函数，使控件能够自己处理输入的箭头键和TAB键
</p>

<p>OnMeasureItem
</p>

<p>当控件被创建时为自画子组合框，列表框或菜单项调用这个函数。CWnd通知Windows该控件的大小
</p>

<p>SendChildNotifyLastMsg
</p>

<p>提供了从父窗口到子窗口的通知消息，使子窗口能够处理一个任务
</p>

<p>ReflectChildNotify
</p>

<p>将消息向它的来源反映的帮助函数
</p>

<p>OnWndMsg
</p>

<p>指明一个窗口消息是否已被处理
</p>

<p>ReflectLastMsg
</p>

<p>将上一个消息反映到子窗口
</p>

<p>OnVKeyToItem
</p>

<p>由CWnd所拥有的列表框调用，用于响应WM_KEYDOWN消息
</p>

<p>29.输入消息处理函数
</p>

<p>OnChar
</p>

<p>当一次击键被转换为非系统字符时调用这个函数
</p>

<p>OnDeadChar
</p>

<p>当一次击键被转换为非系统死键（例如重音字符）时调用这个函数
</p>

<p>OnHScroll
</p>

<p>当用户点击了CWnd的水平滚动条时调用这个函数
</p>

<p>OnKeyDown
</p>

<p>当按下了一个非系统键时调用这个函数
</p>

<p>OnKeyUp
</p>

<p>当放开一个非系统键时调用这个函数
</p>

<p>OnLButtonDblClk
</p>

<p>当用户双击鼠标左键时调用这个函数
</p>

<p>30.输入消息处理函数
</p>

<p>OnLButtonDown
</p>

<p>当用户按下鼠标左键时调用这个函数
</p>

<p>OnLButtonUp
</p>

<p>当用户放开鼠标左键时调用这个函数
</p>

<p>OnMButtonDblClk
</p>

<p>当用户双击鼠标中键时调用这个函数
</p>

<p>OnMButtonDown
</p>

<p>当用户按下鼠标中键时调用这个函数
</p>

<p>OnMButtonUp
</p>

<p>当用户放开鼠标中键时调用这个函数
</p>

<p>OnMouseActivate
</p>

<p>当鼠标位于非活动窗口，并且用户按下鼠标键时调用这个函数
</p>

<p>OnMouseMove
</p>

<p>当鼠标光标移动时调用这个函数
</p>

<p>OnMouseWheel
</p>

<p>当用户旋转鼠标轮时调用这个函数。使用WindowsNT4.0的消息处理
</p>

<p>OnRegisteredMouseWheel
</p>

<p>当用户旋转鼠标轮的时候调用这个函数。使用Windows 95和Windows NT 3.51的消息处理
</p>

<p>OnRButtonDblClk
</p>

<p>当用户双击鼠标右键时调用这个函数
</p>

<p>OnRButtonDown
</p>

<p>当用户按下鼠标右键时调用这个函数
</p>

<p>OnRButtonUp
</p>

<p>当用户放开鼠标右键时调用这个函数
</p>

<p>OnSetCursor
</p>

<p>如果没有捕获鼠标输入并且鼠标导致光标在窗口内移动时，就调用这个函数
</p>

<p>OnTimer
</p>

<p>当达到SetTimer指定的时间间隔时调用这个函数
</p>

<p>OnVScroll
</p>

<p>当用户点击窗口的垂直滚动条时调用这个函数
</p>

<p>OnCaptureChanged
</p>

<p>向失去鼠标捕获的窗口发送一条消息
</p>

<p>31.非客户区消息处理函数
</p>

<p>OnNcActivate
</p>

<p>当需要改变非客户区以指明活动或非活动状态时调用这个函数
</p>

<p>OnNcCalcSize
</p>

<p>当需要计算非客户区的大小和位置时调用这个函数
</p>

<p>OnNcCreate
</p>

<p>在OnCreate之前，当要创建非客户区时调用这个函数
</p>

<p>OnNcDestroy
</p>

<p>当非客户区要被销毁的时候调用这个函数
</p>

<p>OnNcHitTest
</p>

<p>如果CWnd中包含了光标，或者用SetCapture捕获了鼠标输入时，每当鼠标移动时，Windows调用这个函数
</p>

<p>OnNcLButtonDblClk
</p>

<p>当光标位于CWnd的非客户区，用户双击鼠标左键时，就调用这个函数
</p>

<p>OnNcLButtonDown
</p>

<p>当光标位于CWnd的非客户区，用户按下鼠标左键时，就调用这个函数
</p>

<p>OnNcLButtonUp
</p>

<p>当光标位于CWnd的非客户区，用户放开鼠标左键时，就调用这个函数
</p>

<p>OnNcMButtonDblClk
</p>

<p>当光标位于CWnd的非客户区，用户双击鼠标中键时，就调用这个函数
</p>

<p>OnNcMButtonDown
</p>

<p>当光标位于CWnd的非客户区，用户按下鼠标中键时，就调用这个函数
</p>

<p>OnNcMButtonUp
</p>

<p>当光标位于CWnd的非客户区，用户放开鼠标中键时，就调用这个函数
</p>

<p>32.非客户区消息处理函数
</p>

<p>OnNcMouseMove
</p>

<p>当光标在CWnd的非客户区中移动时就调用这个函数
</p>

<p>OnNcPaint
</p>

<p>当非客户区需要重画时调用这个函数
</p>

<p>OnNcRButtonDblClk
</p>

<p>当光标位于CWnd的非客户区，用户双击鼠标右键时，就调用这个函数
</p>

<p>OnNcRButtonDown
</p>

<p>当光标位于CWnd的非客户区，用户按下鼠标右键时，就调用这个函数
</p>

<p>OnNcRButtonUp
</p>

<p>当光标位于CWnd的非客户区，用户放开鼠标右键时，就调用这个函数
</p>

<p>33.MDI消息处理函数
</p>

<p>OnMDIActivate
</p>

<p>当MDI子窗口被激活或失去活动状态时调用这个函数
</p>

<p>34.剪贴板消息处理函数
</p>

<p>OnAskCbFormatName
</p>

<p>当剪贴板的拥有者将显示剪贴板内容时，剪贴板观察程序就调用这个函数
</p>

<p>OnChangeCbChain
</p>

<p>通知指定的窗口将从链中删除
</p>

<p>OnDestroyClipboard
</p>

<p>当通过Windows的EmptyClipboard函数清空剪贴板时调用这个函数
</p>

<p>OnDrawClipboard
</p>

<p>当内容变化时调用这个函数
</p>

<p>OnHScrollClipboard
</p>

<p>当剪贴板的拥有者要滚动剪贴板的图像、使适当的部分无效以及更新滚动条值的时候调用这个函数
</p>

<p>OnPaintClipboard
</p>

<p>当剪贴板观察器的客户区需要重画的时候调用这个函数
</p>

<p>OnRenderAllFormats
</p>

<p>当拥有者应用程序将被销毁且需要提交它的所有格式时调用这个函数
</p>

<p>OnRenderFormat
</p>

<p>当一种延迟提交的格式需要被提交时为剪贴板拥有者调用这个函数
</p>

<p>OnSizeClipboard
</p>

<p>当剪贴板观察器窗口的客户区大小发生变化时调用这个函数
</p>

<p>OnVScrollClipboard
</p>

<p>当拥有者要滚动剪贴板的图像、使适当的部分无效以及更新滚动条值的时候调用这个函数
</p>

<p>35.菜单循环通知
</p>

<p>OnEnterMenuLoop
</p>

<p>进入一个菜单模式的循环时调用该函数
</p>

<p>OnExitMenuLoop
</p>

<p>当退出一个菜单模式的循环时调用该函数
</p>



<p style='float:right;'>本页共676段，11912个字符，25172 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
