<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript">
function goTopEx(){
	var obj=document.getElementById("goTopBtn");
	function getScrollTop(){
			return document.documentElement.scrollTop;
		}
	function setScrollTop(value){
			document.documentElement.scrollTop=value;
		}    
	window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
	obj.onclick=function(){
		var goTop=setInterval(scrollMove,10);
		function scrollMove(){
				setScrollTop(getScrollTop()/111);
				if(getScrollTop()<1)clearInterval(goTop);
			}
	}
}

 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>MFC如何创建无模式对话框</title>

<style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.6em;
}
P{
margin:16px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;
}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 105px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 30px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 80px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 55px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 
img{
border:0;
}
.picsay{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
}
.code0{
color:red;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:0em;
}
.code2{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:2em;
}
.code4{
color:blue;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:4em;
}
</style>
</head>

<body>

<div class="container">
<p>一种次要窗口，包含按钮和各种选项，通过它们可以完成特定命令或任务。</p>

<p>对话框与窗口有区别，它没有最大化按钮、没有最小化按钮、不能改变形状大小 </p>

<p>对话框：是人机交流的一种方式，用户对对话框进行设置，计算机就会执行相应的命令。对话框中有单选框、复选框等。</p>

<p>对话框的组成</p>

<p>对话框主要由两部分组成。</p>

<p>对话框资源：可以使用对话框编辑器来配置对话框的界面，如对话框的大小、位置、样式，对话框中控件的类型和位置等。另外，我们还可以在程序的执行过程中动态创建对话框资源。</p>

<p>对话框类：在MFC程序中，可以使用向导帮助用户建立一个与对话框资源相关联的类，通常这个类由CDialog类派生。</p>

<p>对话框的类型</p>

<p>对话框可以分为模式对话框和无模式对话框两种类型。</p>

<p>CDialog</p>

<p>为了能够方便的操作对话框，MFC为用户提供了CDialog类。它是在屏幕上显示对话框的基类，与对话框资源紧密相关，提供了管理对话框的接口，封装了一些对话框的相关操作。</p>

<p>从CDialog的定义代码可以看出，Cdialog提供了两套构建Cdialog对象的系统，分别用于模式对话框和无模式对话框。</p>

<p>无模式对话框对象的构建过程，它首先调用缺省的构造函数生成对话框对象，然后调用Create函数创建和初始化对话框。Cdialog类中的Create函数有两种函数原型：</p>

<p>BOOL Create( LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL );</p>

<p>BOOL Create( UINT nIDTemplate, CWnd* pParentWnd = NULL );</p>

<p>其中，</p>

<p>参数lpszTemplateName是无模式对话框模板资源的标志符；</p>

<p>参数nIDTemplat是对话框模板资源的标志符，它通常以IDD_开头（例如IDD_DIALOG1）;</p>

<p>参数pParentWnd是指向对话框对象所属的父窗口的指针（如果它为NULL，则表示对话框对象的父窗口是应用程序主窗口）。如果希望对话框中它的父窗口创建后马上被显示，就必须把对话框模板设置为WS_VISIBLE形式。否则，需要调用ShowWindow函数来显示对话框。</p>

<p>对于模式对话框，其构造函数如下所示：</p>

<p>CDialog( LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL );</p>

<p>CDialog( UINT nIDTemplate, CWnd* pParentWnd = NULL );</p>

<p>构造函数的参数说明与无模式对话框的Create函数类似。在模式对话框中，当创建了对话框对象后，可以通过调用DoModal函数来显示对话框。</p>

<p>一般情况下，无论是模式对话框还是无模式对话框，都有两个按钮OK和CANCEL。对话框为它们提供了默认的消息处理函数OnOk和OnCancel。调用这两个函数都将关闭对话框。所不同的是，默认的OnOk函数中关闭对话框前将更新对话框数据，而默认的OnCancel函数不更新对话框数据。</p>

<p>当CDialog类检测到OK或Cancel键时，它将调用::EndDialog函数。EndDialog函数虽然结束了对话框应用程序，但却并没有删除对话框对象，释放内存。这对于模式对话框来说，不是问题，它的生存时间不长，我们一般在栈上创建它们；但无模式对话框则不同，它的生存时间更长，我们通常在栈上创建它们，并且希望它在消失之前能够删除自己。因此，大多数情况下，我们需要在无模式对话框中重载OnOK和OnCancel函数，加入DestroyWindows函数来彻底地删除它。</p>

<p>对话框数据交换和验证机制</p>

<p>在VC中，所有的对话框函数都是使用C++代码实现的，它并没有采用特殊的资源或“奇特”的宏，但却可以很好地实现用户与应用程序之间的交互工作，这里的关键就在于对话框应用程序中广泛采用的对话框数据交换和验证机制。</p>

<p>对话框数据交换（DDX,Dialog Data Exchange）用于初始化对话框中的控件并获取用户的数据输入，而对话框数据验证（DDV,Dialog Data Validation）则用于验证对话框中数据输入的有效性。MFC在每个对话框类中提供了一个用于重载的虚函数——DoDataExchange来实现对话框数据交换和验证工作。</p>

<p>1、首先创建对话框模板资源</p>

<p>  2、从CDialog类派生自己的无模式对话框类:CModelessDlg</p>

<p>  3、在合适的位置动态创建（new）CModelessDlg的对象：pDlg</p>

<p>  4、调用pDlg的Create函数创建无模式对话框</p>

<p>  5、调用pDlg的ShowWindow函数显示无模式对话框；</p>

<p>  6、覆盖OnOK和OnCancel函数，执行DestroyWindow函数销毁无模式对话框</p>

<p>  7、覆盖PosNcDestroy函数，执行delete this；</p>

<p>非模态对话框对象是用new操作符在堆中动态创建的，而不是以成员变量的形式嵌入到别的对象中或以局部变量的形式构建在堆栈上。通常应在对话框的拥有者窗口类内声明一个指向对话框类的指针成员变量，通过该指针可访问对话框对象。</p>

<p>通过调用CDialog::Create函数来启动对话框，而不是CDialog::DoModal，这是模态对话框的关键所在。由于Create函数不会启动新的消息循环，对话框与应用程序共用同一个消息循环，这样对话框就不会垄断用户的输入。Create在显示了对话框后就立即返回，而DoModal是在对话框被关闭后才返回的。众所周知，在MFC程序中，窗口对象的生存期应长于对应的窗口，也就是说，不能在未关闭屏幕上窗口的情况下先把对应的窗口对象删除掉。由于在Create返回后，不能确定对话框是否已关闭，这样也就无法确定对话框对象的生存期，因此只好在堆中构建对话框对象，而不能以局部变量的形式来构建之。　 </p>

<p>必须调用CWnd::DestroyWindow而不是CDialog::EndDialog来关闭非模态对话框。调用CWnd::DestroyWindow是直接删除窗口的一般方法。由于缺省的CDialog::OnOK和CDialog::OnCancel函数均调用EndDialog，故程序员必须编写自己的OnOK和OnCancel函数并且在函数中调用DestroyWindow来关闭对话框。</p>

<p>因为是用new操作符构建非模态对话框对象，因此必须在对话框关闭后，用delete操作符删除对话框对象。在屏幕上一个窗口被删除后，框架会调用CWnd::PostNcDestroy，这是一个虚拟函数，程序可以在该函数中完成删除窗口对象的工作，具体代码如下</p>

<p>void CModelessDialog::PostNcDestroy</p>

<p>{</p>

<p>    delete this; //删除对象本身</p>

<p>}</p>

<p>这样，在删除屏幕上的对话框后，对话框对象将被自动删除。拥有者对象就不必显式的调用delete来删除对话框对象了。　</p>

<p>必须有一个标志表明非模态对话框是否是打开的。这样做的原因是用户有可能在打开一个模态对话框的情况下，又一次选择打开命令。程序根据标志来决定是打开一个新的对话框，还是仅仅把原来打开的对话框激活。通常可以用拥有者窗口中的指向对话框对象的指针作为这种标志，当对话框关闭时，给该指针赋NULL值，以表明对话框对象已不存在了。　</p>

<p>提示：在C++编程中，判断一个位于堆中的对象是否存在的常用方法是判断指向该对象的指针是否为空。这种机制要求程序员将指向该对象的指针初始化为NULL值，在创建对象时将返回的地址赋给该指针，而在删除对象时将该指针置成NULL值。　</p>

<p>根据上面的分析，我们很容易把Register程序中的登录数据对话框改成非模态对话框。这样做的好处在于如果用户在输入数据时发现编辑视图中有错误的数据，那么不必关闭对话框，就可以在编辑视图中进行修改。　</p>

<p>窗口对象的自动清除：　</p>

<p>一个MFC窗口对象包括两方面的内容：一是窗口对象封装的窗口，即存放在m_hWnd成员中的HWND（窗口句柄），二是窗口对象本身是一个C++对象。要删除一个MFC窗口对象，应</p>

<p>该先删除窗口对象封装的窗口，然后删除窗口对象本身。　</p>

<p>删除窗口最直接方法是调用CWnd::DestroyWindow或::DestroyWindow，前者封装了后者的功能。前者不仅会调用后者，而且会使成员m_hWnd保存的HWND无效(NULL)。如果DestroyWindow删除的是一个父窗口或拥有者窗口，则该函数会先自动删除所有的子窗口或被拥有者，然后再删除父窗口或拥有者。在一般情况下，在程序中不必直接调用DestroyWindow来删除窗口，因为MFC会自动调用DestroyWindow来删除窗口。例如，当用户退出应用程序时，会产生WM_CLOSE消息，该消息会导致MFC自动调用CWnd::DestroyWindow来删除主框架窗口，当用户在对话框内按了OK或Cancel按钮时，MFC会自动调用CWnd::DestroyWindow来删除对话框及其控件。　</p>

<p>窗口对象本身的删除则根据对象创建方式的不同，分为两种情况。在MFC编程中，会使用大量的窗口对象，有些窗口对象以变量的形式嵌入在别的对象内或以局部变量的形式创建在堆栈上，有些则用new操作符创建在堆中。对于一个以变量形式创建的窗口对象，程序员不必关心它的删除问题，因为该对象的生命期总是有限的，若该对象是某个对象的成员变量，它会随着父对象的消失而消失，若该对象是一个局部变量，那么它会在函数返回时被清除。　</p>

<p>对于一个在堆中动态创建的窗口对象，其生命期却是任意长的。初学者在学习C++编程时，对new操作符的使用往往不太踏实，因为用new在堆中创建对象，就不能忘记用delete删除对象。读者在学习MFC的例程时，可能会产生这样的疑问，为什么有些程序用new创建了一个窗口对象，却未显式的用delete来删除它呢？问题的答案就是有些MFC窗口对象具有自动清除的功能。　</p>

<p>如前面讲述非模态对话框时所提到的，当调用CWnd::DestroyWindow或::DestroyWindow删除一个窗口时，被删除窗口的PostNcDestroy成员函数会被调用。缺省的PostNcDestroy什么也不干，但有些MFC窗口类会覆盖该函数并在新版本的PostNcDestroy中调用delete this来删除对象，从而具有了自动清除的功能。此类窗口对象通常是用new操作符创建在堆中的，但程序员不必操心用delete操作符去删除它们，因为一旦调用DestroyWindow删除窗口，对应的窗口对象也会紧接着被删除。　</p>

<p>不具有自动清除功能的窗口类如下所示。这些窗口对象通常是以变量的形式创建的，无需自动清除功能。　</p>

<p>所有标准的Windows控件类。　</p>

<p>从CWnd类直接派生出来的子窗口对象（如用户定制的控件）。　</p>

<p>切分窗口类CSplitterWnd。　</p>

<p>缺省的控制条类（包括工具条、状态条和对话条）。　</p>

<p>模态对话框类。　</p>

<p>具有自动清除功能的窗口类如下所示，这些窗口对象通常是在堆中创建的。　</p>

<p>主框架窗口类（直接或间接从CFrameWnd类派生）。　</p>

<p>视图类（直接或间接从CView类派生）。　</p>

<p>　</p>

<p>读者在设计自己的派生窗口类时，可根据窗口对象的创建方法来决定是否将窗口类设计成可以自动清除的。例如，对于一个非模态对话框来说，其对象是创建在堆中的，因此应该具有自动清除功能。　</p>

<p>综上所述，对于MFC窗口类及其派生类来说，在程序中一般不必显式删除窗口对象。也就是说，既不必调用DestroyWindow来删除窗口对象封装的窗口，也不必显式地用delete操作符来删除窗口对象本身。只要保证非自动清除的窗口对象是以变量的形式创建的，自动清除的窗口对象是在堆中创建的，MFC的运行机制就可以保证窗口对象的彻底删除。　</p>

<p>如果需要手工删除窗口对象，则应该先调用相应的函数（CWnd::DestroyWindow）删除窗口，然后再删除窗口对象．对于以变量形式创建的窗口对象，窗口对象的删除是框架自动完成的．对于在堆中动态创建了的非自动清除的窗口对象，必须在窗口被删除后，显式地调用delete来删除对象（一般在拥有者或父窗口的析构函数中进行）．对于具有自动清除功能的窗口对象，只需调用CWnd::DestroyWindow即可删除窗口和窗口对象。注意，对于在堆中创建的窗口对象，不要在窗口还未关闭的情况下就用delete操作符来删除窗口对象．　</p>

<p>提示：在非模态对话框的OnCancel函数中可以不调用CWnd::DestroyWindow，取而代之的是调用CWnd::ShowWindow(SW_HIDE)来隐藏对话框．在下次打开对话框时就不必调用Create了，只需调用CWnd::ShowWindow(SW_SHOW)来显示对话框．这样做的好处在于对话框中的数据可以保存下来，供以后使用．由于拥有者窗口在被关闭时会调用DestroyWindow删除每一个所属窗口，故只要非模态对话框是自动清除的，程序员就不必担心对话框对象的删除问题．　</p>

<p>以下是一点资料供参考，非模态对话框的销毁顺序：</p>

<p>MFC应用程序中处理消息的顺序</p>
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>

<!--
_____________________________________________________________________________________

1 段落替换：
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])
------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
[\s*</p>\s*]
[\s*<p>\s*]
------------------
</p>

<p>

<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
-->