<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>MFC三种绘图模式六种图形对象</h3>

<p>
</p>

<p>早期开发图形程序都是直接针对具体设备进行的，要开发一个图形软件必须先了解是什么型号的显示卡或者打印机，根据每个厂家提供的接口编写不同的代码来开发。进入Windows时代，操作系统通过对驱动程序的统一管理，将设备接口细节隐藏于操作系统内部。程序员在编写图形程序时，只要调用一个公用的虚拟设备即可，这个虚拟设备也就是DC。
</p>

<p>在Windows应用程序中，设备环境（DC，绘图模式）与图形对象协同进行绘图显示工作。就像画家绘图一样，设备环境（绘图模式）好比是画家的画布，图形对象好比是画家的画具，画家可以使用不同的画布、不同的画笔、画刷、颜料等，画出不同色彩、不同线条 、不同材料的画。
</p>

<p>MFC绘图类包括绘图环境类和绘图对象类。
</p>

<p>1 绘图环境类（绘图模式）
</p>

<p>绘图环境类是MFC对GDI三类绘图模式函数封装成CDC及三种派生类。
</p>

<p>CDC派生类封装的GDI函数及功能说明：
</p>

<p>a) CPaintDC类：封装了BeginPaint和EndPaint函数。
</p>

<p>用于标准客户区绘图，窗口刷新时不消失，在WM_PAINT消息下使用。
</p>

<p>b) CWindowDC类:封装了GetWindowDC和ReleaseDC函数。
</p>

<p>用于非客户区绘图，在WM_NCPAINT消息下使用，窗口刷新时不消失。
</p>

<p>c) CClientDC类：封装了GetDC和ReleaseDC函数。
</p>

<p>用于临时客户区绘图，窗口刷新时消失，任何时候都可以使用。
</p>

<p>d) CMemDC类：封装CreateCompatibleDC和DeleteDC等函数。
</p>

<p>VC6.0暂未封装该类，VS 2010有封闭。在内存中绘图，常用于双缓冲防止画面闪烁。
</p>

<p>CMetaFileDC类-父类是CDC类，作用保存绘制命令。
</p>

<p>实例：
</p>

<p>void CXdcDlg::OnPaint()
</p>

<p>{
</p>

<p>CPaintDC dc(this); // device context for painting
</p>

<p>dc.Rectangle(0,0,40,40);
</p>

<p>dc.Rectangle(80,80,120,120);
</p>

<p>dc.MoveTo(20,20);
</p>

<p>dc.LineTo(100,100);
</p>

<p>}
</p>

<p>void CXdcDlg::OnNcPaint()
</p>

<p>{
</p>

<p>#if 0
</p>

<p>CWindowDC dc(this);
</p>

<p>CRect rect;
</p>

<p>GetWindowRect(rect);
</p>

<p>dc.Rectangle(0,0,rect.Width(),rect.Height());
</p>

<p>char str[222];
</p>

<p>sprintf(str,"非客户空间（%d,%d,%d,%d)",rect.left,rect.top,rect.right,rect.bottom);
</p>

<p>dc.SetTextColor(RGB(255,0,0));
</p>

<p>dc.TextOut(5,5,str,strlen(str));
</p>

<p>#endif
</p>

<p>}
</p>

<p>void CXdcDlg::OnLButtonDown(UINT nFlags, CPoint point)
</p>

<p>{
</p>

<p>CClientDC dc(this);
</p>

<p>dc.Ellipse(point.x-10,point.y-10,point.x+10,point.y+10);
</p>

<p>CDialog::OnLButtonDown(nFlags, point);
</p>

<p>}
</p>

<p>图片描述(最多50字)
</p>

<p>图片描述(最多50字)
</p>

<p>2 绘图对象类
</p>

<p>使用GDI对象可以改变线条的颜色、大小，可以使用填充颜色，改变字体，显示一张位图等。不过，GDI对象是要通过DC才能发生作用的。要使用这些GDI对象，必须使用SelectObject函数将其选入DC中。
</p>

<p>主要有六种，全部由CGdiObject类派生：
</p>

<p>CPen-画笔，用于修饰线条的颜色、宽度和线型（实线、虚线或点划线等）；
</p>

<p>CBrush-画刷，用于修饰一个闭合图形内部的填充内容（填充颜色、填充线条以及平铺位图；
</p>

<p>CFont-字体，用于修饰输出文字的样式、高度、粗细以及字间距等；
</p>

<p>CBitmap-位图，用于显示和处理点阵图像；
</p>

<p>CRgn-区域，用于修饰输出图像的不规则边界，如椭圆或多边形等；
</p>

<p>CPalette-调色板，用于修饰输出图像的色调，如16色或256色等；
</p>

<p>颜色变量和处理函数：
</p>

<p>typedef DWORD COLORREF;
</p>

<p>COLORREF c1 = RGB(255,255,255);
</p>

<p>一般按如下步骤使用GDI对象：
</p>

<p>a、创建或得到一个GDI对象；
</p>

<p>b、使用dc.SelectObject函数把GDI对象选入DC；
</p>

<p>c、使用DC进行绘图或文字输出；
</p>

<p>d、恢复DC原来的GDI对象并删除刚新创建的GDI对象；
</p>

<p>3 	一般的使用GDI对象的绘图步骤
</p>

<p>综合DC和GDI对象的使用步骤，则绘图的完整步骤为：
</p>

<p>3.1 获取或者创建一个DC，也就是创建一个绘图模式或环境；
</p>

<p>3.2 获取或者创建一个GDI对象(Pen, Brush等)；
</p>

<p>3.3 使用dc.SelectObject函数把GDI对象选入DC；
</p>

<p>3.4 使用DC进行绘图或文字输出；
</p>

<p>3.5 恢复DC原来的GDI对象并删除刚新创建的GDI对象，如pen.DeleteObject()；
</p>

<p>3.6 释放或删除设备描述表DC；
</p>

<p>其中，1和6，2和4是对应的。
</p>

<p>4 CPen类（画笔）
</p>

<p>画笔决定了线条的颜色、宽度和线型(实线、点线或点划线等)。Windows使用当前在设备描述表中已选择的画笔来画线。程序中可以选择Windows的预定义画笔，也可以选择自定义的画笔。
</p>

<p>预定义画笔有三种：BLACK_PEN(黑色笔) 、WHITE_PEN(白色笔)和NULL_PEN(空笔)，这些都在windows.h中已经定义好了，程序员可使用GetStockObject函数来选择其中的一种，系统缺省的画笔为黑色笔。Windows.h包含了HPEN的数据类型定义，使用该类型可以定义画笔句柄的变量。
</p>

<p>仅靠系统提供的预定义画笔远远不能满足需求，应用程序可根据实际需要创建一种自定义的逻辑画笔。其步骤一般为：首先用CreatePen或CreatePenIndirect函数建立一支画笔，再调用SelectObject函数将其选入设备描述表，此后就可使用该画笔在选定的设备描述表中进行绘图操作。任何时候某一设备描述表只能有一支画笔被选入作为当前画笔，当一支画笔被选入时，原先已选入的画笔便不再有效。完成绘图操作后，可以通过调用DeleteObject来释放已建立的画笔。
</p>

<p>* 函数CreatePen()
</p>

<p>语法:HPEN CreatePen(int fnPenStyle,int nWidth,COLORREF clrref);
</p>

<p>说明:该函数创建一个逻辑画笔。其中fnPenStyle参数指定画笔的线型，该参数可取由windows.h定义的七个标识符之一，其含义为：
</p>

<p>PS_SOLID                 实线
</p>

<p>PS_DASH                  虚线
</p>

<p>PS_DOT                    点线
</p>

<p>PS_DASHDOT           夹一点虚线
</p>

<p>PS_DASHDOTDOT     夹二点虚线
</p>

<p>PS_NULL                  无
</p>

<p>PS_INSIDEFRAME     线画在所有构件框架内
</p>

<p>nWidth参数是用逻辑单位表示的画笔的宽度；
</p>

<p>clrref参数是一个COLORREF类型的颜色值，指定画笔的颜色，可用宏指令RGB构造这个值，如：clrref=RGB(byRed,byGreen,byBlue);
</p>

<p>实例
</p>

<p>void CPenDlg::OnPaint()
</p>

<p>{
</p>

<p>CPaintDC dc(this); // 绘图模式之一(标准客户区绘图)，另外还有CWindowDC（非客户区）、CClientDC（临时客户区）
</p>

<p>dc.TextOut(20,20,"默认画笔：黑色，宽度为1");
</p>

<p>dc.MoveTo(20,60);
</p>

<p>dc.LineTo(120,60);
</p>

<p>dc.TextOut(20,80,"通过构造函数创建画笔：CPen pn1(PS_SOLID,4,RGB(255,0,0));");
</p>

<p>CPen pn1(PS_SOLID,4,RGB(255,0,0));
</p>

<p>CPen *pOldPen = dc.SelectObject(&pn1); //选择的是新建画笔，返回的是之前的旧画笔
</p>

<p>dc.MoveTo(20,120);
</p>

<p>dc.LineTo(120,120);
</p>

<p>dc.TextOut(20,140,"通过CreatePen函数创建画笔：pn2.CreatePen(PS_DASHDOT,1,RGB(0,0,255));");
</p>

<p>CPen pn2;
</p>

<p>pn2.CreatePen(PS_DASHDOT,1,RGB(0,0,255));
</p>

<p>dc.SelectObject(&pn2);
</p>

<p>dc.MoveTo(20,180);
</p>

<p>dc.LineTo(120,180);
</p>

<p>dc.TextOut(20,200,"画一个矩形dc.Rectangle(20,240,140,300); 右上、右下角坐标 ");
</p>

<p>dc.SelectObject(pOldPen); // 选择默认画笔
</p>

<p>dc.Rectangle(20,240,140,300);
</p>

<p>dc.TextOut(20,320,"画一个无边框的矩形：CPen pn3(PS_NULL,1,RGB(0,0,0));");
</p>

<p>CPen pn3(PS_NULL,1,RGB(0,0,0));
</p>

<p>dc.SelectObject(&pn3);
</p>

<p>dc.Rectangle(20,360,140,420);
</p>

<p>dc.TextOut(20,440,"等价的无边框矩形的画法：dc.FillSolidRect(20,440,120,60,RGB(255,255,255));右上角坐标，长，宽");
</p>

<p>dc.FillSolidRect(20,480,120,60,RGB(255,255,255)); //右上角坐标，长，宽
</p>

<p>dc.SelectObject(pOldPen); // 恢复默认画笔
</p>

<p>}
</p>

<p>运行效果：
</p>

<p>图片描述(最多50字)
</p>

<p>5 CBrush（刷子）
</p>

<p>当我们在绘制一些区域图形时，其内部往往需要以某种图案进行填充，这就需要选定"刷子"作为绘图工具。Windows系统不仅为用户提供了预定义刷子，而且还允许应用程序自定义刷子。
</p>

<p>Windows系统中预定义的刷子有如下七种：
</p>

<p>BLACK_BRUSH        黑色刷子
</p>

<p>DKGRAY_BRUSH      深灰色刷子
</p>

<p>GRAY_BRUSH          灰色刷子
</p>

<p>HOLLOW_BRUSH      中空刷子，画边界而不填充
</p>

<p>LTGRAY_BRUSH       浅灰色刷子
</p>

<p>NULL_BRUSH           空刷子
</p>

<p>WHITE_BRUSH         白色刷子
</p>

<p>应用程序可以调用GetStockObject函数选用其中一个，系统缺省的刷子是白色刷子。Window.h包含了HBRUSH数据类型的定义，使用该类型就可定义刷子句柄的变量。
</p>

<p>仅靠这七种刷子往往不能满足要求，应用程序通过调用如下几种函数创建逻辑刷子，这些函数返回值均为刷子句柄。
</p>

<p>* 函数CreateHatchBrush()
</p>

<p>语法：HBRUSH CreateHatchBrush(int fnStyle, COLORREF clrref);
</p>

<p>说明: 该创建一个带阴影的逻辑刷子。
</p>

<p>FnStyle指定的阴影格式如下:
</p>

<p>HS_BDLAGONAL 45度向上斜线组成的阴影图案(自左到右)
</p>

<p>HS_CROSS                 水平和垂直交叉组成的阴影图案
</p>

<p>HS_DIAGCROSS        45度斜线交叉组成的阴影图案
</p>

<p>HS_FDIAGONAL        45度向下斜线组成的阴影图案(自左到右)
</p>

<p>HS_HORZONA           水平线组成的阴影图案
</p>

<p>HS_VERTICAL           垂直线组成的阴影图案
</p>

<p>Clrref是具有COLORREF类型定义的刷子颜色值，可用宏指令RGB构造这个值。
</p>

<p>* 函数CreateSolidBrush()
</p>

<p>语法:HBRUSH CreateSolidBrush(COLORREF clrre);
</p>

<p>说明:该函数创建的是一种实心颜色的逻辑刷子。clrre含义同上。
</p>

<p>同样，使用创建刷子的函数时，要检查其返回，确保它是一个有效的句柄。
</p>

<p>一旦创建了绘图工具之后，可以SelectObject函数把它选择到显示缓冲区里。
</p>

<p>在使用显示缓冲区之前，并不一定非要创建和选择绘图工具，Windows为每个显示缓冲区提供默认的绘图工具。例如:黑色笔,白色刷子和系统字体。
</p>

<p>DeleteObject函数用来删除不再需要的绘图工具，但不能删除一个已选进显示缓冲区的绘图工具，而是应该使用SelectObject函数恢复原有的绘图工具，然后再删除需要删除的工具。
</p>

<p>6 CFont（字体）
</p>

<p>Windows是使用定义好的与设备无关的字符集，Windows的"文本"字符也是图形，所以屏幕上所显示的用打印机或绘图仪等输出品的文本完全一样，做到"所见即所得"。
</p>

<p>文本绘制函数有：
</p>

<p>TextOut            以当前的字体写一字符串
</p>

<p>DrawText          在一个特定矩形区中绘制某一格式的文本
</p>

<p>ExtTextOut      在一个特定矩形区中，以当前字体写一字符串
</p>

<p>GrayString       用灰色文本写一字符串
</p>

<p>TabbedTextOut  写一带扩展字符的字符串
</p>

<p>要输出文本就离不开字体。获取字体的相关信息可以使用函数：
</p>

<p>BOOL GetTextMetrics( LPTEXTMETRIC lpMetrics )
</p>

<p>结构TEXTMETRIC的定义如下所示:
</p>

<p>typedef struct tagTEXTMETRIC {      // tm
</p>

<p>LONG tmHeight;                       //字符高度
</p>

<p>LONG tmAscent;                       //字符上部高度(基线以上)
</p>

<p>LONG tmDescent;                      //字符下部高度(基线以下)
</p>

<p>LONG tmInternalLeading;           //由tmHeight定义的字符高度的顶部空间数目
</p>

<p>LONG tmExternalLeading;          //加在两行之间的空间数目
</p>

<p>LONG tmAveCharWidth;            //平均字符宽度
</p>

<p>LONG tmMaxCharWidth;           //最宽字符的宽度
</p>

<p>LONG tmWeight;                       //字体的粗细轻重程度
</p>

<p>LONG tmOverhang;                   //加入某些拼接字体上的附加高度
</p>

<p>LONG tmDigitizedAspectX;        //字体设计所针对的设备水平方向
</p>

<p>LONG tmDigitizedAspectY;        //字体设计所针对的设备垂直方向
</p>

<p>BCHAR tmFirstChar;                 //为字体定义的第一个字符
</p>

<p>BCHAR tmLastChar;                  //为字体定义的最后一个字符
</p>

<p>BCHAR tmDefaultChar;                    //字体中所没有字符的替代字符
</p>

<p>BCHAR tmBreakChar;                //用于拆字的字符
</p>

<p>BYTE tmItalic;                          //字体为斜体时非零
</p>

<p>BYTE tmUnderlined;                  //字体为下划线时非零
</p>

<p>BYTE tmStruckOut;                   //字体被删去时非零
</p>

<p>BYTE tmPitchAndFamily;          //字体间距(低4位)和族(高4位)
</p>

<p>BYTE tmCharSet;                      //字体的字符集
</p>

<p>} TEXTMETRIC;
</p>

<p>GDI字体族和字样表如下表所示:
</p>

<p>字体族字体族常量字样说明
</p>

<p>Dontcare      FF_DONTCARE          System          当不能提供字体信息或字体并不
</p>

<p>重要时使用
</p>

<p>Decorative     FF_DECORATIVE       Symbol         新奇字体
</p>

<p>Modern         FF_MODERN Courer,ModernIerminal 笔画大小固定的字体，但衬线可有可无
</p>

<p>Roman          FF_ROMAN  Roman,TimeRoman      有衬线的、笔画大小可变的罗马字体
</p>

<p>Script            FF_SCRIPT   Script                         仿手写体
</p>

<p>Swiss            FF_SWISS    Helvetical,System        无衬线的、笔画大小可变的字体
</p>

<p>* CreateFontIndirect函数
</p>

<p>语法: HFONT CreateFontIndirect(
</p>

<p>CONST LOGFONT *lplf  // pointer to logical font structure
</p>

<p>);
</p>

<p>说明:参数lplf是LOGFONT结构的指针。结构中含有逻辑字体的特征信息。该函数用lplf所指的LOGFONT结构中的信息创建一种逻辑字体。LOGFONT结构的定义如下:
</p>

<p>typedef struct tagLOGFONT {                          // lf
</p>

<p>LONG lfHeight;                                       //字高度
</p>

<p>LONG lfWidth;                                        //字符平均宽度
</p>

<p>LONG lfEscapement;                                //行与水平页角度
</p>

<p>LONG lfOrientation;                                //基线与水平角度
</p>

<p>LONG lfWeight;                                      //笔划的粗细
</p>

<p>BYTE lfItalic;                                          //非零为斜体
</p>

<p>BYTE lfUnderline;                                   //非零为下划线
</p>

<p>BYTE lfStrikeOut;                                   //非零为中划线
</p>

<p>BYTE lfCharSet;                                      //指定字符集
</p>

<p>BYTE lfOutPrecision;                               //输出精度
</p>

<p>BYTE lfClipPrecision;                              //裁剪精度
</p>

<p>BYTE lfQuality;                                      //输出质量
</p>

<p>BYTE lfPitchAndFamily;                          //字体的字距和族
</p>

<p>TCHAR lfFaceName[LF_FACESIZE];       //含字体名的字符串
</p>

<p>} LOGFONT;
</p>

<p>* 函数SetTextAlign
</p>

<p>大多数文本函数传递的参数表都要求有一个点坐标参数以定义写文本的参考点。当前文本对齐属性规定了字符串如何相对于所传递的坐标进行写。SetTextAlign函数用以设置当前文本对齐属性。
</p>

<p>语法:
</p>

<p>UINT SetTextAlign(
</p>

<p>HDC hdc,    // handle to device context
</p>

<p>UINT fMode  // text-alignment flag
</p>

<p>);
</p>

<p>说明:该函数设置文本对齐方式。Hdc是参数描述表，fuAlign是文本对齐方式
</p>

<p>* GetClientRect函数
</p>

<p>语法:
</p>

<p>BOOL GetClientRect(
</p>

<p>HWND hWnd,     // handle to window
</p>

<p>LPRECT lpRect  // address of structure for client coordinates
</p>

<p>);
</p>

<p>说明: hWnd是与用户区域相关的窗口，lpRect是指向RECT结构的指针。
</p>

<p>附：通过HDC句柄调用GDI函数的三种绘图模式
</p>

<p>// DC32.cpp : Defines the entry point for the application.
</p>

<p>#include "stdafx.h"
</p>

<p>#include "resource.h"
</p>

<p>#include &lt;stdio.h>
</p>

<p>// GDI函数通过HDC句柄来调用
</p>

<p>#if 1
</p>

<p>//消息回调函数窗口客户区绘图 BeginPaint(hwndDlg,&ps);窗口刷新时不消失，在WM_PAINT消息下使用，封装成CPaintDC类
</p>

<p>BOOL CALLBACK dlgFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
</p>

<p>{
</p>

<p>switch(uMsg)
</p>

<p>{
</p>

<p>case WM_COMMAND:
</p>

<p>switch(wParam)
</p>

<p>{
</p>

<p>case IDCANCEL:
</p>

<p>EndDialog(hwndDlg,IDCANCEL);
</p>

<p>break;
</p>

<p>}
</p>

<p>case WM_PAINT:	//窗口客户区绘图
</p>

<p>{
</p>

<p>PAINTSTRUCT ps;
</p>

<p>//获取与容器客户区关联的绘图句柄
</p>

<p>HDC hdc=BeginPaint(hwndDlg,&ps);
</p>

<p>//画两个矩形
</p>

<p>Rectangle(hdc,0,0,40,40);
</p>

<p>Rectangle(hdc,80,80,120,120);
</p>

<p>//画一条线
</p>

<p>MoveToEx(hdc,20,20,NULL);
</p>

<p>LineTo(hdc,100,100);
</p>

<p>EndPaint(hwndDlg,&ps);
</p>

<p>}
</p>

<p>break;
</p>

<p>}
</p>

<p>return FALSE;
</p>

<p>}
</p>

<p>#endif
</p>

<p>#if 0
</p>

<p>//消息回调函数非窗口客户区绘图 ;窗口刷新时不消失，在WM_NCPAINT消息下使用，封装成CWindowDC类
</p>

<p>BOOL CALLBACK dlgFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
</p>

<p>{
</p>

<p>switch(uMsg)
</p>

<p>{
</p>

<p>case WM_COMMAND:
</p>

<p>switch(wParam)
</p>

<p>{
</p>

<p>case IDCANCEL:
</p>

<p>EndDialog(hwndDlg,IDCANCEL);
</p>

<p>break;
</p>

<p>}
</p>

<p>case WM_NCPAINT:
</p>

<p>{
</p>

<p>HDC hdc = GetWindowDC(hwndDlg);
</p>

<p>RECT rect;
</p>

<p>GetWindowRect(hwndDlg,&rect);	//获取整个窗口的空间区域
</p>

<p>//画两个矩形
</p>

<p>Rectangle(hdc,0,0,rect.right-rect.left,rect.bottom-rect.top);
</p>

<p>char str[222];
</p>

<p>sprintf(str,"非客户空间（%d,%d,%d,%d)",rect.left,rect.top,rect.right,rect.bottom);
</p>

<p>SetTextColor(hdc,RGB(255,0,0));
</p>

<p>TextOut(hdc,5,5,str,strlen(str));
</p>

<p>ReleaseDC(hwndDlg,hdc);
</p>

<p>return TRUE;
</p>

<p>}
</p>

<p>case WM_MOVE:
</p>

<p>SendMessage(hwndDlg,WM_NCPAINT,0,0);
</p>

<p>InvalidateRect(hwndDlg,NULL,TRUE);
</p>

<p>return TRUE;
</p>

<p>}
</p>

<p>return FALSE;
</p>

<p>}
</p>

<p>#endif
</p>

<p>#if 0
</p>

<p>//消息回调函数临时客户区绘图 ;窗口刷新时消失，任何时候都可以使用，封装成GetDC类
</p>

<p>BOOL CALLBACK dlgFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
</p>

<p>{
</p>

<p>switch(uMsg)
</p>

<p>{
</p>

<p>case WM_COMMAND:
</p>

<p>switch(wParam)
</p>

<p>{
</p>

<p>case IDCANCEL:
</p>

<p>EndDialog(hwndDlg,IDCANCEL);
</p>

<p>break;
</p>

<p>}
</p>

<p>case WM_LBUTTONDOWN:
</p>

<p>HDC hdc = GetDC(hwndDlg);
</p>

<p>int x = LOWORD(lParam);
</p>

<p>int y = HIWORD(lParam);
</p>

<p>// 画一个圆形
</p>

<p>Ellipse(hdc,x-10,y-10,x+10,y+10);
</p>

<p>ReleaseDC(hwndDlg,hdc);
</p>

<p>return TRUE;
</p>

<p>}
</p>

<p>return FALSE;
</p>

<p>}
</p>

<p>#endif
</p>

<p>//测试坐标系转换
</p>

<p>void ScreenToClient(HWND hwndParent, RECT &rect)
</p>

<p>{
</p>

<p>POINT lt = {rect.left,rect.top};
</p>

<p>POINT rb = {rect.right,rect.bottom};
</p>

<p>ScreenToClient(hwndParent,&lt);
</p>

<p>ScreenToClient(hwndParent,&rb);
</p>

<p>rect.left = lt.x;
</p>

<p>rect.top = rb.x;
</p>

<p>rect.bottom = rb.y;
</p>

<p>}
</p>

<p>#if 0
</p>

<p>//消息回调函数测试坐标系转换
</p>

<p>BOOL CALLBACK dlgFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
</p>

<p>{
</p>

<p>switch(uMsg)
</p>

<p>{
</p>

<p>case WM_COMMAND:
</p>

<p>switch(wParam)
</p>

<p>{
</p>

<p>case IDCANCEL:
</p>

<p>EndDialog(hwndDlg,IDCANCEL);
</p>

<p>break;
</p>

<p>}
</p>

<p>case WM_SETCURSOR: //当鼠标靠近或者切换到不同的控件时回调
</p>

<p>{
</p>

<p>HWND hwnd = (HWND)wParam;
</p>

<p>if(hwnd != GetDlgItem(hwndDlg,IDOK))
</p>

<p>return TRUE;
</p>

<p>RECT rect;
</p>

<p>GetWindowRect(hwnd,&rect); //获取按钮的屏幕坐标
</p>

<p>ScreenToClient(hwndDlg,rect);
</p>

<p>rect.left -=100;
</p>

<p>rect.right -= 100;
</p>

<p>MoveWindow(hwnd,rect.left,rect.top,rect.right-rect.left,rect.bottom-rect.top,TRUE);
</p>

<p>return TRUE;
</p>

<p>}
</p>

<p>break;
</p>

<p>}
</p>

<p>return FALSE;
</p>

<p>}
</p>

<p>#endif
</p>

<p>int APIENTRY WinMain(HINSTANCE hInstance,
</p>

<p>HINSTANCE hPrevInstance,
</p>

<p>LPSTR   lpCmdLine,
</p>

<p>int    nCmdShow)
</p>

<p>{
</p>

<p>//MessageBox(NULL,"first program","note",0);
</p>

<p>DialogBox(hInstance,(LPCTSTR)ws,NULL,dlgFunc);
</p>

<p>return 0;
</p>

<p>}
</p>

<p>运行效果：
</p>

<p>－End－
</p>



<p style='float:right;'>本页共378段，11602个字符，18420 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
