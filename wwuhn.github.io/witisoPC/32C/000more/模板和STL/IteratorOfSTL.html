<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>摘录PCnotes</title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop属
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrower{
border-collapse:collapse;
}
#tbrower td{


border:1px #ccc solid;
padding:2px;
}
</style></head><body onload="downn();">
<div>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	//if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	//}
</script>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a><a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a></div>
<div id="container">
<script>
	goTopEx();
</script>
<p>The STL provides a collection of templates representing containers, iterators, function objects, and algorithms. A container is a unit, like an array, that can hold several values. STL containers are homogeneous; that is, they hold values all of the same kind. Algorithms are recipes for accomplishing particular tasks, such as sorting an array or finding a particular value in a list. Itertors are objects that let you move through a container much as pointers let you move through an arry; they are generalizations of pointers. Function objects are objects that act like functions; they can be class objects or function pointers(including function names because a function name acts as a pointer). The STL lets you construct a variety of containers, including arrays, queues, and lists, and it lets you perform a variety of operations, including searching, sorting, and randomizing.</p>
<p>There's too much information about the STL to present, so we'll look at some representative examples and examine the spirit of the generic programming approach. When you have a hands-on appreciation for containers, iterators and algorithms, we'll look at the underlying design philosophy and then take an overview of the whole STL.</p>
<h4>The vector Template class</h4>
<p>A computing-style vector holds a set of like values that can be accessed randomly. That is, you can see, say, an index to directly access the 10th element of a vector without having to access the preceding 9 elements first. That is, you could create a vector object, assign one vector object to another, and use the [] operator to access vector elements. To make the class generic, you make it a template class. That's what the STL does, defining a vector template in the vector(formerly vector.h) header file.</p>
<p>To create a vector template object, you use the uaual &lt;type> notation to indicate the type to be used. Also the vector template uses dynamic memory allocation, and you can use an initialization argument to indicate how many vector elements you want:</p>
<pre>
#include vector
using namespace std;
vector&lt;int> rating(5); //a vector of 5 ints
int n;
cin >> n;
vector&lt;double> scores(n); //a vector of n doubles
</pre>
<p>After you create a vector object, operator overloading for [] makes it possible to use the usual array notation for accessing individual elements:</p>
<pre>
ratings[0] = 9;
for(int i=0; i&lt;n; i++)
    cout  &lt;&lt; scores[i]  &lt;&lt;endl
</pre>
<p>Below is a example that uses this class in an undemanding application. This particular program creates two vector objects, one an int specilization and one a string specialization; each has five elements.</p>
<pre>
#include &lt;iostream>
#include &lt;string>
#include &lt;vector>
using namespace std;
const int NUM = 5;
int main()
{
    vector&lt;int> ratings(NUM);
    vector&lt;string> titles(NUM);
    cout &lt;&lt; "You will do exactly as told. You will enter\n"
          &lt;&lt; NUM  &lt;&lt; " book titles and your ratings (0-10).\n";
    int i;
    for (i = 0; i &lt; NUM; i++)
    {
        cout  &lt;&lt; "Enter title #"  &lt;&lt; i + 1  &lt;&lt; ": ";
        getline(cin,titles[i]);
        cout  &lt;&lt; "Enter your rating (0-10): ";
        cin >> ratings[i];
        cin.get();
    }
    cout  &lt;&lt; "Thank you. You entered the following:\n"
           &lt;&lt; "Rating\tBook\n";
    for (i = 0; i &lt; NUM; i++)
    {
        cout  &lt;&lt; ratings[i]  &lt;&lt; "\t"  &lt;&lt; titles[i]  &lt;&lt; endl;
    }
    cin.get();

    return 0; 
}
//output:
/*
You will do exactly as told. You will enter
5 book titles and your ratings (0-10).
Enter title #1: book1

Enter your rating (0-10): 4
Enter title #2: book2

Enter your rating (0-10): 5
Enter title #3: book3

Enter your rating (0-10): 2
Enter title #4: book4

Enter your rating (0-10): 3
Enter title #5: book5

Enter your rating (0-10): 4
Thank you. You entered the following:
Rating  Book
4       book1
5       book2
2       book3
3       book4
4       book5
*/


</pre>
<p>All this program does is use the vector template as a convenient way to create a dynamically allocated array. The next section shows an example that uses more of the class methods.</p>

<h4>Things to do to vectors</h4>
<p>Besides allocating storage, what else can the vector template do for you? All the STL containers provide certain basic methods, including size(), which returns the number of elements in a container, swap(), which exchanges the contents of two containers, begin(), which returns an iterator that refers to the first element in a container, and end(), which returns an iterator that represents past-the-end for the containor.</p>
<p>What's an iterator? It's generalization of a pointer. In fact, it can be a pointer. Or it can be an object for which pointer-like operations such as dereferencing(for example, operator*()) and incrementing(for example, operator++()) have been defined. As you'll see later, generalizing pointers to itertors allows the STL to provide a uniform interface for a variety of container classes, including ones for which simple pointers wouldn't work. Each container class defines a suitable iterator. The type name for this iterator is a class scope typedef called iterator. For example, to declare an iterator for a type double specialization of vector, you would use this:</p>
<pre>
vector&lt;double>::iterator pd; //pd an iterator
</pre>
<p>Suppose scores is a vector&lt;double> object:</p>
<pre>
vector&lt;double> scores;
</pre>
<p>Then you can use the iterator pd in code like the following:</p>
<pre>
pd = scores.begin(); 	// have pd points to the first element
*pd = 22.3;		// dereference pd and assign value to first element
++pd;			// make pd point to the next element
</pre>
<p>You can display the contents with this code:</p>
<pre>
for(pd = scores.begin(); pd != scores.end(); pd++)
	cout &lt;&lt; *pd &lt;&lt;end;
</pre>
<p>All containers have the methods just discussed. The vector template class also has some methods that only some STL containers have. One handy method, called push_back(), adds an element to the end of a vector. While doing so, it attends to memory managements so that the vector size increases to accommodate added members. This means you can write code like the following:</p>
<pre>
vector&lt;double> scores;
double temp;
while(cin >> temp && temp >=0)
	scores.push_back(temp);
cout  &lt; &lt; "You entered"  &lt; &lt; scores.size()  &lt; &lt; " scores.\n";
</pre>
<p>Below is the example illustrates some methods.</p>
<pre>
// vect2.cpp -- methods and iterators
#include &lt;iostream>
#include &lt;string>
#include &lt;vector>
using namespace std;
struct Review {
    string title;
    int rating;
};
bool FillReview(Review & rr);
void ShowReview(const Review & rr);

int main()
{
    vector&lt;Review> books;
    Review temp;
    while (FillReview(temp))
        books.push_back(temp);
    int num = books.size();
    if (num > 0)
    {
        cout &lt;&lt; "Thank you. You entered the following:\n"
            &lt;&lt; "Rating\tBook\n";
        for (int i = 0; i &lt; num; i++)
            ShowReview(books[i]);
        cout &lt;&lt; "Reprising:\n"
            &lt;&lt; "Rating\tBook\n";
        vector&lt;Review>::iterator pr;
        for (pr = books.begin(); pr != books.end(); pr++)
            ShowReview(*pr);
        vector &lt;Review> oldlist(books);     // copy constructor used
        if (num > 3)
        {
            // remove 2 items
            books.erase(books.begin() + 1, books.begin() + 3);
            cout &lt;&lt; "After erasure:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
                ShowReview(*pr);
            // insert 1 item
            books.insert(books.begin(), oldlist.begin() + 1,
                        oldlist.begin() + 2);
            cout &lt;&lt; "After insertion:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
                ShowReview(*pr);
        }
        books.swap(oldlist);
        cout &lt;&lt; "Swapping oldlist with books:\n";
        for (pr = books.begin(); pr != books.end(); pr++)
            ShowReview(*pr);
    }
    else
        cout &lt;&lt; "Nothing entered, nothing gained.\n";
    cin.get();
	cin.get();
	return 0;
}

bool FillReview(Review & rr)
{
    cout &lt;&lt; "Enter book title (quit to quit): ";
    getline(cin,rr.title);
    if (rr.title == "quit")
        return false;
    cout &lt;&lt; "Enter book rating: ";
    cin >> rr.rating;
    if (!cin)
        return false;
    // get rid of rest of input line
    while (cin.get() != '\n')
        continue;
    return true;
}

void ShowReview(const Review & rr)
{
    cout &lt;&lt; rr.rating &lt;&lt; "\t" &lt;&lt; rr.title &lt;&lt; endl; 
}
/*
output:
Enter book title (quit to quit): book1

Enter book rating: 4
Enter book title (quit to quit): book2

Enter book rating: 5
Enter book title (quit to quit): book3

Enter book rating: 3
Enter book title (quit to quit): book4

Enter book rating: 5
Enter book title (quit to quit): book5

Enter book rating: 4
Enter book title (quit to quit): quit

Thank you. You entered the following:
Rating  Book
4       book1
5       book2
3       book3
5       book4
4       book5
Reprising:
Rating  Book
4       book1
5       book2
3       book3
5       book4
4       book5
After erasure:
4       book1
5       book4
4       book5
After insertion:
5       book2
4       book1
5       book4
4       book5
Swapping oldlist with books:
4       book1
5       book2
3       book3
5       book4
4       book5
*/
</pre>
<h4>Why iterators?</h4>
<p>Understanding iterators is perhaps the key to understanding the STL. Just as templates make algorithms independent of the type of data stored, iterators make the algorithms independent of the type of container used. Thus, they are an essential component of the STL's generic approch.</p>

<p>To see why iterators are needed, let's look at how you might implement a find function for two different data representations and then see how you could generalize the approach. First, let's consider a function that searches an ordianry array of double for a particular value. You could write the function like this:</p>

<p></p>

<pre>

double * find_ar(double *ar, int n, const double &amp; val)
{
    for (int i=0; i&lt;n; i++)
        if (ar[i]==val)
            return &ar[i];
    return 0;
}
</pre>

<p>If the function finds the value in the array, it returns the address in the array where the value is found; otherwise, it returns the null pointer. It uses subscript notation to move through the array. You could use a template to generalize to arrays of any type having an == operator. Nonetheless, this algorithm is still tried to one particular data structure-the array.</p>

<p>So let's look at searching another kind of data structure, the linked list. The list consists of linked Node structures:</p>
<p></p>
<pre>
struct Node
{
    double item;
    Node * p_next;
};
</pre>



<p>Suppose you have a pointer that points to the first node in the list. The p_next pointer in each node points the next node, and the p_next pointer for the last node in the list is set to 0. You could write a find-11() function this way:</p>
<p></p>
<pre>
Node * find_11(Node * head, const double & val)
{
    Node * start;
    for (start = head; start!=0; start = start->p_next)
        if(star->item == val)
            return start;
        return 0;
}
</pre>

<p>Again, you could use a template to generalize this to lists of any data type supporting the == operator. Nonetheless, this algorithm is still tied to one particular data structure-the linked list.</p>

<p>If you consider details of implementation, the two find functions use different algorithm:One uses array indexing to move through is a list of items, and the other resets start to start->p_next. But broadly, the two algroithms are the same: Compare the value with each value in the container in sequence until you find a match.</p>

<p>The goal of generic programming in this case would be to have a single find function that would work with arrays or linked lists or any other container type. That is, not only should the function be independent of the data type stored in the container, it should be independent of the data structure of the container itself. Templates provide a generic representation for the data type stored in a container. What's needed is a generic representation of the process of moving through the values in a container. The iterator is that generalized representation.</p>

<p>What properties should an iterator have in order to implement a find function? Here's a short list:</p>



<p>You should be able to dereference an iterator in order to access the value to which it refers. That is, if p is an iterator, *p should be defined.</p>



<p>You should be able to assign one iterator to another. That is, if p and q are iterators, the expression p = q should be defined.</p>



<p>You should be able to compare one iterator to another for equlity. That is, if p and q are iterators, the expressions p == q and p != q should be defined.</p>



<p>You should be able to move an iterator through all the elements of a containor. This can be satisfied by defining ++p and p++ for an iterator p.</p>

<p>There are more things an iterator could do, but nothing more it need to-at least, not for the purposes of a find functions. Actually, the STL defines several levels of iterators of increasing capabilities, and we'll return to that matter later. Note, by the way, that an ordianry pointer meets the requirements of an iterator. Hence, you can rewrite the find_arr() function like this:</p>
<p></p>
<pre>
typedef double * iterator;
iterator find_ar(iterator ar, int n, const double & val)
{
    for(int i=0; i&lt;n; i++, arr++)
        if(*ar == val)
            return ar;
    return 0;
}
</pre>

<p>Then you can alter the function parameter list so that it takes a pointer to the beginning of the array and a pointer to one past-the-end of the array  as arguments to indicate a range. And the function can return the end pointer as a sign the value was not found. The following version of find_ar() makes these changes:</p>
<pre>
typedef double * iterator;
iterator find_ar(iterator begin, iterator end, const double & val)
{
    for(ar = begin; ar !=end; arr++)
        if(*ar == val)
            return ar;
	return end;
}
</pre>

<p>for the find_11() function, you can define an iterator class that defines the * and ++ operators:</p>
<pre>
struct Node
{
	double item;
	Node * p_next;
};
class iterator
{
	Node * pt;
	public:
		iterator(): pt(0){}
		iterator(Node * pn):pt(pn){}
		double operator*(){return pt->item;}
		iterator& operator++()  //for ++it
		{
			pt = pt->p_next;
			return *this;
		}
		iterator operator++(int)  //for it++
		{
			iterator tmp = *this;
			pt = pt->p_next;
			return tmp;
		}
//...opertor==(),opertor!=(),etc.		
};
</pre>

<p>The main point here is not how, in detail, to define the iterator class, but that with such a class, the second find function can be written like this:</p>
<pre>
iterator find_11(iterator begin, const double & val)
{
    for(start=head; start != 0; ++start)
        if(*start == val)
            return start;
	return 0;
}
</pre>

<p>This is very nearly the same as find_ar(). The point of difference is in how the two functions determine whether they've reached the end of the values being searched. The find_ar() function uses an iterator to one-past-the-end, whereas find_11() uses a null value stored in the final node. Remove that difference, and you can make the two functions identical. For example, you could require that the linked list have one additional element after the last officail element. That is, you could have both the array and the linked list have a past-the-end element, and you could end the search when the iterator reaches the past-the-end position. Then find_ar() and find_11() would have the same way of detecting the end of data and become identical algorithms. Note that requiring a past-the-end element moves from making requirements on iterators to making requirements on the container class.</p>

<p>The STL follows the approach just outlined. First, each container class(vector,list,deque,and so on) defines an iterator type appropriate to the class. For one class, the iterator might be a pointer; for another, it might be an object. Whatever the implementation, the iterator will provide the needed operations, such as * and ++. (Some classes may need more operations than others.) Next, each container class will have a past-the-end marker, which is the value assigned to an iterator when it has been incremented one past the last value in the container. Each container class will have begin() and end() methods that return iterators to the first element in a container and to the past-the-end position. And each container class will have the ++ operation take an iterator from the first element to past-the-end, visiting every container element en route.</p>

<p>To use a container class, you don't need to know how its iterators are implemented nor how past-the-end is implemented. It's enough to know that it does have iterators, that begin() returns an iterator to the first element, and that end() returns an iterator to past-the-end. For example, suppose you want to print the values in a vector&lt;double> oject. In that case, you cna use this:</p>
<pre>
vector&lt;double>::iterator pr;
for(pr=scores.begin(); pr != scores.end(); pr++)
    cout  &lt;&lt; *pr &lt;&lt;end;
</pre>
<p>Here the following line identifies pr as the iterator type defined for the</p>
<pre>
vector&lt;double> class;
vector&lt;double>::iterator pr;
</pre>
<p>If you used the list&lt;double> class template instead to scores, you could use this code:</p>
<pre>
list&lt;double>::iterator pr;
for(pr=scores.begin(); pr != scores.end(); pr++)
    cout  &lt;&lt; *pr &lt;&lt;end;
</pre>
<p>The only change is in the type declared for pr. Thus,by having each class define appropriate iterators and designing the classes in a uniform fashion, the STL lets you write the same code for containers that have quite dissimilar internal representations.</p>
<p>With C++ automatic type deduction, you can simplify further and use the following code with either the vector or the list:</p>
<pre>
for(auto pr=scores.begin(); pr != scores.end(); pr++)
    cout  &lt;&lt; *pr &lt;&lt;endl;
</pre>
<p>Actually, as a matter of style, it's better to avoid using the iterators directly; instead, if possible, you should use an STL function, such as for_each(), that takes care of the details for you. Alternatively, use the C++11 range-based for loop:
</p>
<pre>
for(auto x:scores) cout &lt;&lt;x &lt;&lt; endl;
</pre>
<p>So to summarize the STL approach, you start with an algorithm for processing a container. You express it in as general terms as possible, making it independent of data type and container type. To make the general algorithm work with specific cases, you define iterators that meet the needs of the algorithm and place requirements on the container design. That is, basic iterator properties and container properties stem from requirements placed on the algorithm.</p>
<h4>Kinds of iterators</h4>
<p>Different algorithms have different requirements for iterators. for example, a find algorithm needs the ++ operator to be defined so the iterator can step through the entire container. It needs read access to data but not write access.(It just looks at data and doesn't change it.) The usual sorting algorithm, on the other hand, requires random access so that it can swap two non-adjacent elements. If iter is an iterator, you can get random access by defining the + operator so that you can use expressions such as iter + 10. Also a sort algorithm needs to be able to both read and write data.</p>
<p>The STL defines five kinds of iterators and describes its algorithms in terms of which kinds of iterators it needs. The five kinds are the input iterator, output iterator, forward iterator, bidirectional iterator, and random access iterator. For example, the find() prototype looks like this:
</p>
<pre>
template&lt;class InputIterator, class T>
InputIterator find(InputIterator first, InputIterator last, const T& value);
</pre>
<p>This tells you that this algorithm requires an input iterator. Similarly, the following prototype tells you that the sort algorithm requires a random access iterator:</p>
<pre>
template&lt;class RandomAcessIterator, class T>
RandomAcessIterator find(RandomAcessIterator first, RandomAcessIterator last, const T& value);
</pre>
<p>All five kinds of iterators can be dereferenced(that is, the * operator is defined for them) and can be compared for equality(using the == opertor, possibly overloaded) and inequality(using the != operator, possibly overloaded). If two iterators test as equal, then dereferencing one should produce the same value as dereferencing the second. That is, if</p>
<p>iter1 == iter2</p>
<p>is true, then the following is also true:</p>
<p>*iter1 == *iter2</p>
<p>Of course, these properties hold true for built-in operators and pointers, so these requirements are guides for what you must do when overloading these operators for an iterator class. Now let's look at other iterator properties.</p>
<h4>Input Iterators</h4>
<p>The term input is used from the viewpoint of a program. That is, information going from the containor to the program is considered input, just as information from a keyboard to the program is considered input. So an input iterator is one that a program can use to read values from a container. In particular, dereferencing an input iterator must allow a program to read a value from a container, but it needn't allow a program to alter value. So algorithms that require an input iterator are algorithms that don't change values held in a container.</p>
<p>An input iterator has to allow you to access all the values in a container. It does so by supporting the ++ operator, both in prefix and suffix form. If you set an input operator to the first element in a container and increment it until it reaches past-the-end, it will point to every container item once en route. Incidentally there is no guarantee that traversing a container a second time with an input iterator will move through the values in the same order. Also after an input iterator has been incremented, there is no guarantee that its prior value can still be dereferenced. Any algorithm based on an input iterator, then, should be a single-pass algorithm that doesn't rely on iterator values from a previous pass or on earlier itertor values from the same pass.</p>
<p>Note that an input iteraotr is a one-way iterator; it can increment, but it can't back up.</p>
<h4>Output iterators</h4>
<p>In STL usage, the term output indicates that the iterator is used for transferring information from a program to a container.(Thus the output for the program is input for the container.) An output iterator is similar to an input iterator, except that dereferencing is graranteed to allow a program to alter a container value but not to read it. If the ability to write without reading seems strange, keep in mind that this property also applies to output sent to your display; cout can modify the stream of characters sent to the display, but it can't read what's onscreen. The STL is general enough that its containers can represent output devices, so you can run into the same situation with containers. Also if an algorithm modifies the contents of a container(for example, by generating new values to be stored) without reading the contents, there's no reason to require that it use an iterator that can read the contents.</p>
<p>In short, you can use an input iterator for single-pass, read-only algortithms and an output operator for single-pass, write-only algorithms.</p>
<h4>Forward Iterators</h4>
<p>Like input and output iterators, forward iterators use only the ++ operators for navigating through a container. So a forward iterator can only go forward through a container one element at a time. However, unlike input and output iterators, it necessarily goes through a sequence of values in the same order each time you use it. Also after you increment a forward iterator. you can still dereference the prior iterator value, if you've saved it, and get the same value. These properties make multiple-pass algorithms possible.</p>
<p>A forward iterator can allow you to both read and modify data, or it can allow you just to read it:</p>
<pre>
int * pirw; // read-write iterator
const int * pir; //read-only iterator
</pre>
<h4>Bidirectional Iterators</h4>

<p>Suppose you have an algorithm that needs to be able to traverse a containor in both directions. For example, a reverse function could swap the first and last elements, increment the pointer to the first element, decrement the pointer to a second element, and repeat the process. A bidirectional iterator has all the features of a forward iterator and adds support for the two decrement operators(prefix and postfix).</p>
<h4>Random Access Iterators</h4><p></p>

<p>Some algorthms, such as standard sort and binary search, require the ability to jump directly to an arbitrary element of a container. This is termed random access, and it requires a random access iterator. This type of iterator has all the features of a bidirectional iterator, plus it adds operations(such as pointer addition) that support random access and relational operators for ordering the elements.Below is the table that lists the operations a random access iterator has beyond those of a bidirectional iterator. In this table, X represent a random iterator type, T represents te type pointed to, a and b are iterator values, n is an integer, and r is a random iterator variable or reference.
</p>
<table cellspacing="0" cellpadding="0">
  <col width="78">
  <col width="518">
  <tr height="19">
    <td height="19" width="78">Expression</td>
    <td width="518">Description</td>
  </tr>
  <tr height="19">
    <td height="19">a+n</td>
    <td>Points to the nth element after the one a points to</td>
  </tr>
  <tr height="19">
    <td height="19">n+a</td>
    <td>Same as a+n</td>
  </tr>
  <tr height="19">
    <td height="19">a-n</td>
    <td>Points to the nth element before the one a points to</td>
  </tr>
  <tr height="19">
    <td height="19">r+=n</td>
    <td>Equivalent to r = r+n</td>
  </tr>
  <tr height="19">
    <td height="19">r-=n</td>
    <td>Equivalent to r = r-n</td>
  </tr>
  <tr height="19">
    <td height="19">a[n]</td>
    <td>Equivalent to *(a+n)</td>
  </tr>
  <tr height="19">
    <td height="19">b-a</td>
    <td>The value of n such that b == a+n</td>
  </tr>
  <tr height="19">
    <td height="19">a&lt;b</td>
    <td>Ture if b-a&gt;0</td>
  </tr>
  <tr height="19">
    <td height="19">a&gt;b</td>
    <td>Ture if b&lt;a</td>
  </tr>
  <tr height="19">
    <td height="19">a&gt;=b</td>
    <td>Ture if !(b&lt;a)</td>
  </tr>
  <tr height="19">
    <td height="19">a&lt;=b</td>
    <td>Ture if !(b&gt;a)</td>
  </tr>
</table>
<p>Expressions such as a + n are valid only if both a and a+n lie within the range of the container(including past-the-end).</p>

<h4>Iterator Hierarchy</h4>
<p>You have probably noticed that the iterator kinds form a hierarchy. A forward iterator has all the capabilities of an input iterator and of an output iterator, plus its own capabilities. A bidirectional iterator has all the capabilities of a forward iterator, plus its own capabilities. And a random access iterator has all the capabilities of a forward iterator, plus its own capabilities. Below is the table that summarizes the main iterator capabilities. In it, i is an iterator, and n is an integer.</p>

<table cellspacing="0" cellpadding="0">
  <col width="210">
  <col width="47">
  <col width="54">
  <col width="62">
  <col width="108" span="2">
  <tr height="19">
    <td height="19" width="210">Iterator    Capability</td>
    <td width="47">Input</td>
    <td width="54">Output</td>
    <td width="62">Forward</td>
    <td width="108">Bidirectional</td>
    <td width="108">Random Access</td>
  </tr>
  <tr height="19">
    <td height="19">Dereferencing read</td>
    <td>Yes</td>
    <td>No</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">Dereferencing write</td>
    <td>No</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">Fixed and repeatable order</td>
    <td>No</td>
    <td>No</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">++i i++</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">--i i--</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>Yes</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">i[n]</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">i + n</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">i - n</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">i += n</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>Yes</td>
  </tr>
  <tr height="19">
    <td height="19">i -+ n</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>No</td>
    <td>Yes</td>
  </tr>
</table>
<p>An algorithm written in terms of a particular kind of iterator can use the kind of iterator or any other iterator that has the required capabilities. So a container with, say, a random access iterator can use an algorithm written for an input iterator.</p>
<p>Why all these different kinds of iterator? The idea is to write an algorithm using the iterator with the fewest requirements possible, allowing it to be used with the largest range of containers. Thus, the find() function, by using a lowly input iterator, can be used with any container that contains readable values. The sort() function, however, by requiring a random access iterator, can be used just with containers that upport that kind of iterator.</p>
<p>Note that the various iterator kinds are not defined types; rather, they are conceptual characterizations. As mentioned earlier, each container class defines a class scope typedef name called iterator. So the vector&lt;int> class has iterators of type vector&lt;int>::iterator. But the documentation for this class would tell you that vector iterators are random access iterators. That, in turn, allows you to use algorithms based on any iterator type because a random access iterator has all the iterator capabilities. Similarly, a list&lt;int> class has iterators of type list&lt;int>::iterator. The STL implements a doubly linked list, so it uses a bidirectional iterator. Thus, it can't use algorithms based on random access iterators, but it can use algorithms based on less demanding iterators.</p>









