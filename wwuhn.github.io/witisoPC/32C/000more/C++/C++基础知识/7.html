<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>

<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}

#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}


#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>

</head>

<body>

<div id="container">





<h4>﻿C++基础知识第十天</h4>

<p>cpp软件架构狮 2018-07-23 13:14:59</p>

<h4>1.STL六大组件</h4>

<h4>2.STL三大组件：容器、算法、迭代器</h4>

<p>每一个容器都有自己的迭代器，迭代器用来遍历容器中的元素。</p>

<p>遍历：不重复的进行访问每个元素。</p>

<p>3.容器，迭代器，算法的初步使用。</p>

<p>1)先引入所需要的容器头文件和算法头文件</p>

<p></p>
<pre>
void Myprint( int val )
{
	算法 中 的回 调 函数 需 要自己写
	cout << val << " "; 内容 为 自己所想打印的内容
}


void test()
{
	vector<int > V;
	for ( int i = 0; i < 5; i++ )
	{
		V.push_back( i + 10 );
	}
	vector<int>::iterator	pBegin	= V.begin();
	vector<int>::iterator	pEnd	= V.end();
/* 直接使用迭代器进行容器的遍历 */
	while ( pBegin != pEnd )
	{
		cout << *pBegin << " ";
		pBegin++;
	}
	cout << endl;
/* 模拟算法的最后一个回调函数的使用 */
	pBegin = V.begin();
	while ( pBegin != pEnd )
	{
		Myprint( *pBegin );
		pBegin++;
	}
	cout << endl;
/* 使用算法遍历容器，并且打印出来。注意：算法的最后一个参数为回调函数，需要自己写（所想要打印的内从容） */
	for_each( V.begin(), V.end(), Myprint );
	cout << endl;
}
} ；
</pre>

<p>2）容器的分类：序列式容器和关联式容器</p>

<p>序列式容器：容器元素在容器中的位置由元素进入容器的时间和地点来决定。如：(vector，deque , list, stack, queue )</p>

<p>关联式容器：容器具有自己的规则，元素在容器中的位置由容器的规则来定。如(树状容器: set/mutilset; map/mutilmap )</p>

<p>3)每个容器都有自己的迭代器，由容器自己提供。</p>

<h4>3.string 容器：</h4>

<p>1）从 const char * 到 string 有隐式转换；反之则没有。</p>

<p>3.下标操作符： [] 和 at()方法。</p>

<p>两个的区别在于：1）[] 越界程序会直接挂掉， 2）at()方法越界程序会提供错误信息。</p>

<h4>4.vector 容器：</h4>

<p>1）连续的内存空间</p>

<p>2）单口</p>

<p>3）会实现内存空间动态增长（当已有内存占满时）；申请更大的空间，原来的空间析构，原来的迭代器会失效。</p>

<p>4）它的内存空间不会随着 clear()方法清除数据而消失的，只有当容器生命周期结束时，它的容量才会释放；</p>

<p>"所以当想在生命周期存在时减少或增大容器内存，可以使用 swap() 方法。"（如下）</p>

<p></p>
<pre>
void test04()
{
	vector<int> v;
	for ( int i = 0; i < 100000; i++ )
	{
		v.push_back( i );
	}
	cout << "capacity:" << v.capacity() << endl;
	cout << "size:" << v.size() << endl;
	v.resize( 3 );
	cout << "capacity:" << v.capacity() << endl; "注意容量与长度不一样，"
	cout << "size:" << v.size() << endl;
/*
 * 收缩内存
 * vector<int>(v).swap(v);
 */
	vector<int>( v ).swap( v ); /* 匿名对象 */
	cout << "capacity:" << v.capacity() << endl;
	cout << "size:" << v.size() << endl;
}
</pre>

<p>5）reserve的使用："预留空间"，在此空间还没有初始化时是不允许访问。可以通过push_back()插入元素后，进行访问。</p>

<p>6）resize的使用：开辟空间并且初始化，它的空间申请完后是可以访问的。</p>

<p>重新指定容器的长度为num，若容器变长，则默认值或指定值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除，"只是长度变短，但是容器的容量没有变化，"。</p>

<p>7）只要容器的容量产生变化，原来的迭代器就会失效。（如删除元素之后，原来的迭代器就不能用了）。</p>

<h4>5.迭代器的注意事项：</h4>

<p>1）"（当内存由于动态增长，更换地址后，原来的迭代器就失效了，不可以再使用）。"</p>

<p>2)只要能遍历容器中所有元素的，都是容器认可的迭代器。</p>

<p>3）每个容器的迭代器不一样，有自己的独立迭代器。</p>

<p>4） const_iterator 只读</p>

<p>reverse_iterator 逆序迭代器</p>

<p>iterator 最普通的正向迭代器</p>



<h4>6.迭代器的种类：5种。</h4>

<p>1）每个容器只提供一种</p>

<p>2）都是由对应的容器自己提供的迭代器。（因为每个容器的实现机制不一样）。</p>

<p>3）输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器</p>

<h4>6.vector 申请和释放空间的注意：</h4>

<p>尽量不要频繁申请和释放空间（太浪费时间）；可以先预测一下所用空间的大小，直接用reserve()申请足够大的空间，在逐步初始化。</p>

<h4>7.随机迭代器：（vector容器支持随机访问）</h4>

<h4>8.deque 容器：</h4>

<p>1）是一种双向开口，动态以分段连续内存空间组合而成，随时可以增加一块新内存的容量器。</p>

<p>2）可以在首尾两端分别作元素的删除和插入操作。</p>


<p><h4>1.栈容器(stack) ：元素先进后出，单口容器</h4></p>

<p>1)不提供迭代器；没有遍历功能</p>

<p>2）以其他的容器作为底层，它相当于提供接口</p>

<p>3）只有栈顶元素才可以被外界取用。所以想遍历容器，只能从栈顶开始，取出一个元素，就删除它，当遍历完后，容器也就没有元素了。</p>

<p><h4>2.队列容器（queue）：元素先进先出</h4></p>

<p>1）没有迭代器。不支持随机访问</p>

<p>2）两个出口，一个只进，一个只出。</p>

<p>3）和 stack 栈容器一样，遍历完后，容器的元素也被删除空。</p>

<p>3.（ stack 和 queue 容器叫受限的线性表）</p>

<p><h4>3.链表容器（list）：双向循环链表</h4></p>

<p>1）采用动态存储分配，不会造成内存浪费和溢出。</p>

<p>2）元素的插入和删除十分方便，修改指针即可。</p>

<p>3）list容器提供自己的排序算法；</p>

<p>4）list容器的排序（重点在回调函数的使用）</p>

<p>5）swap()既可以交换两个链表的数据，也可以动态的伸缩内存。</p>

<p><h4>4.set容器（红黑树，平衡二叉树的一种）</h4></p>

<p>1)<strong>它的元素既是键值又是实值</strong>，而且所有的元素都会自动排序。</p>

<p>2）不允许两个元素有相同的键值。</p>

<p>3)不允许通过迭代器修改元素的值。</p>

<p>4）与list有某些相同的性质，当对容器中的元素进行插入和删除操作时，操作之前的所有迭代器，在完成操作完成后都是有效的，除了被删除的那个元素的迭代器</p>

<p><h4>5.multiset容器：</h4></p>

<p>1）特性和set一样，唯一区别在于它允许键值重复。</p>

<p><h4>6.算法的默认排序原则</h4></p>
<p>都是由小到大；如果想从大到小，就需要自己建立一个回调函数</p>

<p><h4>7.对组( pair )</h4> </p>
<p>将一对值组合成一个值，这一对值可以具有不同的数据类型。两个值可以分别用对组的公有属性 first 和 second 访问。</p>
<p>创建对组的两种方式：</p>

<p>1）pair<string ,int> pair1("xiaobai",20); cout<< pair1.first <<endl; cout<< pair1.second <<endl;</p>

<p>2)pair<string, int> pair2 = make_pair("xiaohong",23); cout<< pair2.first <<endl; cout<< pair2.second <<endl;</p>

<p>3)pair<string, int> pair3 = pair2; cout<< pair3.first <<endl; cout<< pair3.second <<endl;</p>

<p><strong>8.map 容器：(它的所有元素都是一个对组)</strong></p>

<p>1）键值对；键值不可以相同，实值可以相同。所有的元素都会根据键值自动排序。</p>

<p>2）插入元素的四种方式：</p>
<p>map<int , int> m;</p>

<p>m.insert(pair<int, int>(1, 2));</p>

<p>m.insert(make_pair(2, 2));</p>

<p>m.insert(map<int, int>::value_type(3, 2));</p>

<p>m[4] = 4;</p>

<p>3）如果通过[] 访问一个不存在的key值，那么编译器会创建一个，实值为默认值。</p>

<p>4）map的迭代器与普通容器不同。是一个对组迭代器。可以通过迭代器修改实值的值，不可以修改键值的值。</p>

<p>5）map的迭代器与list迭代器有某些相同的性质，对容器元素进行插入和删除时，操作之前的所有迭代器在操作完成之后不会失效，当然那个被删除的元素迭代器除外。</p>

<p>6）指定map 的排序规则：（因为它的元素为对组，所以排序规则需要自己写函数确定）</p>

<p><h4>9.multimap容器：</h4></p>

<p>与map 容器操作类似，唯一不同在于它的键值可以相同。</p>

<p><strong>10.如何判断容器支持随机访问（或提供随机迭代器）：</strong></p>

<p>只需要看容器提供的迭代器能否 +2，+3</p>

<p>vector<int>::iterator it = v.begin(); it = it+3;(可以，提供随机迭代器)</p>

<p>queue<int>::iterator it = q.begin(); it = it+2;(不可以向后跳跃，不提供随机迭代器)。</p>

<p><h4>11.STL中，所有的拷贝都是值寓意，所提供的内容必须是可以拷贝的。</h4></p>

<p>1）此时就涉及到深拷贝和浅拷贝的问题；当由指针存在，而且它指向堆内存时，用容器提供的拷贝只会复制指针的指向，并没有拷贝到指针所指向的数据。</p>

<p>当生命周期结束，进行空间析构时，就会出现同一块内存二次析构，程序挂掉。</p>

<p>2）必须自己重载一个深拷贝函数（和类的函数重载一样；(一般都是：一个拷贝函数和一个重载=号操作函数)。</p>

<p><h4>12.STL使用的时机</h4></p>

<p><h4>1.容器中的 find()函数默认区分大小写，而且返回值为迭代器.</h4></p>

<p><h4>2.仿函数：重载函数调用操作符的类，其对象成为函数对象，也叫仿函数。</h4></p>

<p>1）仿函数是一个类，不是一个函数。重载了()</p>

<p>2）仿函数重载了()操作符，使得函数对象可以像函数一样使用。</p>

<p>3）重载的operator()需要一个参数的，这样的类对象称为 "一元仿函数"； 依次类推。</p>

<p><h4>3.预定义函数对象：（实现了数据类型与算法的分离。）</h4></p>

<p>1）plus<int> p; 预定义好的函数对象，能实现不同类型数据的 + 运算。</p>



<p><h4>3.函数没有类型，不能定义变量。函数对象有类型，因为他是一个类。</h4></p>

<p<h4>>4.函数对象与普通函数的区别：</h4></p>

<p>1）函数对象超出了普通函数的概念，可以保存函数的调用状态</p>

<p>2）函数对象可以做参数和返回值</p>

<p><h4>5.谓词：</h4></p>

<p>1）普通函数或重载的operator()"返回值为bool 类型"的函数对象（仿函数）。</p>

<p>2）一个参数的叫一元谓词，以此类推。</p>

<p><h4>6.兰博打函数表达式： vector<int> v1;</h4></p>

<p>for_each(v1.begin(), v1.end(), [](int val){ cout<< val<<" "; });</p>

<p>for_each(v1.begin(), v1.end(), [](int val)->void{ cout<< val<<" "; });</p>

<p><h4>7.内建函数对象</h4></p>



<p>template<class T> T plus<T>//加法仿函数</p>

<p>template<class T> T minus<T>//减法仿函数</p>

<p>template<class T> T multiplies<T>//乘法仿函数</p>

<p>template<class T> T divides<T>//除法仿函数</p>

<p>template<class T> T modulus<T>//取模仿函数</p>

<p>template<class T> T negate<T>//取反仿函数</p>



<p><h4>7.函数对象适配器：</h4></p>

<p>1). 让自己编写的函数对象继承基类,如果是一元函数对象需要继承unary_function,</p>

<p>如果是二元函数对象继承binary_function</p>

<p>2). 函数对象operator()函数后增加 const</p>

<p>3). 使用bind2nd bind1st(将一个二元函数对象转变为一元函数对象)，</p>

<p>区别为： bind1st: 将参数绑定为函数对象的第一个参数 bind2nd: 将参数绑定为函数的第二个参数。</p>

<p>4）for_each()：遍历打印容器内容。返回值为最后一个函数对象的类型。</p>

<p>6）取反适配器</p>

<p>find_if()：查找容器中有无所寻找的内容，返回值为查找类型的迭代器。</p>

<p>对一元函数对象、谓词取反用 not1; 对二元函数对象、谓词取反用 not2;</p>

<p>7）给普通函数绑定参数(需要：先把一个普通的函数指针适配成函数对象)</p>

<p>ptr_fun函数指针适配器：把一个普通函数指针适配为函数对象。</p>

<p>void Myprint(int val1, int val2){ cout<< val1 + val2 <<" "; }</p>

<p>void main() { for_each(v1.begin(), v1.end(), bind2nd(ptr_fun(Myprint), 200)); }</p>

<p>8）成员函数适配器(mem_fun_ref:容器中存放的为对象实体。)（mem_fun：容器中存放的为对象指针。）</p>

<p>vector<person> v1; person p1("aaa", 10); v1.push_back(p1);</p>

<p>for_each(v1.begin(), v1.end(), mem_fun_ref(&person::showperosn));</p>

<p>vector<person*> v1; v1.push_back(&p1);</p>

<p>for_each(v1.begin(), v1.end(), mem_fun(&person::showperosn));</p>

<p><h4>8.算法：</h4></p>

<p>遍历算法：</p>

<p>1）for_each算法：第三个参数，接受的函数类型。</p>

<p>2）transform；</p>

<p>查找算法</p>

<p>1）find(查找元素或对象) 与 find_if（查找指针所指向的内容）</p>

<p>2）adjacent_find查找相邻重复元素</p>

<p>3）binary_search(二分查找法)，需要查找的容器元素有序排列</p>

<p>4）count 与 count_if (统计容器中元素的个数)</p>

<p>排序算法</p>

<p>1）合并两个有序序列（merge）两个序列必须是有序的。且顺序应该一样（或从小大，或从大到小，两种方式参数有点区别，默认从小到大，从大到小需要额外添加函数对象）</p>

<p>2) sort算法（条件：容器必须支持随机访问）</p>

<p>3）random_shuffle（打乱容器中的顺序）</p>

<p>4）reverse （反转）</p>



<p>拷贝和替换算法</p>

<p>1）copy (拷贝)</p>

<p>2）replace（替换）把所有要替换的值都替换成目标值。</p>

<p>3）replace_if</p>

<p>4) swap</p>

<p>算数生成算法</p>

<p>1）accumulate （累加容器中元素）</p>

<p>2）fill（填充）</p>

<p>3）</p>

<p>集合算法</p>

<p>1）set_intersection (求交集) 注意它的返回值。</p>

<p>2）set_union (求并集)</p>

<p>3）set_difference (差集);</p>




</div>

<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 31){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}

</script>
</div>

</body>
</html>