<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>CPP之编码问题（Unicode，ASCII，本地默认）</h4>


<p>&lt;a href="https://www.cnblogs.com/wynn518/p/8981203.html"&gt;本篇文章&lt;/a&gt;试图回答的问题：</p>
<p>1、char* pStr="我aａ";这句代码执行后，pStr指向的内存区域中存储的字节到底是根据什么码表而来的呢？该字符串占几个字节？</p>
<p>2、将一个VS2010的Windows程序设置了“使用Unicode字符集”到底意味着什么？</p>
<p>3、现在有一个文件，其存储内容未知（可能是文本，可能是图像，可能是视频），要求是：在文件最前面插入一串Unicode文本，插入完成后以文本程序打开该文件，插入的文本不会显示为乱码（该文件本身的内容不考虑）。——如何做到？</p>
<p>本人能力、精力有限，所言所感都基于自身的实践和有限的阅读、查阅，如有错误，欢迎拍砖，敬请赐教——博客园：钱智慧。</p>
<p>一：</p>
<p>用VS2010新建一个win32控制台应用程序TestChar，代码如下：</p>

<pre>
 1 #include &lt;iostream>
 2 using namespace std;
 3 int main()
 4 {
 5     char* pStr="我aａ";
 6     cout&lt;&lt;sizeof("我aａ")&lt;&lt;endl;
 7     cout&lt;&lt;hex&lt;&lt;pStr[0]-0;
 8     cout&lt;&lt;pStr[1]-0&lt;&lt;endl;
 9     return 0;
10 }
</pre>
<p>打印结果如下：</p>
<pre>
6
ffffffceffffffd2</pre>
<p>分析：存储介质（内存、外存等）上存储的都是二进制数据，而对于字符信息的存储，先查码表进行解码，再把码以二进制信息存储，即pStr指向的这段内存中存储的都是字符们的编码：一个中文字符，一个英文字母，一个全角字母。要得到”我“的编码，默认会查找本地码表，本人是中文Win7系统，查找的是GB2312码表，而对照GB2312码表可发现，"我"的编码正是ced2，与打印一致（f是符号位，可无视）。另外GB2312是不会对英文字母进行编码的，因为英文字母属于半角字符，这类编码由ASCII码表负责，GB2312中的任何字符都占用两个字节，空字符也由ASCII负责编码，这就是为何上面的字符串占用的字节数目是6。可见，上面一句代码，其实涉及到了两张码表：ASCII码表和GB2312。</p>
<p>二：</p>
<p>新建一个MFC对话框程序，名为TestUnicodeChar。默认情况下，VS2010建的项目都是基于Unicode的，即打开项目的属性，在”字符集“设置中都是”使用Unicode字符集“，这到底是什么意思呢？莫非在程序中用的中文都是以Unicode字节进行存储的？由上面的TestChar程序可以看出并非如此，pStr中的"我”是以GB2312进行存储的。又或者，源文件（h文件、cpp文件等）在磁盘上是以Unicode进行编码存储的？也不是，源文件存储默认也是以本地GB2312进行存储的。验证方式：用UE编辑器随便打开一个设置了“使用Unicode字符集”项目的某个源文件，比如打开本项目中的TestUnicodeCharDlg.cpp文件，在UE中以16进制的形式查看该文件内容，可以发现其前两个字节并非FF FE（这是Unicode文件的标识），你随便找一个中文，对照其16进制找到其编码，然后跟GB2312码表中的该中文的编码对照即可验证。这是一个GB2312码表的网页链接：</p>
<p>http://tool.xker.com/gb2312tbl.php </p>
<p>我们知道，在C++中，有char和string，为了支持Unicode字符，还有wchar_t和wstring，我们可以认为string是基于char的，而wstring是基于wchar_t的。为什么要引入Unicode呢，只用char和string难道不能保存含有中文的字符（串）吗？由TestChar程序，我们知道完全可以，并且采用的是GB2312编码，问题是你无法确定一个类似pStr的混合串的字符数目，比如：string str="我a"，你调用string的length方法不能准确得到str的长度，这给编程带来了不便。所以你可以选用wstring和wchar:wstring wstr=L"我a"，这时你再调用wstring的length方法就能准确得到了，其中L前缀可以使后面紧跟的字符串解释成宽字符串（Unicode）。因为Unicode对任何字符都采用2个字节进行编码，所以length的实现想必也很简单：每两个字节算一个字符，进而可以方便得到字符串的长度，这便是Unicode优于多字节编码的地方：试想，如果采用多字节编码，那么要实现基于这种编码的字符串类的length方法会非常头疼。Unicode浪费了存储空间但带来了编程上的简便。（关于这方面的详细内容可以参考《Windows程序设计 第5版》第1章）</p>
<p>在Windows中，有这样一些宏：_T,TEXT,TCHAR,CString，它们根据不同的设定有不同的含义。先看一下它们的使用:</p>
<p>在TestUnicodeCharDlg.cpp的OnPaint方法中加上如下代码：</p>
<p>1 TCHAR * pStr=TEXT("a我");//_T与TEXT的含义是一样的</p>
<p>2 CString str1=TEXT("a我");</p>
<p>3 CString str2=L"a我";</p>
<p>如果程序定义了UNICODE宏，则_T和TEXT（二者含义和用法完全一样）便会把括号内的字符串解释为UNICODE字符串，TCHAR便会替换为wchar_t，CString便会替换为CStringW，否则（即没有定义UNICODE宏），都会解释为相应的char版本。而L前缀不是宏，类似强转：不管有没有定义UNICODE宏，都把后面的字符串解释为UNICODE字符串。而设置“使用UNICODE字符集”就相当于定义UNICODE宏，即该设置仅仅是影响了一些宏的行为。若把该项目的“使用Unicode字符集”设置改为“未使用”，则编译会出错，因为此时str2就是一个CStringA实例，你不能把一个L前缀的字符串（Unicode字符串）赋值给它。</p>
<p>三：</p>
<p>第三个问题本质上就是往一个文件中写Unicode字符串的问题。涉及到编码问题的文件操作始终牢记一点：以什么编码写，就以编码读。在TestUnicodeChar程序的OnInitDialog函数中加入如下代码：</p>
<pre>
 1 BOOL CTestUnicodeCharDlg::OnInitDialog()
 2 {
 3     CDialogEx::OnInitDialog();
 4 
 5     // 将“关于...”菜单项添加到系统菜单中。
 6 
 7     // IDM_ABOUTBOX 必须在系统命令范围内。
 8     ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
 9     ASSERT(IDM_ABOUTBOX < 0xF000);
10 
11     CMenu* pSysMenu = GetSystemMenu(FALSE);
12     if (pSysMenu != NULL)
13     {
14         BOOL bNameValid;
15         CString strAboutMenu;
16         bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
17         ASSERT(bNameValid);
18         if (!strAboutMenu.IsEmpty())
19         {
20             pSysMenu->AppendMenu(MF_SEPARATOR);
21             pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
22         }
23     }
24 
25     // 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
26     //  执行此操作
27     SetIcon(m_hIcon, TRUE);            // 设置大图标
28     SetIcon(m_hIcon, FALSE);        // 设置小图标
29 
30     // TODO: 在此添加额外的初始化代码
31     CFile myFile;
32 
33 
34     if ( myFile.Open( _T("c:\\myfile.txt"), CFile::modeCreate |   
35         CFile::modeReadWrite ) )
36     {
37 
38         CString str=TEXT("a我");
39         //myFile.Write("\xff\xfe",2);
40         myFile.Write( str, str.GetLength()*sizeof(TCHAR) ); 
41         myFile.Flush();
42     }
43     
44 
45     return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
46 }
</pre>
<p>运行程序，然后用写字板、记事本、NotePad++、UE（UEdit）分别打开mfile.txt发现，有的能正常显示，有的则乱码。要知道，你往myfile.txt写进去的是 两个字符的Unicode编码，用某文本程序去打开myfile.txt，倘若该程序默认情况下读取文本时是按Unicode来解析的，则不会乱码，否则就乱码。我们把注释的那行代码的注释拿掉，用任何支持Unicode的文本程序去打开myfile.txt就不会出错了，因为一个文本中的前两个字节FF FE便向试图打开该文本的程序表明该文本应该用Unicode进行解析（你可以用NotePad++新建几个Unicode格式的文本，随便保存几个字符，然后用UE以16进制格式查看便可知Unicode文本的前两个字节都是FF FE）。</p>
<p>另外，经常遇到有人问这样的问题：CString如何转换为char*？问这个问题之前，最好问下自己：我的目的是什么，为何要进行这样的转换，当前项目有没有设置Unicode。要知道，如果设置了Unicode，则CString存储的是Unicode字符串，转换为char*后，你如果直接显示这个char*或者写到文件中（没有把FF FE写到文件开始处）然后打开，则会（假如打开文件的程序默认不以Unicode进行解析）出现乱码，所以，这种情况下，转换为char*的意义不大——这不是说不能把Unicode串转为char*，这完全是可行的，本质上这只是在把一个Unicode字符串的内存内容"活生生”取出来而已。不管怎样，下面的代码重新修改了OnInitDialog函数，演示了几种情况：</p>
<pre>
 1 BOOL CTestUnicodeCharMFCDlg::OnInitDialog()
 2 {
 3     CDialogEx::OnInitDialog();
 4 
 5     // 将“关于...”菜单项添加到系统菜单中。
 6 
 7     // IDM_ABOUTBOX 必须在系统命令范围内。
 8     ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
 9     ASSERT(IDM_ABOUTBOX < 0xF000);
10 
11     CMenu* pSysMenu = GetSystemMenu(FALSE);
12     if (pSysMenu != NULL)
13     {
14         BOOL bNameValid;
15         CString strAboutMenu;
16         bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
17         ASSERT(bNameValid);
18         if (!strAboutMenu.IsEmpty())
19         {
20             pSysMenu->AppendMenu(MF_SEPARATOR);
21             pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
22         }
23     }
24 
25     // 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
26     //  执行此操作
27     SetIcon(m_hIcon, TRUE);            // 设置大图标
28     SetIcon(m_hIcon, FALSE);        // 设置小图标
29 
30     // TODO: 在此添加额外的初始化代码
31     CFile myFileW,myFileA,myFileCharArrow,myFileWOrA;
32 
33 
34     if ( myFileW.Open( _T("c:\\myfileW.txt"), CFile::modeCreate |   
35         CFile::modeReadWrite )  && 
36         myFileA.Open( _T("c:\\myfileA.txt"), CFile::modeCreate |   
37         CFile::modeReadWrite ) &&
38         myFileCharArrow.Open( _T("c:\\myfileCharArrow.txt"), CFile::modeCreate |   
39         CFile::modeReadWrite ) &&
40         myFileWOrA.Open( _T("c:\\myFileWOrA.txt"), CFile::modeCreate |   
41         CFile::modeReadWrite ))
42     {
43 
44         CString strW=TEXT("a我");//因为本项目设置了Unicode字符集，所以我们知道CString会被替换为CStringW
45         
46         CStringA strA(strW);
47         
48 
49         myFileW.Write( strW, strW.GetLength()*2); 
50         myFileW.Flush();
51 
52         myFileA.Write(strA,strA.GetLength());
53         myFileA.Flush();
54         //CString的GetString返回的const类型指针，要么在右边强转，要么左边用const类型的char*去接
55         //注意指针命名：p是pointer，c是const，如果有t则是TEXT，w是wide,l是long
56         char* pstr=(char*)strA.GetString();
57         /*下面这行代码若不注掉，会报错，因为本程序是Unicode程序，
58         strW会是一个CStringW类型的字符串，它的GetString返回的是LPCWSTR类型指针
59         当然不能赋值给LPCSTR类型指针了，一个是const wchar_t*，另一个是const char*
60         */
61         //const char* pcstr1=strW.GetString();
62         
63         myFileCharArrow.Write(pstr,strlen(pstr));
64         myFileCharArrow.Flush();
65 
66         //假设我们在编程中，不知道有没有使用Unicode设置，为了通用，我们可以尽量使用宏及通用版本的相关函数（如_tcslen)
67         CString strWOrA=TEXT("a我");
68         //注意这里的TCHAR不一定就是wchar_t，这取决于程序是否设置了Unicode
69         const TCHAR* pctstr=strWOrA.GetString();//CString的GetString返回的是const指针
70         myFileWOrA.Write(ptstr,_tcslen(pctstr)*sizeof(TCHAR));
71         myFileWOrA.Flush();
72 
73     }
74     
75 
76     return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
77 }
</pre>
<p>用UE察看几个文件的内容，如图：</p>
<p>其中，CED2是”我“的GB2312编码，6211（注意字节高低次序）是”我“的Unicode编码，我们可知，CStringA strA(strW)这行代码，一定进行了码表间的转换。结合代码，文件内容应该不难理解。</p>
<p>还有些让人容易头晕的字符串指针宏，下面列举出来：</p>
<p>关于char*的：</p>
<p>LPCSTR: long pointer const string，可看成const char*，与PCSTR相似</p>
<p>LPSTR：可看成char*，与PSTR相似</p>
<p>关于wchar_t*的：</p>
<p>LPCWSTR，PCWSTR，LPWSTR，PWSTR</p>
<p>通用版本（根据是否配置了Unicode有不同的宏替换）：</p>
<p>TCHAR*</p>
<p>LPTSTR,LPCTSTR (T有点类似TEXT宏的意思）</p>
</pre>

<p style='float:right;'>本页共180段，8019个字符，13388 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
