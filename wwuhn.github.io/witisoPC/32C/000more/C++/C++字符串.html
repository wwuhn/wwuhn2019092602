<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script language="javascript"> 
//bg_even("表格ID属性名","奇数行背景色","偶数行背景色","鼠标经过背景色","点击后背景色");
function bg_even(o,a,b,c,d){
        var t=document.getElementById(o).getElementsByTagName("tr");
        for(var i=0;i<t.length;i++){
                t[i].style.backgroundColor=(t[i].sectionRowIndex%2==0)?a:b;
                t[i].onclick=function(){
                        if(this.x!="1"){
                                this.x="1";
                                this.style.backgroundColor=d;
                        }else{
                                this.x="0";
                                this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                        }
                }
                t[i].onmouseover=function(){
                        if(this.x!="1")this.style.backgroundColor=c;
                }
                t[i].onmouseout=function(){
                        if(this.x!="1")this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                }
        }
}

 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title></title>

<style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.6em;
}
P{
margin:16px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 100px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 70px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#goBottom:hover{
background-color:white;
border:#ccc 1px solid;
color:red;
}
 
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}
.floatr{
float:right;
padding-right:5px;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
img{
border:0;
}
.picsay{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
}
.code0{
color:red;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:0em;
}
.code2{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:2em;
}
.code4{
color:blue;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:4em;
}
sub,sup{
font-size:80%;
color:red;
}
</style>
</head>

<body> 
<div class="container">
<!--
<table id="tbrowser">
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
-->

<!--
height="*\w*"
width="*\w*"
</p>
<p>
-->


<table id="tbrowser">
<col width="10%" />
<col width="10%" />
<col width="30%" />
<col width="50%" />
  <tr>
    <td>类型</td>
    <td>语言</td>
    <td>需要包含的头文件</td>
    <td>说明</td>
  </tr>
  <tr>
    <td>char*</td>
    <td>C</td>
    <td>#include &lt;iostream&gt;<br />
using namespace std;</td>
    <td>一个指向字符或字符串的指针，是一个内置类型；</td>
  </tr>
  <tr>
    <td>string </td>
    <td>C++</td>
    <td>#include &lt;string&gt;</td>
    <td>C++标准库(STL)中的一个类；</td>
  </tr>
  <tr>
    <td>CString</td>
    <td>MFC</td>
    <td>#include &lt;afx.h&gt;</td>
    <td>MFC定义的一个类；</td>
  </tr>
</table>
<p><string.h>是C版本的头文件，包含比如strcpy、strcat之类的字符串处理函数。</p>
<p>从灵活度来说，string最灵活易用，其次是CString，char*的拓展性和灵活性比较差。一般来说在基于标准库开发时用string，在在MFC和ATL编程时用CString。</p>
<p>CString、string之间的转换基本上都是通过char*作为桥梁，因为char*既可以方便地转换成string，也可以方便地转换成CString。</p>
<h4>char*</h4>
<p>char*是一个指向字符的指针，是一个内置类型。可以指向一个字符，也可以表示字符数组的首地址（首字符的地址）。我们更多的时候是用的它的第二的功能，来表示一个字符串，功能与字符串数组char ch[n]一样，表示字符串时，最后有一个 '\0'结束符作为字符串的结束标志。</p>
<p class="code2">#include &lt;iostream&gt;</P>
<p class="code2">using namespace std;</P>
<p class="code2">void testCharArray()</P>
<p class="code2">{</P>
<p class="code2">char ch1[12] = &quot;Hello Wrold&quot;; //这里只能ch1[12]，ch1[11]编译不通过,提示array bounds overflow</P>
<p class="code2">char *pch1 , *pch2 = &quot;string&quot;;</P>
<p class="code2">char *pch3, *pch4;</P>
<p class="code2">pch3 = &amp;ch1[2]; //ch1[2]的地址赋给pch3</P>
<p class="code2">char ch = 'c';</P>
<p class="code2">pch4 = &amp;ch;</P>
<p class="code2">pch1= ch1;</P>
<p class="code2">cout &lt;&lt; ch1 &lt;&lt; endl;    //输出ch1[0]到\0之前的所有字符</P>
<p class="code2">cout &lt;&lt; pch1 &lt;&lt; endl;   //输出ch1[0]到\0之前的所有字符</P>
<p class="code2">cout &lt;&lt; pch2 &lt;&lt; endl;   //输出ch1[0]到\0之前的所有字符</P>
<p class="code2">cout &lt;&lt; pch3 &lt;&lt; endl;   //输出ch1[2]到\0之前的所有字符</P>
<p class="code2">cout &lt;&lt; *pch3 &lt;&lt; endl;  //解引用pch3输出pch3指向的字符</P>
<p class="code2">cout &lt;&lt; *pch4 &lt;&lt; endl;  //解引用pch4输出pch4指向的字符</P>
<p class="code2">}</p>
<p><strong>结果为：</strong></p>
<p class="code2">Hello Wrold</p>
<p class="code2">Hello Wrold</p>
<p class="code2">string</p>
<p class="code2">llo Wrold</p>
<p class="code2">l</p>
<p class="code2">C</p>
<h3 id="string-">string</h3>
<p>string是C++标准库(STL)中的类型，它是定义的一个类，定义在头文件中。里面包含了对字符串的各种常用操作，它较char*的优势是内容可以动态拓展，以及对字符串操作的方便快捷，用+号进行字符串的连接是最常用的操作。</p>
<p>string类和char*比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 = 进行赋值操作，== 进行比较，+ 做串联。我们尽可以把它看成是C++的基本数据类型。</p>
<p class="code2">#include &lt;string&gt;</P>
<p class="code2">void testString()</P>
<p class="code2">{</P>
<p class="code2">string s1 = &quot;this&quot;;</P>
<p class="code2">string s2 = string(&quot; is&quot;);</P>
<p class="code2">string s3, s4;</P>
<p class="code2">s3 = string(&quot; a&quot;).append(&quot;string.&quot;);</P>
<p class="code2">s4 = s1 + s2 + s3;</P>
<p class="code2">cout &lt;&lt; s1 &lt;&lt; endl;</P>
<p class="code2">cout &lt;&lt; s2 &lt;&lt; endl;</P>
<p class="code2">cout &lt;&lt; s3 &lt;&lt; endl;</P>
<p class="code2">cout &lt;&lt; s4 &lt;&lt; endl;</P>
<p class="code2">cout &lt;&lt; s4.size() &lt;&lt; endl;</P>
<p class="code2">s4.insert(s4.end()-7, 1, ' ');</P>
<p class="code2">cout &lt;&lt; s4 &lt;&lt; endl;</P>
<p class="code2">}</p>
<p><strong>结果为：</strong></p>
<p class="code2">this</p>
<p class="code2"> is</p>
<p class="code2"> astring.</p>
<p class="code2">this is astring.</p>
<p class="code2">16</p>
<p class="code2">this is a string.</p>
<h3 id="cstring">CString</h3>
<p>CString常用于MFC编程中，是属于MFC的类，如从对话框中利用GetWindowText得到的字符串就是CString类型，CString定义在头文件中。CString（typedef CStringT&gt; CString）为Visual C++中最常用的字符串类，继承自CSimpleStringT类，主要应用在MFC和ATL编程中，所以使用CString时要包含afx.h文件#include 。</p>
<p class="code2">#include &lt;afx.h&gt;</P>
<p class="code2">//因为CString不是标准C++库定义的类型，没有对&lt;&lt;运算符进行重载，</P>
<p class="code2">//所以不能通过cout&lt;&lt;cstr来输出内容，只能自己先定义一个方法。</P>
<p class="code2">void printCString(const CString &amp;cstr);</P>
<p class="code2">void testCString()</P>
<p class="code2">{</P>
<p class="code2">char *ch = &quot;Hello&quot;;</P>
<p class="code2">string s = &quot;Wrold&quot;;</P>
<p class="code2">CString cstr1(ch), cstr2(s.c_str()), cstr3(&quot;Program&quot;);</P>
<p class="code2">printCString(cstr1);</P>
<p class="code2">printCString(cstr2);</P>
<p class="code2">printCString(cstr3);</P>
<p class="code2">CString cstr4, cstr5;</P>
<p class="code2">cstr4 = cstr1 + cstr2 + cstr3;</P>
<p class="code2">cstr5 = cstr1 + &quot; &quot; + cstr2 + &quot; &quot; + cstr3;</P>
<p class="code2">printCString(cstr4);</P>
<p class="code2">printCString(cstr5);</P>
<p class="code2">}</p>
<p class="code2">void printCString(const CString &amp;cstr) </P>
<p class="code2">{</P>
<p class="code2">int n = cstr.GetLength();</P>
<p class="code2">for(int i=0; i&lt;n; i++)</P>
<p class="code2">{</P>
<p class="code2">printf(&quot;%c&quot;, cstr[i]);</P>
<p class="code2">}</P>
<p class="code2">printf(&quot;\n&quot;);</P>
<p class="code2">}</p>
<p><strong>结果为：</strong></p>
<p class="code2">Hello</p>
<p class="code2">Wrold</p>
<p class="code2">Program</p>
<p class="code2">HelloWroldProgram</p>
<p class="code2">Hello Wrold Program</p>
<p>更多关于CString的用法请参考：<a href="http://www.cnblogs.com/Caiqinghua/archive/2009/02/16/1391190.html">http://www.cnblogs.com/Caiqinghua/archive/2009/02/16/1391190.html</a></p>
<p><strong>使用CString时可能会遇到的一些错误：</strong></p>
<p>编译时会发现类似如下错误：</p>
<p>Building MFC application with /MD[d] (CRT dll version) requires MFC shared dll version.<br />
Please #define _AFXDLL or do not use /MD[d] C:\Program Files (x86)\<br />
Microsoft Visual Studio 8\VC\ce\atlmfc\include\AFX.h 24</p>
<p><strong>解决方法：</strong></p>
<p>(注：我用的开发环境是VS2010,其它VS的环境类似操作)</p>
<p><strong>方法1</strong>：这里错误提示的意思是缺少_AFXDLL这个宏，因此在Project——&gt;property中，C/C++里面Preprocessor(预编译)，加入_AFXDLL这个宏，OK搞定！！</p>
<p><strong>方法2</strong>：对着你的项目点击右键，依次选择：属性、配置属性、常规，然后右边有个“项目默认值”，下面有个MFC的使用，选择“在共享 DLL 中使用 MFC”，就OK了～～～</p>
<p>参考文章：<a href="http://blog.csdn.net/ahjxly/article/details/8465209">http://blog.csdn.net/ahjxly/article/details/8465209</a></p>
<p><a href="http://blog.csdn.net/zhoxier/article/details/7929920">http://blog.csdn.net/zhoxier/article/details/7929920</a></p>
<p>讲明白了char*、string及CString的关系，可能有人对、、这几个头文件又糊涂了，由于篇幅的原因，这部分的内容将在下一节进行说明，欢迎阅读：《<a href="http://blog.csdn.net/luoweifu/article/details/20242307"> 与、的区别</a>》</p>
<h2 id="u76F8u4E92u7684u8F6Cu6362">相互的转换</h2>
<p>既然这三种类型都可用于表示字符串，但又是不同的类型，那他们如何转换呢？可用的方法参见如下：</p>
<h3 id="char-string-">char*与string的转换</h3>
<p class="code2">void pCharToString()</P>
<p class="code2">{</P>
<p class="code2">//from char* to string</P>
<p class="code2">char * ch = &quot;hello world&quot;;</P>
<p class="code2">string s1 = ch; //直接初始化或赋值</P>
<p class="code2">string s2(ch), s3;</P>
<p class="code2">s3 = string(ch);</P>
<p class="code2">cout &lt;&lt; s1 &lt;&lt; endl;</P>
<p class="code2">cout &lt;&lt; s2 &lt;&lt; endl;</P>
<p class="code2">cout &lt;&lt; s3 &lt;&lt; endl;</P>
<p class="code2">//from string to char*</P>
<p class="code2">string str = string(&quot;string is commonly used.&quot;);</P>
<p class="code2">/*************************************************************************</P>
<p class="code2">其实没有很大的必要将string转换成char*,因为string可以直接当成字符数组来使用，</P>
<p class="code2">即通过下标来访问字符元素，如str[1]表示第1个字符't'</P>
<p class="code2">**************************************************************************/</P>
<p class="code2">const char *ch1 = str.c_str(); </P>
<p class="code2">cout &lt;&lt; ch1 &lt;&lt; endl;</P>
<p class="code2">}</p>
<p><strong>结果为：</strong></p>
<p class="code2">hello world</p>
<p class="code2">hello world</p>
<p class="code2">hello world</p>
<p class="code2">string is commonly used.</p>
<h3 id="char-cstring">char*与CString</h3>
<p class="code2">void pCharToCString()</P>
<p class="code2">{</P>
<p class="code2">//from char* to CString</P>
<p class="code2">char *ch = &quot;char pointer.&quot;;</P>
<p class="code2">CString cStr1 = ch;</P>
<p class="code2">CString cStr2 = CString(ch);</P>
<p class="code2">printCString(cStr1);</P>
<p class="code2">printCString(cStr2);</P>
<p class="code2">//from CString to char*</P>
<p class="code2">CString cstr = &quot;CString&quot;;</P>
<p class="code2">char* chs=cstr.getbuffer(0);//此方法在VS2010下编译不通过，原因见【例6】</P>
<p class="code2">cout &lt;&lt; chs &lt;&lt; endl;</P>
<p class="code2">}</p>
<p><strong>结果为：</strong></p>
<p class="code2">char pointer.</p>
<p class="code2">char pointer.</p>
<p class="code2">CString</p>
<h2 id="string-cstring">string与CString</h2>
<p>【例6】</p>
<p><strong>结果为：</strong></p>
<p class="code2">string1 to CString</p>
<p class="code2">string2 to CString</p>
<p class="code2">string3 to CString</p>
<p class="code2">CString to string3</p>
<p class="code2">CString to string4</p>
<p>c_str()和data()区别是：前者返回带'/0'的字符串，后者则返回不带'/0'的字符串.</p>
<p>在VS2010环境下，cstr2.Format(&quot;%s&quot;, s2.c_str());cstr2.Format(&quot;%s&quot;, s3.data());及str=cstr3.GetBuffer(0);str = LPCSTR(cstr4); 可能会编不过，会报类似error C2664: 'void ATL::CStringT::Format(const wchar_t *,...)' : cannot convert parameter 1 from 'const char [3]' to 'const wchar_t *'的错误。这是因为你的工程的字符集不是多字节字符集，将你的工程属性设置为多字节字符集即可，方法是：右键点击你的工程，选择Properties\Configurations Properties\General，在右侧的Project Defaults下的Character Set选择Use Multi-Byte Character Set。</p>
<h2 id="u603Bu7ED3">总结</h2>
<p>从灵活度来说，string最灵活易用，其次是CString，char*的拓展性和灵活性比较差。一般来说在基于标准库开发时用string，在在MFC和ATL编程时用CString。</p>
<p>CString、string之间的转换还有其它的一些方向，但基本上都是通过char<em>作为桥梁，因为char</em>即可以方便地转换成string，也可以方便地转换成CString。</p>
<p>更多CString的用法也可参考以下链接，他们写的更详细，我就不再重复了。</p>
<p><a href="http://www.cnblogs.com/Caiqinghua/archive/2009/02/16/1391190.html">http://www.cnblogs.com/Caiqinghua/archive/2009/02/16/1391190.html</a></p>
<p><a href="http://blog.csdn.net/lewutian/article/details/6787024">http://blog.csdn.net/lewutian/article/details/6787024</a></p>
<p>&nbsp; </p>
<p><a href="http://www.kancloud.cn/digest/visualstudio/110059">from:</a></p>
<p>http://www.kancloud.cn/digest/visualstudio/110059</p>
<p>&nbsp;</p>
<p>之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 = 进行赋值操作，== 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。</P>
<p>    
  好了，进入正题………</P>
<p>首先，为了在我们的程序中使用string类型，我们必须包含头文件 &lt;string&gt;。如下：</P>
<p>#include &lt;string&gt; //注意这里不是string.h string.h是C字符串头文件</P>
<p>1．声明一个C++字符串</P>
<p>声明一个字符串变量很简单：</P>
<p>string Str;</p>
<p>这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：</P>
<p class="code2">a)    string s;  //生成一个空字符串s</P>
<p class="code2">b)    string s(str) //拷贝构造函数 生成str的复制品</P>
<p class="code2">c)    string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值</P>
<p class="code2">d)    string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</P>
<p class="code2">e)    string s(cstr) //将C字符串作为s的初值</P>
<p class="code2">f)    string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。</P>
<p class="code2">g)    string s(num,c) //生成一个字符串，包含num个c字符</P>
<p class="code2">h)    string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值</P>
<p class="code2">i)    s.~string() //销毁所有字符，释放内存</P>
<p>都很简单，我就不解释了。</P>
<h4>2．字符串操作函数</h4>
<p>这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。</P>
<p class="code2">a) =,assign()   //赋以新值</P>
<p class="code2">b) swap()   //交换两个字符串的内容</P>
<p class="code2">c) +=,append(),push_back() //在尾部添加字符</P>
<p class="code2">d) insert() //插入字符</P>
<p class="code2">e) erase() //删除字符</P>
<p class="code2">f) clear() //删除全部字符</P>
<p class="code2">g) replace() //替换字符</P>
<p class="code2">h) + //串联字符串</P>
<p class="code2">i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare()  //比较字符串</P>
<p class="code2">j) size(),length()  //返回字符数量</P>
<p class="code2">k) max_size() //返回字符的可能最大个数</P>
<p class="code2">l) empty()  //判断字符串是否为空</P>
<p class="code2">m) capacity() //返回重新分配之前的字符容量</P>
<p class="code2">n) reserve() //保留一定量内存以容纳一定数量的字符</P>
<p class="code2">o) [ ], at() //存取单一字符</P>
<p class="code2">p) &gt;&gt;,getline() //从stream读取某值</P>
<p class="code2">q) &lt;&lt;  //将谋值写入stream</P>
<p class="code2">r) copy() //将某值赋值为一个C_string</P>
<p class="code2">s) c_str() //将内容以C_string返回</P>
<p class="code2">t) data() //将内容以字符数组形式返回</P>
<p class="code2">u) substr() //返回某个子字符串</P>
<p class="code2">v)查找函数</P>
<p class="code2">w)begin() end() //提供类似STL的迭代器支持</P>
<p class="code2">x) rbegin() rend() //逆向迭代器</P>
<p class="code2">y) get_allocator() //返回配置器</P>
<p>下面详细介绍：</P>
<p>2．1 C++字符串和C字符串的转换</P>
<p>    
  C ++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’\0’。c_str()返回一个以‘\0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string或字符数组内。C++字符串并不以’\0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。</P>
<p>2．2 大小和容量函数</P>
<p>    
  一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定，默认参数为0，这时候会对string进行非强制性缩减。</p>
<p>还有必要再重复一下C++字符串和C字符串转换的问题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数Connect(char*,char*)），但别人的函数参数用的是char*形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char*,要想作为上面提及的函数的参数，还必须拷贝到一个char*,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果此函数对参数(也就是char*)的内容不修改的话，我们可以这样Connect((char*)UserID.c_str(), (char*)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char*上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char*上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。</P>
<p>2．3元素存取</P>
<p>    
我们可以使用下标操作符[]和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用 at()的时候索引无效，会抛出out_of_range异常。  </P>
<p>    
有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’\0’。其他的各种情况，a.length()索引都是无效的。举例如下：  </P>
<p class="code2">const string Cstr(“const string”);</P>
<p class="code2">string Str(“string”);</P>
<p class="code2">Str[3];    //ok</P>
<p class="code2">Str.at(3);  //ok</P>
<p class="code2">Str[100]; //未定义的行为</P>
<p class="code2">Str.at(100);  //throw out_of_range</P>
<p class="code2">Str[Str.length()]  //未定义行为</P>
<p class="code2">Cstr[Cstr.length()] //返回 ‘\0’</P>
<p class="code2">Str.at(Str.length());//throw out_of_range</P>
<p class="code2">Cstr.at(Cstr.length()) ////throw out_of_range</P>
<p class="code2">我不赞成类似于下面的引用或指针赋值：</P>
<p class="code2">char&amp; r=s[2];</P>
<p class="code2">char* p= &amp;s[3];</P>
<p class="code2">因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。</P>
<p>2．4比较函数</P>
<p>    
C ++字符串支持常见的比较操作符（  &gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string (“aaaa”) &lt;string(aaaaa)。</P>
<p>    
另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等〉0-大于   &lt;0-小于。举例如下：</P>
<p class="code2">    
string s(“abcd”);  </P>
<p class="code2">    
s.compare(“abcd”); //返回0  </P>
<p class="code2">    
s.compare(“dcba”); //返回一个小于0的值  </P>
<p class="code2">    
s.compare(“ab”); //返回大于0的值  </P>
<p class="code2">s.compare(s); //相等</P>
<p class="code2">    
s.compare(0,2,s,2,2); //用”ab”和”cd”进行比较小于零  </P>
<p class="code2">    
s.compare(1,2,”bcx”,2); //用”bc”和”bc”比较。  </P>
<p>怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？靠，你重修吧！</P>
<p>2．5 更改内容</P>
<p>这在字符串的操作中占了很大一部分。</P>
<p>首先讲赋值，第一个赋值方法当然是使用操作符=，新值可以是string(如：s=ns) 、c_string(如：s=”gaint”)甚至单一字符（如：s=’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：</P>
<p class="code2">s.assign(str); //不说</P>
<p class="code2">s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串</P>
<p class="code2">s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给s</P>
<p class="code2">s.assign(“gaint”); //不说</P>
<p class="code2">s.assign(“nico”,5);//把’n’ ‘I’ ‘c’ ‘o’ ‘\0’赋给字符串</P>
<p class="code2">s.assign(5,’x’);//把五个x赋给字符串</P>
<p>把字符串清空的方法有三个：s=””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。</P>
<p>string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。</P>
<p>先说增加字符（这里说的增加是在尾巴上），函数有 +=、append()、push_back()。举例如下：</P>
<p class="code2">s+=str;//加个字符串</P>
<p class="code2">s+=”my name is jiayp”;//加个C字符串</P>
<p class="code2">s+=’a’;//加个字符</P>
<p class="code2">s.append(str);</P>
<p class="code2">s.append(str,1,3);//不解释了同前面的函数参数assign的解释</P>
<p class="code2">s.append(str,2,string::npos)//不解释了</P>
<p class="code2">s.append(“my name is jiayp”);</P>
<p class="code2">s.append(“nico”,5);</P>
<p class="code2">s.append(5,’x’);</P>
<p class="code2">s.push_back(‘a’);//这个函数只能增加单个字符对STL熟悉的理解起来很简单</P>
<p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。</P>
<p class="code2">    
s.insert(0,”my name”);  </P>
<p class="code2">    
s.insert(1,str);  </P>
<p>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1, ’j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。</P>
<p>删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。举例吧：</P>
<p class="code2">string s=”il8n”;</P>
<p class="code2">s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_string</P>
<p class="code2">s.erase(13);//从索引13开始往后全删除</P>
<p class="code2">s.erase(7,5);//从索引7开始往后删5个</P>
<p>2．6提取子串和字符串连接</P>
<p>题取子串的函数是：substr(),形式如下：</P>
<p class="code2">s.substr();//返回s的全部内容</P>
<p class="code2">s.substr(11);//从索引11往后的子串</P>
<p class="code2">s.substr(5,6);//从索引5开始6个字符</P>
<p>把两个字符串结合起来的函数是+。（谁不明白请致电120）</P>
<p>2．7输入输出操作</P>
<p class="code2">1．&gt;&gt; 从输入流读取一个string。</P>
<p class="code2">2．&lt;&lt; 把一个string写入输出流。</P>
<p class="code2">另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。</P>
<p>2．8搜索与查找</P>
<p>查找函数很多，功能也很强大，包括了：</P>
<p class="code2">    
find()  </P>
<p class="code2">    
rfind()  </P>
<p class="code2">    
find_first_of()  </P>
<p class="code2">    
find_last_of()  </P>
<p class="code2">    
find_first_not_of()  </P>
<p class="code2">    
find_last_not_of()  </P>
<p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：</P>
<p>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。</P>
<p>最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)== string::npos)）。</p>
<h2><a id="cb_post_title_url" href="http://www.cnblogs.com/chuncn/archive/2009/02/13/1390175.html">从C到C++ string类</a></h2>
<div>
  <div id="cnblogs_post_body">
<p>C语言的字符串函数，简单而高效。C++ string类，功能强大而复杂（对于我这样的人来讲，复杂了点）。简单的比较没有意义，只是在特定的情况下哪一个更适合的问题。</p>
<p>而在决定哪一个更适合之前，你可能需要明白：</p>
<p>A STL标准模板库中的string类使用异常来传递错误</p>
<p>B STL标准模板库中的string类，是一个具有写时才拷贝（Copy-On-Write）技术的类。Copy-On-Write使用了“引用计数“，在下列情况下会使用Copy-On-Write：1）以别的类构造自己，2）以别的类赋值</p>
<p>C 不必担心内存是否足够和字符串长度的同时，你必须放弃严格控制其内存申请释放的想法。</p>
    <h4><a name="_Toc178948017" id="_Toc178948017">string</a>类的构造函数</h4>
<p>String类的构造函数和析构函数如下：</P>
<p class="code2">    a)     string s;   //生成一个空字符串s</P>
<p class="code2">    b)     string s(str) //拷贝构造函数 生成str的复制品</P>
<p class="code2">    c)     string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值</P>
<p class="code2">    d)     string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</P>
<p class="code2">    e)     string s(cstr) //将C字符串作为s的初值</P>
<p class="code2">    f)     string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。</P>
<p class="code2">    g)     string s(num,c) //生成一个字符串，包含num个c字符</P>
<p class="code2">    h)     string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值</P>
<p class="code2">    &lt;!--[if !supportLineBreakNewLine]--&gt;</P>
<p class="code2">    &lt;!--[endif]--&gt;</p>
    <h4>类的字符操作</h4>
<p>const char &amp;operator[](int n)const;</p>
<p>const char &amp;at(int n)const;</p>
<p>char &amp;operator[](int n);</p>
<p>char &amp;at(int n);</p>
<p>operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。</p>
<p>const char *data()const;//返回一个非null终止的c字符数组</p>
<p>const char *c_str()const;//返回一个以null终止的c字符串</p>
<p>int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p>
    <h4><a name="_Toc178948019" id="_Toc178948019">string</a>的特性描述</h4>
<p>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）</p>
<p>int max_size()const;    //返回string对象中可存放的最大字符串的长度</p>
<p>int size()const;        //返回当前字符串的大小</p>
<p>int length()const;       //返回当前字符串的长度</p>
<p>bool empty()const;        //当前字符串是否为空</p>
<p>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p>
    <h4><a name="_Toc178948020" id="_Toc178948020">string</a>类的输入输出操作</h4>
<p>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。</p>
<p>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符'\n'分开。</p>
    <h4><a name="_Toc178948021" id="_Toc178948021">string</a>的赋值</h4>
<p>string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串</p>
<p>string &amp;assign(const char *s);//用c类型字符串s赋值</p>
<p>string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值</p>
<p>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串</p>
<p>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串</p>
<p>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串</p>
<p>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p>
    <h4><a name="_Toc178948022" id="_Toc178948022">string</a>的连接</h4>
<p>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾</p>
<p>string &amp;append(const char *s);             //把c类型字符串s连接到当前字符串结尾</p>
<p>string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾</p>
<p>string &amp;append(const string &amp;s);    //同operator+=()</p>
<p>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾</p>
<p>string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c</p>
<p>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p>
    <h4><a name="_Toc178948023" id="_Toc178948023">string</a>的比较</h4>
<p>bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等</p>
<p>运算符&quot;&gt;&quot;,&quot;&lt;&quot;,&quot;&gt;=&quot;,&quot;&lt;=&quot;,&quot;!=&quot;均被重载用于字符串的比较；</p>
<p>int compare(const string &amp;s) const;//比较当前字符串和s的大小</p>
<p>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小</p>
<p>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小</p>
<p>int compare(const char *s) const;</p>
<p>int compare(int pos, int n,const char *s) const;</p>
<p>int compare(int pos, int n,const char *s, int pos2) const;</p>
<p>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0  </p>
<p>string的子串：</p>
<p>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p>
<p>string的交换：</p>
<p>void swap(string &amp;s2);    //交换当前字符串与s2的值</p>
    <h4><a name="_Toc178948024" id="_Toc178948024">string</a>类的查找函数</h4>
<p>int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置</p>
<p>int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置</p>
<p>int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置</p>
<p>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置</p>
<p>//查找成功时返回所在位置，失败返回string::npos的值</p>
<p>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置</p>
<p>int rfind(const char *s, int pos = npos) const;</p>
<p>int rfind(const char *s, int pos, int n = npos) const;</p>
<p>int rfind(const string &amp;s,int pos = npos) const;</p>
<p>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值</p>
<p>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置</p>
<p>int find_first_of(const char *s, int pos = 0) const;</p>
<p>int find_first_of(const char *s, int pos, int n) const;</p>
<p>int find_first_of(const string &amp;s,int pos = 0) const;</p>
<p>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos</p>
<p>int find_first_not_of(char c, int pos = 0) const;</p>
<p>int find_first_not_of(const char *s, int pos = 0) const;</p>
<p>int find_first_not_of(const char *s, int pos,int n) const;</p>
<p>int find_first_not_of(const string &amp;s,int pos = 0) const;</p>
<p>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos</p>
<p>int find_last_of(char c, int pos = npos) const;</p>
<p>int find_last_of(const char *s, int pos = npos) const;</p>
<p>int find_last_of(const char *s, int pos, int n = npos) const;</p>
<p>int find_last_of(const string &amp;s,int pos = npos) const;</p>
<p>int find_last_not_of(char c, int pos = npos) const;</p>
<p>int find_last_not_of(const char *s, int pos = npos) const;</p>
<p>int find_last_not_of(const char *s, int pos, int n) const;</p>
<p>int find_last_not_of(const string &amp;s,int pos = npos) const;</p>
<p>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p>
    <h4><a name="_Toc178948025" id="_Toc178948025">string</a>类的替换函数</h4>
<p>string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s</p>
<p>string &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符</p>
<p>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s</p>
<p>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符</p>
<p>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c</p>
<p>string &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s</p>
<p>string &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符</p>
<p>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s</p>
<p>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c</p>
<p>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p>
    <h4><a name="_Toc178948026" id="_Toc178948026">string</a>类的插入函数</h4>
<p>string &amp;insert(int p0, const char *s);</p>
<p>string &amp;insert(int p0, const char *s, int n);</p>
<p>string &amp;insert(int p0,const string &amp;s);</p>
<p>string &amp;insert(int p0,const string &amp;s, int pos, int n);</p>
<p>//前4个函数在p0位置插入字符串s中pos开始的前n个字符</p>
<p>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c</p>
<p>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置</p>
<p>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符</p>
<p>void insert(iterator it, int n, char c);//在it处插入n个字符c</p>
    <h4><a name="_Toc178948027" id="_Toc178948027">string</a>类的删除函数</h4>
<p>iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置</p>
<p>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置</p>
<p>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p>


  <p>&nbsp;</p>
  <p>int 转 CString：<br />
    CString.Format(&quot;%d&quot;,int);<br />
    ...............................<br />
    string 转 CString <br />
    CString.format(&quot;%s&quot;, string.c_str()); <br />
    用c_str()确实比data()要好. <br />
    .......................................<br />
    char* 转 CString <br />
    CString.format(&quot;%s&quot;, char*); <br />
     
    CString strtest; <br />
     
    char * charpoint; <br />
     
    charpoint=&quot;give string a value&quot;; <br />
     
    strtest=charpoint; //直接付值<br />
    ...................................................................<br />
    CString 转 int<br />
     
    CString  ss=&quot;1212.12&quot;; <br />
     
    int temp=atoi(ss); //atoi _atoi64或atol<br />
     
    <br />
    将字符转换为整数，可以使用atoi、_atoi64或atol。 <br />
    int int_chage = atoi((lpcstr)ss) ;<br />
    或：<br />
       
    CString str = &quot;23&quot;;<br />
       
    UINT uint;<br />
       
    sscanf(str, &quot;%d&quot;, uint);<br />
    ..............................<br />
    string 转 int<br />
    ..............................<br />
    char* 转 int<br />
     
    #include &lt;stdlib.h&gt;<br />
     
    <br />
     
    int atoi(const char *nptr);<br />
     
    long atol(const char *nptr);<br />
     
    long long atoll(const char *nptr);<br />
     
    long long atoq(const char *nptr);<br />
    ...................................................................<br />
    CString 转 string<br />
      
    string s(CString.GetBuffer()); <br />
      
    GetBuffer()后一定要ReleaseBuffer(),否则就没有释放缓冲区所占的空间. <br />
    ..........................................<br />
    int 转 string<br />
    ..........................................<br />
    char* 转 string <br />
     
    string s(char *); <br />
     
    你的只能初始化，在不是初始化的地方最好还是用assign().<br />
    ...................................................................<br />
    CString 转 char *<br />
     
    CString strtest=&quot;wwwwttttttt&quot;;<br />
     
    charpoint=strtest.GetBuffer(strtest.GetLength());<br />
    CString转换 char[100] <br />
     
    char a[100]; <br />
     
    CString str(&quot;aaaaaa&quot;); <br />
     
    strncpy(a,(LPCTSTR)str,sizeof(a));<br />
      
    CString  str=&quot;aaa&quot;;  <br />
      
    char*  ch;  <br />
      
    ch=(char*)(LPCTSTR)str;<br />
    ..........................................<br />
    int 转 char *<br />
     
    在stdlib.h中有个函数itoa()<br />
     
    itoa的用法：<br />
     
    itoa(i,num,10);<br />
     
    i 需要转换成字符的数字<br />
     
    num 转换后保存字符的变量<br />
     
    10 转换数字的基数（进制）10就是说按照10进制转换数字。还可以是2，8，16等等你喜欢的进制类型<br />
     
    原形：char *itoa(int value, char* string, int radix);<br />
     
    实例：<br />
     
    #include &quot;stdlib.h&quot;<br />
     
    #include &quot;stdio.h&quot;<br />
     
    main()<br />
     
    {<br />
     
    int i=1234;<br />
     
    char s[5];<br />
     
    itoa(i,s,10);<br />
     
    printf(&quot;%s&quot;,s);<br />
     
    getchar();<br />
    }<br />
    ..........................................<br />
    string 转 char * <br />
    char *p = string.c_str(); <br />
     
    <br />
     
    string aa(&quot;aaa&quot;);<br />
     
    char *c=aa.c_str();<br />
     
    string mngName；<br />
     
    char t[200];<br />
     
    memset(t,0,200);<br />
     
    strcpy(t,mngName.c_str());<br />
    ...................................................................<br />
    标准C里没有string,char *==char []==string<br />
    可以用CString.Format(&quot;%s&quot;,char *)这个方法来将char *转成CString。要把CString转成char *，用操<br />
    作符（LPCSTR）CString就可以了。<br />
    cannot convert from 'const char *' to 'char *'<br />
    const char *c=aa.c_str(); <br />
    string.c_str()只能转换成const char *</p>
  </div>
</div>
<p>&nbsp;</p>
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>


<!--
_____________________________________________________________________________________

1 段落替换：
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])
------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
[\s*</p>\s*]
[\s*<p>\s*]
------------------
</p>

<p>

<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
-->



