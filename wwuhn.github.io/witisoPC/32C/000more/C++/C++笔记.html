<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script language="javascript"> 
//bg_even("表格ID属性名","奇数行背景色","偶数行背景色","鼠标经过背景色","点击后背景色");
function bg_even(o,a,b,c,d){
        var t=document.getElementById(o).getElementsByTagName("tr");
        for(var i=0;i<t.length;i++){
                t[i].style.backgroundColor=(t[i].sectionRowIndex%2==0)?a:b;
                t[i].onclick=function(){
                        if(this.x!="1"){
                                this.x="1";
                                this.style.backgroundColor=d;
                        }else{
                                this.x="0";
                                this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                        }
                }
                t[i].onmouseover=function(){
                        if(this.x!="1")this.style.backgroundColor=c;
                }
                t[i].onmouseout=function(){
                        if(this.x!="1")this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                }
        }
}

 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>C++笔记</title>

<style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.6em;
}
P{
margin:16px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 100px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 70px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#goBottom:hover{
background-color:white;
border:#ccc 1px solid;
color:red;
}
 
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}
.floatr{
float:right;
padding-right:5px;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
img{
border:0;
}
.picsay{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
}
.code0{
color:red;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:0em;
}
.code2{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:2em;
}
.code4{
color:blue;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:4em;
}
sub,sup{
font-size:80%;
color:red;
}
</style>
</head>

<body> 
<div class="container">
<!--
<table id="tbrowser">
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
-->

<!--
height="*\w*"
width="*\w*"
</p>
<p>
-->


<p></p>


<p>std::string是ANSI，但std::wstring是Unicode如果要定义Unicode，只需要在正常的ANSI字符串前加上“L”就可以了。wchar_t* un = L"China!";char* an = "China!";</p>

<p>win32 Console application:手动在source file中添加main.cpp，以命令行窗口显示运行结果；</p>

<p>里我们并没有用到头文件，但是依然可以在不同文件间共享变量和函数，这一切都是extern的功劳！总结要了解extern主要搞清以下几个概念：1、声明和定义的区别。全局代码空间里，变量可以有多个声明，但只能有一个定义2、include头文件等同于展开头文件里的代码了解了以上两点，再来分析extern的用法，是不是就会清晰很多了</p>


<p>C++常见转义字符：\n换行；\r回车；\\反斜杠；\'单引号；\"双引号；\0空字符(NULL)；</p>

<p>string s("hello");</p>

<p>extern的作用是通知编译器，在本CPP中要用到某个符号，这个符号可能不在本CPP中定义。它表示在某个CPP文件中，存在这么一个函数/全局变量。</p>

<p>用操纵符实现格式化输入输出，操纵符算子manipulator是一系列特殊的函数，它不属于任何类的成员，主要用来格式化输入输出，定义在iostream.h和iomanip.h两个头文件中。endl插入一个新行并刷新流；flush刷新流；</p>



<p>如果你学过C语言，应该知道文件操作使用的是文件指针，通过文件指针实现对它指向的文件的各种操作。这些文件操作函数中有的最终还是调用了操作系统的API函数或者处理过程与之类似，例如在Windows系统中，fread函数就调用了API函数ReadFile。</p>

<p>Windows系统的API函数除了ReadFile，还有CreateFile、WriteFile等函数。而MFC基于面向对象的思想，将这些Windows API函数封装到了CFile类中，实现对文件的打开、关闭、读、写、获取文件信息等操作。使用CFile类对文件进行操作非常便捷。</p>

<p>无法删除文件时：任务管理器→选择“性能”标签下的“资源监视器”→在“CPU”标签下的“关联的句柄”栏输入该文件或文件夹的名称。→待搜索出结果后逐个右击关联的进程，并选择结束进程。</p>


<p><h4>动态变量</h4></p>

<p>在C++中，每个程序都需要用到几个变量在写程序前就应该知道，每个数组有几个元素也必须在写程序时就决定。有时在编程序时，我们并不知道需要多大的数组或需要多少变量，直到程序开始运行，根据某一个当前运行值才能决定。</p>

<p>在定义数组时，我们建议按最大的可能值定义数组，每次运行时使用数组的一部分元素，当元素个数变化不是很大时，这个方案是可行的；但如果元素个数的变化范围很大时，就太浪费空间了。</p>

<p>这个问题一个更好的解决方案就是动态变量机制。所谓动态变量是指：在写程序时无法确定它们的存在，只有当程序运行起来时，随着程序的运行，根据程序的需求动态产生和消亡的变量。由于动态变量不能在程序中定义，也就无法给它们取名字，因此动态变量的访问需要通过指向动态变量的指针变量来进行间接访问；</p>

<p>要使用动态变量，必须定义一个相应类型的指针，然后通过动态变量申请的功能向系统申请一块空间，将空间的地址存入该指针变量。这样就可以间接访问动态变量了。当程序运行结束时，系统会自动回收指针战胜的空间，但并不人回收指针指向的动态变量的空间，动态变量的空间需要程序员在程序中地释放。因此要实现等实现动态内存分配，系统必须提供以下3个功能。</p>

<p>1 定义指针变量；</p>

<p>2 动态申请空间；</p>

<p>3 动态回收空间；</p>

<p>int *p</p>

<p>p = new int</p>

<p>*p =20</p>

<p>数据封闭－结构体：现代程序设计语言的一大特点是能够将各自独立的数据或操作组织成一个整体。过程和函数可以将一组操作封闭成一个整体。在数据处理方面，数组可以将类型相同的一组有序数据封装成一个整体。需要时可以从数组中选出元素，并单独进行操作。也可以将他们作为一个整体，同时进行操作。此外，我们同样需要能够将一组无序的、异质的数据看作一个整体进行操作。在程序设计语言中，这样的一组数据被称为记录。在C++语言中，称为结构体。</p>

<p>关系表达系：表达一些比较简单的关系；</p>

<p>逻辑表达式：表达一些比较复杂的关系；</p>

<p>条件表达式："?:"表达式，if else语句的简单表达；</p>

<p>switch语句的break语句，是起条件分隔作用，用于跳出switch语句，其实是控制条件单选和多选的情形。遇到break即跳出，一般可以把相同情况的语句放在一起，:号不跟表达式和break,即可得到随后有跟语句的相同处理。</p>

<p>用批处理建立网页时,%号的转义要用：^%%</p>


<p>变量名只是隐式地声明了变量值存储的地址，而它的指针则是显式地声明了变量值存储的地址。</p>

<p>C++将数组名视为指针，即将数组名解释为其第一个元素的地址，如apples = &apples[0];</p>


<p>存储单元编址：只是将存储器划分成一系列字节单元还不够，为了快速方便地在存储器中标识和定位存储单元，写入和读出其中的数据（即数据的存取访问），还需给每个存储单元编上唯一的号码，称为存储地址。采用的编址方案非常简单－线性编址方案。</p>

<h4>数据的存储约定</h4>

<p>容许一个数据占据多个连续的存储单元，称为数据的存储空间。</p>

<p>显然，我们必须把多个字节的存储单元组合拼接起来，才能得到完整的数据。因此要存储一个数据，我们必须回答关于数据存储空间的一些问题。</p>

<p>1 我们的数据有多大，需要占据多少个存储单元。如win32约定4个字节存储一个int类型的整数。</p>

<p>2 用哪相存储单元的地址，作为数据存储空间的地址。多个存储单元中最小的那个地址，就是数据的存储空间地址。</p>

<p>3 数据怎么变成二进制形式，以及二进的，形式怎样变回来。如数据的补码、ASCII编码的方式。</p>

<p>4 多个字节的数据按何种顺序旋转到多个存储单元中。</p>

<p></p>

<p>编程的思维方式：过程化思维：描述数据以及描述数据的处理过程。</p>

<p>描述数据：说明求解问题需要哪些数据，这些数据的规格是什么样的。</p>

<p>描述数据的处理过程：说明数据如何输入、如何加工处理以及如何输出处理结果的过程，包括输入数据、处理数据和输出结果三个环节。</p>

<p>针对描述数据，C++语言首先提供了变量的概念，用来记住数据所在的存储空间的地址，通过变量我们可以方便地对数据进行存取访问。</p>

<p>同时,C++语言提供了丰富的数据类型，用以约定数据的规格，包括数据的存储空间大小、编码和解码方式以及数据可接受的运算处理行主。</p>
<p>1 内置数据类型：描述常用的整型、字符型、浮点型数据；</p>

<p>2 复合数据类型：描述常变量、数组、指针、引用等复合数据。</p>

<p>3 定制数据类型：定制我们自己的数据类型，约定数据的规格，包括存储空间大小、编码和解码方式及其可接受运算处理行为。</p>

<p>C++语言为描述数据处理过程提供了丰富的语法工具，包括：</p>

<p>1 描述最基本的数据运算行为：运算符和表达式语句；</p>

<p>2 描述数据处理的控制流程：流程控制语句；</p>

<p>3 描述复杂的输入和输出：输入输出流类库；</p>

<p>4 复杂的数据处理过程：复合语句和控制语句；</p>

<h4>编程思维方式：面向对象思维</h4>

<p>1 描述对象：说明求解问题需要哪些对象，这些对象具有什么属性和行为能力；针对描述对象，C++语言提供了类class的语法设施用来描述对象的属性和行为能力。类描述了具有相同属性和行为能力的一类对象，称为对象类型，简称类。在类中，对象的属性称为类的数据成员，对象的行为能力称为灰的成员函数。</p>
<p>(1) 描述对象产生和消亡的行为：C++函数提供了构造函数和析构函数。</p>
<p>(2) 描述对象运算操作的行为：C++语言提供了操作符重载函数。</p>
<p>(3) 描述对象的其他行为：普通的成员函数。</p>
<p>C++语言提供了组合和继承两种语法工具，用于支持对象之间组合和类属关系的表达。</p>

<p>2 描述沟通协作过程：说明如何生成具体的对象，以及这些对象之间如何沟通协作发挥各自的行为能力实现问题求解的过程。</p>

<p>条件语句中的表达式一般为逻辑表达式或关系表达式</p>

<p>基础数据结构有3大类，分别是线性、树状和图状。线性数据结构主要有线性表、单向链表和双向链表，线性数据结构的判断基础是，除了首元素和尾元素，其他元素都只有一个前驱和一个后继。树状结构是无环结构，即除根节点外，每个节点都有一个前驱和若干后继，但不能形成环路。图状则涵盖了前两者类型，也允许有环路。</p>

<p>由于静态数据成员要实际在分配空间，因此不能在类声明中进行初始化。静态数据成员初始化在类的外部进行，且与一般数据成员初始化不同，它的格式如下：<数据类型><类名>::<静态数据成员名>=<值></p>
<p>用户处理的数据往往需要存盘作永久备份。将文档类中的数据成员变量的值保存在磁盘文件中，或者将存储的文档文件中的数据读取到相应的成员变量中。这个过程称为序列化(Serialize)。</p>

<p>类的私有成员只能被本类的方法或者申请友元函数，但可以不需定义类的对象，直接使用灰的私有成员函数。</p>

<p>派生类可以继承原有类的成员数据和函数，同时可以添加新的成员。</p>

<p>类其实就是一类数据，封闭或抽象了一类数据和对这些数据操作的方法；类实例化为对象后就可以利用这些数据或方法进行数据处理，形成数据输出。</p>


<p>C语言fputs()函数：写文件函数(将一指定的字符串写入文件）#include <stdio.h>int fputs(const char * s, FILE * stream);函数说明：fputs()用来将参数s 所指的字符串写入到参数stream 所指的文件内.返回值：若成功则返回写出的字符个数, 返回EOF 则表示有错误发生.</p>

<p>cout<<"你的出生年月是："<<birth<<endl;1 文本：""2 变量：直接的变量名；3 换行：endl</p>

<p>字符数据char s[25];cout<<"请输入字符串：\n";cin.getline(s,25);cout<<s<<"\n";字符串#include "iostream";string s1="张三";cout<<s1.c_str()<<endl;</p>


<p>对于C++应用程序来说，数据主要有两种存储方式，一种是栈存储方式，另一种是堆存储方式。栈存储方式通常用于存储战胜空间小、生命周期短的数据，如局部变量和函数参数等。堆存储通常用于存储战胜空间大、生命周期长的数据，如静态变量和全局变量等，以及用new运算符开辟出的空间。</p>

<p>icon→导入import→IDE会自动把图标文件复制到res文件夹；</p>

<p>引入import图标后，再用原图标在res文件夹内替换一下；</p>

<p>信息系统模块：基本数据输入模块、业务数据输入模块、查询模块、管理模块等；</p>

<p>类：数据的二次分类；将程序分为不同的部件，不同的部件即属于不同的类，将基础类型的数据和对这些数据的处理方法封装在一起，形成类型，类型实例化为类，就像变量的定义或部件的制造；</p>

<p>不可见字符（控制字符）与界定符(单引号、双引号、反斜框)、问号等，用一个反斜框打头进行字符转义；</p>

<p>符号常量：#define PI 3.14159</p>

<p>const常变量：const int a=3;(必须写成一行，不能分开写)</p>

<p>变量的4个属性：变量名称、数据类型、变量地址、变量的值；变量地址由系统分配给变量一个内在单元编号。C++可以用&(地址运算符)加变量名称得到一个变量的地址；</p>

<p>C语言的强制类型转换cast：(要转换的新的数据类型)被转换的表达式;</p>

<p>表达式是由运算符、操作数（常量、变量、函数等）和括号按照一定的规则组成的式子；可以将常量、变量和函数认为是最简单的表达式。表达式可以嵌套，每个表达式都有一个值。在计算时要考虑运算符的优先级、结合性及数据类型的转换；计算机中的表达式都写在一行中。表达式有算术、赋值、关系、逻辑、条件和逗号等。在表达式的后边加个分号就是表达式语句。除了控制语句外，几乎都是表达式语句。</p>

<p>多态性可分为运行时的多态性（虚函数），和编译时的多态性（重载）</p>

<p>还有构造函数多态。</p>

<p>类除了创建对象，还可以派生子类；</p>

<p>重载可以分为运算符的重载和函数的重载，但本质上都是一样的。</p>


<p>过程的封装：函数；</p>


<p>C++ this是指向当前对象的指针；</p>

<p>CString类的Format函数：与C的Printf()函数类似，也可以实现将数字格式化为字符串；</p>

<p>CString转换为整形：</p>

<p>CString str("123");</p>

<p>int iTempt = atoi(str);</p>

<p>转换为char*型。因为MFC的很多函数的参数使用了char*数据类型，而用户能够提供的多是CString类型。有三种方法可以将CString转换为Char*类型；</p>

<p>1 使用GetBuffer()函数</p>

<p>char *P;</p>

<p>CString str = "Good Morning";</p>

<p>p = str.GetBuffer(str.GetLength());</p>

<p>2 使用memcpy()函数</p>

<p>CString str = "Good Morning";</p>

<p>char mch[20];</p>

<p>memcpy(mch,str,str.GetLength());</p>

<p>3 使用LPCTSTR强制类型转换</p>

<p>char *ch</p>

<p>CString str = "Good Morning";</p>

<p>ch = (LPSTR)(LPCTSTR)str;</p>

<p>char*类型的数据则 可以直接赋值给CString对象；</p>

<p>C语言中非0表示真。</p>

<p>形参：函数定义时定义的参数；实参：函数调用时定义的参数；</p>

<p>对于行列式的数据结构或问题，可以考虑外内、外循环的嵌套结构；</p>

<p>如果函数嵌套两层以上，建立用函数的形式解决嵌套层次太多的问题。</p>

<p>计算机的内存（RAM）由数百万个顺序存储位置组成，每个位置都有唯一的地址。计算机的内存地址范围从0开始至最大值（取决于内存的数量）。</p>

<p>运行计算机时，操作系统要使用一些内存。运行程序时，程序的代码（执行程序中不同任务的机器语言指令）和数据（该程序使用的信息）也要使用一些内存。</p>

<p>在C程序中声明一个变量时，编译器会预留一个内在位置来储存变量。此位置有唯一的地址。编译器把该地址与变量名相关联。当程序使用该变量名时，将自动访问正确的内存位置。</p>

<p>结构是一个或多个变量的集合，该集合有一个单独的名称，便于操作。与数组不同，结构可以储存不同类型（C语言的任意数据类型，包括数组和其他结构）的变量。结构中的变量被称为结构的成员（member）。</p>

<p>要理解变量作用域，首先要理解结构化编程的思路。结构化编程把程序分成若干独立的函数，每个函数都执行特殊的任务。这里的关键是函数独立。为了真正让函数独立，每个函数的变量都不能受其他函数代码的影响。只有隔离每个函数数据，才能确保函数在完成自身任务时不会被其他函数破坏。在函数中定义变量，便可“隐藏”这些变量，让程序的其他部分无法访问它们。</p>

<p>然而，并非所有情况都要在函数间完全隔离所有的数据。程序员通过指定变量的作用域能很好地控制数据隔离的程序。</p>

<p>任何变量都有一个指定的存储类别，用于决定变量的作用域（在程序中何处可见）和生命期（变量在内存中的存活时间）。</p>

<p>对于结构化编程，正确使用存储类别非常重要。在函数中使用局部变量，提高了函数间的独立性。尽量使用自动存储类别的变量，除非有特殊原因需要使用外部或静态变量。</p>

<p>既然外部变量在程序中的任何地方都可用，为何不将所有的变量都声明为外部变量？</p>

<p>随着程序越来越大，包含的变量也越来越多。外部变量在程序运行期间会一直占用内存，而自动变量只在执行它所在的函数时占用内存。因此，使用局部变量节约内存空间。然而，更重要地是，使用局部变量能减少程序不同部分不必要的交互，从而减少了程序的bug，同时也遵循了结构化编程的原则。</p>

<p>程序输入源和输出目标统称为设备(device)。无论什么设备，是用于输入还是输出，C语言都通过流进行输入和输出操作。</p>

<p>流与文件息息相关。这里的文件指的不是磁盘文件，而是程序待处理的流和实际物理设备之间的媒介。大多数情况下，C语言的初学者无需了解这些文件，因为流、文件、设备之间的交互都由C库函数和操作系统自动完成。</p>

<p>C语言的流有两种模式：文本模式和二进制模式。文本流只由字符组成，如发送至屏幕的文本数据。文本流被组织成行，每行最多可255个字符，且以行结束符或换行符结尾。文本流中的某些字符（如换行符）有特殊的含义。</p>

<p>C标准库中有许多用于处理输入流和输出流的函数。如Printf(),puts(),gets(),scanf()等；</p>



<p>An executable program is created for a specific hardware/system combination. When we talk about portability of C++ programs, we usually mean protability of source ocde.</p>

<p>The ISO C++ standard defines two kinds of entities:</p>

<p>1 Core language features, such as built-in types and loops;</p>

<p>2 standard-library component, such as containers and I/O operations.</p>

<p>Essentially all executable code is placed in functions and called directly or indirectly form main(), we can compose fnctions forces us to name the activity and document is dependencies.</p>

<p>Every name and every expression has a type that determined the operations that may be performed on it.</p>

<p>A type defines a set possible values and a set of operations.</p>

<p>an object is some memory that holds a value of some type.</p>

<p>A value is  a set of bits interpreted according to a type.</p>

<p>A variable is a name object.</p>

<p>Each fundamental type corresponds directly to hardware facilities and has a fixed size that determines the ranges of values that can be store in it.</p>

<p>C++ provides a conventional set of statements for expressing selection and looping.</p>

<p>Type built out of the built-in type using C++'s abstraction mechanisms are called user-defined types. they are refered to as classes and enumerations.</p>

<p>Having the data specified separately from the operations on it has advantages such as the bility to use the data in arbitrary ways. However, a tighter connection between the representation and the operations is need for a user-defined of a "real type." In particular, we often want to keep the representation inaccessible to users.</p>

<p>A union is a struct in  which all members are allocated at the same same address so that the union occupies only as much space as its largest member. Naturally, a union can hold a value for only one member at a time.</p>

<p>Use enumerations to represent sets of name constants that enumerate the value.</p>

<p>organize related data into structures.</p>

<p>A struct is simply a class with its members public by default.</p>

<p>a set of data related data and a set of operations about those data.</p>

<p>No significant program is written in just a bare programming language. First, a set of libraries is developed. These then form the basis for further work.</p>

</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>


<!--
_____________________________________________________________________________________

1 段落替换：
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])
------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
[\s*</p>\s*]
[\s*<p>\s*]
------------------
</p>

<p>

<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
-->



