<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>MFC Object和Windows Object的关系</title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop属性.  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}

document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
height:28px;
//white-space:nowrap;
//overflow:hidden; 
//text-overflow:ellipsis; 
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
padding-left:2px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
</style>
</head>

<body>

<div id="container">
<h3></h3>


<p><strong>MFC Object和Windows Object的关系</strong></p>
<p>MFC中最重要的封装是对Win32 API的封装，因此，理解Windows Object和MFC Object (C++对象，一个C++类的实例)之间的关系是理解MFC的关键之一。所谓Windows Object（Windows对象）是Win32下用句柄表示的Windows操作系统对象；所谓MFC Object (MFC对象)是C++对象，是一个C++类的实例，这里（本书范围内）MFC Object是有特定含义的，指封装Windows Object的C++ Object，并非指任意的C++ Object。</p>
<p>MFC Object 和Windows Object是不一样的，但两者紧密联系。以窗口对象为例：</p>
<p>一个MFC窗口对象是一个C++ CWnd类（或派生类）的实例，是程序直接创建的。在程序执行中它随着窗口类构造函数的调用而生成，随着析构函数的调用而消失。而Windows窗口则是Windows系统的一个内部数据结构的实例，由一个“窗口句柄”标识，Windows系统创建它并给它分配系统资源。Windows窗口在MFC窗口对象创建之后，由CWnd类的Create成员函数创建，“窗口句柄”保存在窗口对象的m_hWnd成员变量中。Windows窗口可以被一个程序销毁，也可以被用户的动作销毁。MFC窗口对象和Windows窗口对象的关系如图2-1所示。其他的Windows Object和对应的MFC Object也有类似的关系。</p>

<p>下面，对MFC Object和Windows Object作一个比较。有些论断对设备描述表(MFC类是CDC，句柄是HDC)可能不适用，但具体涉及到时会指出。</p>

<strong>从数据结构上比较</strong>
<p>MFC Object是相应C++类的实例，这些类是MFC或者程序员定义的；</p>
<p>Windows Object是Windows系统的内部结构，通过一个句柄来引用；</p>
<p>MFC给这些类定义了一个成员变量来保存MFC Object对应的Windows Object的句柄。对于设备描述表CDC类，将保存两个HDC句柄。</p>

<strong>从层次上讲比较</strong>
<p>MFC Object是高层的，Windows Object是低层的；</p>
<p>MFC Object封装了Windows Object的大部分或全部功能，MFC Object的使用者不需要直接应用Windows Object的HANDLE（句柄）使用Win32 API，代替它的是引用相应的MFC Object的成员函数。</p>

<strong>从创建上比较</strong>
<p>MFC Object通过构造函数由程序直接创建；Windows Object由相应的SDK函数创建。</p>
<p>MFC中，使用这些MFC Object，一般分两步：</p>
<p>首先，创建一个MFC Object，或者在STACK中创建，或者在HEAP中创建，这时，MFC Object的句柄实例变量为空，或者说不是一个有效的句柄。</p>
<p>然后，调用MFC Object的成员函数创建相应的Windows Object，MFC的句柄变量存储一个有效句柄。</p>
<p>CDC(设备描述表类)的创建有所不同，在后面的2.3节会具体说明CDC及其派生类的创建和使用。</p>
<p>当然，可以在MFC Object的构造函数中创建相应的Windows对象，MFC的GDI类就是如此实现的，但从实质上讲，MFC Object的创建和Windows Object的创建是两回事。</p>

<strong>从转换上比较</strong>
<p>可以从一个MFC Object得到对应的Windows Object的句柄；一般使用MFC Object的成员函数GetSafeHandle得到对应的句柄。</p>
<p>可以从一个已存在的Windows Object创建一个对应的MFC Object； 一般使用MFC Object的成员函数Attach或者FromHandle来创建，前者得到一个永久性对象，后者得到的可能是一个临时对象。</p>

<strong>从使用范围上比较</strong>
<p>MFC Object对系统的其他进程来说是不可见、不可用的；而Windows Object一旦创建，其句柄是整个Windows系统全局的。一些句柄可以被其他进程使用。典型地，一个进程可以获得另一进程的窗口句柄，并给该窗口发送消息。</p>
<p>对同一个进程的线程来说，只可以使用本线程创建的MFC Object，不能使用其他线程的MFC Object。</p>

<strong>从销毁上比较</strong>
<p>MFC Object随着析构函数的调用而消失；但Windows Object必须由相应的Windows系统函数销毁。</p>
<p>设备描述表CDC类的对象有所不同，它对应的HDC句柄对象可能不是被销毁，而是被释放。</p>
<p>当然，可以在MFC Object的析构函数中完成Windows Object的销毁，MFC Object的GDI类等就是如此实现的，但是，应该看到：两者的销毁是不同的。</p>
<p>每类Windows Object都有对应的MFC Object，下面用表格的形式列出它们之间的对应关系，如表2-1所示：</p>
<p>表2-1 MFC Object和Windows Object的对应关系</p>
<table id="tbrowser">
<col width="15%" />
<col width="15%" />
<col width="70%" />
  <tbody>
    <tr>
      <td>描述</td>
      <td>Windows句柄</td>
      <td>MFC Object</td>
    </tr>
    <tr>
      <td>窗口</td>
      <td>HWND</td>
      <td>CWnd and CWnd-derived classes</td>
    </tr>
    <tr>
      <td>设备上下文</td>
      <td>HDC</td>
      <td>CDC and CDC-derived classes</td>
    </tr>
    <tr>
      <td>菜单</td>
      <td>HMENU</td>
      <td>CMenu</td>
    </tr>
    <tr>
      <td>笔</td>
      <td>HPEN</td>
      <td>CGdiObject类，CPen和CPen-derived classes</td>
    </tr>
    <tr>
      <td>刷子</td>
      <td>HBRUSH</td>
      <td>CGdiObject类，CBrush和CBrush-derived classes</td>
    </tr>
    <tr>
      <td>字体</td>
      <td>HFONT</td>
      <td>CGdiObject类，CFont和CFont-derived classes</td>
    </tr>
    <tr>
      <td>位图</td>
      <td>HBITMAP</td>
      <td>CGdiObject类，CBitmap和CBitmap-derived classes</td>
    </tr>
    <tr>
      <td>调色板</td>
      <td>HPALETTE</td>
      <td>CGdiObject类，CPalette和CPalette-derived classes</td>
    </tr>
    <tr>
      <td>区域</td>
      <td>HRGN</td>
      <td>CGdiObject类，CRgn和CRgn-derived classes</td>
    </tr>
    <tr>
      <td>图像列表</td>
      <td>HimageLIST</td>
      <td>CimageList和CimageList-derived classes</td>
    </tr>
    <tr>
      <td>套接字</td>
      <td>SOCKET</td>
      <td>CSocket,CAsynSocket及其派生类</td>
    </tr>
  </tbody>
</table>


<h4>表2-1中的OBJECT分以下几类:</h4>

<p>Windows对象，</p>
<p>设备上下文对象，</p>
<p><a name="baidusnap0" target="_blank" id="baidusnap0"></a><strong>GDI对象</strong>（BITMAP，BRUSH，FONT，PALETTE，PEN，RGN），</p>
<p>菜单，</p>
<p>图像列表，</p>
<p>网络套接字接口。</p>
<p>从广义上来看，文档对象和文件可以看作一对MFC Object和Windows Object，分别用CDocument类和文件句柄描述。</p>
<p>后续几节分别对前四类作一个简明扼要的论述。</p>

<strong><h3>Windows Object</h3></strong>

<p>用SDK的Win32 API编写各种Windows应用程序，有其共同的规律：首先是编写WinMain函数，编写处理消息和事件的窗口过程WndProc，在WinMain里头注册窗口（Register Window），创建窗口，然后开始应用程序的消息循环。</p>
<p>MFC应用程序也不例外，因为MFC是一个建立在SDK API基础上的编程框架。对程序员来说所不同的是：一般情况下，MFC框架自动完成了Windows登记、创建等工作。</p>
<p>下面，简要介绍MFC Window对Windows Window的封装。</p>

<strong><h4>Windows的注册</h4></strong>

<p>一个应用程序在创建某个类型的窗口前，必须首先注册该“窗口类”(Windows Class)。注意，这里不是C++类的类。Register Window把窗口过程、窗口类型以及其他类型信息和要登记的窗口类关联起来。</p>

<h4>“窗口类”的数据结构</h4>

<p>“窗口类”是Windows系统的数据结构，可以把它理解为Windows系统的类型定义，而Windows窗口则是相应“窗口类”的实例。Windows使用一个结构来描述“窗口类”，其定义如下：</p>
<p>typedef struct _WNDCLASSEX {</p>
<p>UINT cbSize; //该结构的字节数</p>
<p>UINT style; //窗口类的风格</p>
<p>WNDPROC lpfnWndProc; //窗口过程</p>
<p>int cbClsExtra;</p>
<p>int cbWndExtra;</p>
<p>HANDLE hInstance; //该窗口类的窗口过程所属的应用实例</p>
<p>HICON hIcon; //该窗口类所用的像标</p>
<p>HCURSOR hCursor; //该窗口类所用的光标</p>
<p>HBRUSH hbrBackground; //该窗口类所用的背景刷</p>
<p>LPCTSTR lpszMenuName; //该窗口类所用的菜单资源</p>
<p>LPCTSTR lpszClassName; //该窗口类的名称</p>
<p>HICON hIconSm; //该窗口类所用的小像标</p>
<p>} WNDCLASSEX;</p>
<p>从“窗口类”的定义可以看出，它包含了一个窗口的重要信息，如窗口风格、窗口过程、显示和绘制窗口所需要的信息，等等。关于窗口过程，将在后面消息映射等有关章节作详细论述。</p>
<p>Windows系统在初始化时，会注册(Register)一些全局的“窗口类”，例如通用控制窗口类。应用程序在创建自己的窗口时，首先必须注册自己的窗口类。在MFC环境下，有几种方法可以用来注册“窗口类”，下面分别予以讨论。</p>

<h4>调用AfxRegisterClass注册</h4>

<p>AfxRegisterClass函数是MFC全局函数。AfxRegisterClass的函数原型：</p>
<p>BOOL AFXAPI AfxRegisterClass(WNDCLASS *lpWndClass);</p>
<p>参数lpWndClass是指向WNDCLASS结构的指针，表示一个“窗口类”。</p>
<p>首先，AfxRegisterClass检查希望注册的“窗口类”是否已经注册，如果是则表示已注册，返回TRUE，否则，继续处理。</p>
<p>接着，调用::RegisterClass(lpWndClass)注册窗口类；</p>
<p>然后，如果当前模块是DLL模块，则把注册“窗口类”的名字加入到模块状态的域m_szUnregisterList中。该域是一个固定长度的缓冲区，依次存放模块注册的“窗口类”的名字（每个名字是以“/n/0”结尾的字符串）。之所以这样做，是为了DLL退出时能自动取消(Unregister)它注册的窗口类。至于模块状态将在后面第9章详细的讨论。</p>
<p>最后，返回TRUE表示成功注册。</p>

<h4>调用AfxRegisterWndClass注册</h4>

<p>AfxRegisterWndClass函数也是MFC全局函数。AfxRegisterWndClass的函数原型：</p>
<p>LPCTSTR AFXAPI AfxRegisterWndClass(UINT nClassStyle,</p>
<p>HCURSOR hCursor, HBRUSH hbrBackground, HICON hIcon)</p>
<p>参数1指定窗口类风格；</p>
<p>参数2、3、4分别指定该窗口类使用的光标、背景刷、像标的句柄，缺省值是0。</p>
<p>此函数根据窗口类属性动态地产生窗口类的名字，然后，判断是否该类已经注册，是则返回窗口类名；否则用指定窗口类的属性（窗口过程指定为缺省窗口过程），调用AfxRegisterCalss注册窗口类，返回类名。</p>
<p>动态产生的窗口类名字由以下几部分组成（包括冒号分隔符）：</p>
<p>如果参数2、3、4全部为NULL，则由三部分组成。</p>
<p>“Afx”+“:”+模块实例句柄”+“:”+“窗口类风格”</p>
<p>否则，由六部分组成：</p>
<p>“Afx”+“:”+模块实例句柄+“:”+“窗口类风格”+“:”+光标句柄+“:”+背景刷句柄+“:”+像标句柄。比如：“Afx:400000:b:13de:6:32cf”。</p>
<p>该函数在MFC注册主边框或者文档边框“窗口类”时被调用。具体怎样用在5.3.3.3节会指出。</p>

<h4>隐含的使用MFC预定义的的窗口类</h4>

<p>MFC4.0以前的版本提供了一些预定义的窗口类，4.0以后不再预定义这些窗口类。但是，MFC仍然沿用了这些窗口类，例如：</p>
<p>用于子窗口的“AfxWnd”；</p>
<p>用于边框窗口(SDI主窗口或MDI子窗口)或视的“AfxFrameOrView”；</p>
<p>用于MDI主窗口的“AfxMDIFrame”；</p>
<p>用于标准控制条的“AfxControlBar”。</p>
<p>这些类的名字就 是“AfxWnd”、“AfxFrameOrView”、“AfxMdiFrame”、 “AfxControlBar”加上前缀和后缀（用来标识版本号或是否调试版等）。它们使用标准应用程序像标、标准文档像标、标准光标等标准资源。为了使用这些“窗口类”，MFC会在适当的时候注册这些类：或者要创建该类的窗口时，或者创建应用程序的主窗口时，等等。</p>
<p>MFC内部使用了函数</p>
<p>BOOL AFXAPI AfxEndDeferRegisterClass(short fClass)</p>
<p>来帮助注册上述原MFC版本的预定义“窗口类”。参数fClass区分了那些预定义窗口的类型。根据不同的类型，使用不同的窗口类风格、窗口类名字等填充WndClass的域，然后调用AfxRegisterClass注册窗口类。并且注册成功之后，通过模块状态的m_fRegisteredClasses记录该窗口类已经注册，这样该模块在再次需要注册这些窗口类之前可以查一下m_fRegisteredClasses，如果已经注册就不必浪费时间了。为此，MFC内部使用宏</p>
<p>AfxDeferRegisterClass(short fClass)</p>
<p>来注册“窗口类”，如果m_fRegisteredClasses记录了注册的窗口类，返回TRUE，否则，调用AfxEndDeferRegisterClass注册。</p>
<p>注册这些窗口类的例子：</p>
<p>MFC在加载边框窗口时，会自动地注册“AfxFrameOrView”窗口类。在创建视时，就会使用该“窗口类”创建视窗口。当然，如果创建视窗口时，该“窗口类”还没有注册，MFC将先注册它然后使用它创建视窗口。</p>
<p>不过，MFC并不使用”AfxMDIFrame”来创建MDI主窗口，因为在加载主窗口时一般都指定了主窗口的资源，MFC使用指定的像标注册新的MDI主窗口类（通过函数AfxRegisterWndClass完成，因此“窗口类”的名字是动态产生的）。</p>
<p>MDI子窗口类似于上述MDI主窗口的处理。</p>
<p>在MFC创建控制窗口时，如工具栏窗口，如果“AfxControlBar”类还没有注册，则注册它。注册过程很简单，就是调用::InitCommonControl加载通用控制动态连接库。</p>

<h4>调用::RegisterWndClass</h4>

<p>直接调用Win32的窗口注册函数::RegisterWndClass注册“窗口类”，这样做有一个缺点：如果是DLL模块，这样注册的“窗口类”在程序退出时不会自动的被取消注册(Unregister)。所以必须记得在DLL模块退出时取消它所注册的窗口类。</p>

<h4>子类化</h4>

<p>子类化（Subclass）一个“窗口类”，可自动地得到它的“窗口类”属性。</p>

<strong>MFC窗口类CWnd</strong>

<p>在Windows系统里，一个窗口的属性分两个地方存放：一部分放在“窗口类”里头，如上所述的在注册窗口时指定；另一部分放在Windows Object本身，如：窗口的尺寸，窗口的位置（X，Y轴），窗口的Z轴顺序，窗口的状态（ACTIVE，MINIMIZED，MAXMIZED，RESTORED…），和其他窗口的关系（父窗口，子窗口…），窗口是否可以接收键盘或鼠标消息，等等。</p>
<p>为了表达所有这些窗口的共性，MFC设计了一个窗口基类CWnd。有一点非常重要，那就是CWnd提供了一个标准而通用的MFC窗口过程，MFC下所有的窗口都使用这个窗口过程。至于通用的窗口过程却能为各个窗口实现不同的操作，那就是MFC消息映射机制的奥秘和作用了。这些，将在后面有关章节详细论述。</p>
<p>CWnd提供了一系列成员函数，或者是对Win32相关函数的封装，或者是CWnd新设计的一些函数。这些函数大致如下。</p>
<p>（1）窗口创建函数</p>
<p>这里主要讨论函数Create和CreateEx。它们封装了Win32窗口创建函数::CreateWindowEx。Create的原型如下：</p>
<p>BOOL CWnd::Create(LPCTSTR lpszClassName,</p>
<p>LPCTSTR lpszWindowName, DWORD dwStyle,</p>
<p>const RECT&amp; rect,</p>
<p>CWnd* pParentWnd, UINT nID,</p>
<p>CCreateContext* pContext)</p>
<p>Create是一个虚拟函数，用来创建子窗口（不能创建桌面窗口和POP UP窗口）。CWnd的基类可以覆盖该函数，例如边框窗口类等覆盖了该函数以实现边框窗口的创建，视类则使用它来创建视窗口。</p>

<p>Create调用了成员函数CreateEx。CWnd::CreateEx的原型如下：</p>
<p>BOOL CWnd::CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,</p>
<p>LPCTSTR lpszWindowName, DWORD dwStyle,</p>
<p>int x, int y, int nWidth, int nHeight,</p>
<p>HWND hWndParent, HMENU nIDorHMenu, LPVOID lpParam)</p>
<p>CreateEx有11个参数，它将调用::CreateWindowEx完成窗口的创建，这11个参数对应地传递给::CreateWindowEx。参数指定了窗口扩展风格、“窗口类”、窗口名、窗口大小和位置、父窗口句柄、窗口菜单和窗口创建参数。</p>
<p>CreateEx的处理流程将在后面4.4.1节讨论窗口过程时分析。</p>
<p>窗口创建时发送WM_CREATE消息，消息参数lParam指向一个CreateStruct结构的变量，该结构有11个域，其描述见后面4.4.1节对窗口过程的分析，Windows使用和CreateEx参数一样的内容填充该变量。</p>
<p>（2）窗口销毁函数</p>
<p>例如：</p>
<p>DestroyWindow函数 销毁窗口</p>
<p>PostNcDestroy( )，销毁窗口后调用，虚拟函数</p>

<p>（3）用于设定、获取、改变窗口属性的函数，例如：</p>
<p>SetWindowText(CString tiltle) 设置窗口标题</p>
<p>GetWindowText() 得到窗口标题</p>
<p>SetIcon(HICON hIcon, BOOL bBigIcon)；设置窗口像标</p>
<p>GetIcon( BOOL bBigIcon ) ;得到窗口像标</p>
<p>GetDlgItem( int nID)；得到窗口类指定ID的控制子窗口</p>
<p>GetDC(); 得到窗口的设备上下文</p>
<p>SetMenu(CMenu *pMenu); 设置窗口菜单</p>
<p>GetMenu()；得到窗口菜单</p>
<p>…</p>

<p>（4）用于完成窗口动作的函数</p>
<p>用于更新窗口，滚动窗口，等等。一部分成员函数设计成或可重载(Overloaded）函数，或虚拟(Overridden)函数，或MFC消息处理函数。这些函数或者实现了一部分功能，或者仅仅是一个空函数。如：</p>

<h4>有关消息发送的函数</h4>：

<p>SendMessage( UINT message,WPARAM wParam = 0, LPARAM lParam = 0 );</p>
<p>给窗口发送发送消息，立即调用方式</p>
<p>PostMessage(( UINT message,WPARAM wParam = 0, LPARAM lParam = 0 );</p>
<p>给窗口发送消息，放进消息队列</p>
<p>…</p>

<h4>有关改变窗口状态的函数
</h4>
<p>MoveWindow( LPCRECT lpRect, BOOL bRepaint = TRUE );</p>
<p>移动窗口到指定位置</p>
<p>ShowWindow(BOOL )；显示窗口，使之可见或不可见</p>
<p>….</p>

<h4>实现MFC消息处理机制的函数：
</h4>
<p>virtual LRESULT WindowProc( UINT message, WPARAM wParam, LPARAM lParam ); 窗口过程，虚拟函数</p>

<p>virtual BOOL OnCommand( WPARAM wParam, LPARAM lParam )；处理命令消息</p>
<p>…</p>

<h4>消息处理函数：
</h4>
<p>OnCreate( LPCREATESTRUCT lpCreateStruct );MFC窗口消息处理函数，窗口创建时由MFC框架调用</p>
<p>OnClose();MFC窗口消息处理函数，窗口创建时由MFC框架调用</p>
<p>…</p>

<h4>其他功能的函数
</h4>
<p>CWnd的导出类是类型更具体、功能更完善的窗口类，它们继承了CWnd的属性和方法，并提供了新的成员函数（消息处理函数、虚拟函数、等等）。</p>
<p>常用的窗口类及其层次关系见图1-1。</p>

<strong>在MFC下创建一个窗口对象</strong>

<p>MFC下创建一个窗口对象分两步，首先创建MFC窗口对象，然后创建对应的Windows窗口。在内存使用上，MFC窗口对象可以在栈或者堆(使用new创建)中创建。具体表述如下：</p>

<p>创建MFC窗口对象。通过定义一个CWnd或其派生类的实例变量或者动态创建一个MFC窗口的实例，前者在栈空间创建一个MFC窗口对象，后者在堆空间创建一个MFC窗口对象。
</p>

<p>调用相应的窗口创建函数，创建Windows窗口对象。
</p>
<p>例如：在前面提到的AppWizard产生的源码中，有CMainFrame（派生于CMDIFrame(SDI)或者CMDIFrameWnd(MDI)）类。它有两个成员变量定义如下：</p>
<p>CToolBar m_wndToolBar;</p>
<p>CStatusBar m_wndStatusBar;</p>
<p>当创建CMainFrame类对象时，上面两个MFC Object也被构造。</p>
<p>CMainFrame还有一个成员函数</p>
<p>OnCreate（LPCREATESTRUCT lpCreateStruct)，</p>
<p>它的实现包含如下一段代码，调用CToolBar和CStatusBar的成员函数Create来创建上述两个MFC对象对应的工具栏HWND窗口和状态栏HWND窗口：</p>
<p>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)</p>
<p>{</p>
<p>…</p>
<p>if (!m_wndToolBar.Create(this) ||</p>
<p>!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))</p>
<p>{</p>
<p>TRACE0(&quot;Failed to create toolbar/n&quot;);</p>
<p>return -1; // fail to create</p>
<p>}</p>

<p>if (!m_wndStatusBar.Create(this) ||</p>
<p>!m_wndStatusBar.SetIndicators(indicators,</p>
<p>sizeof(indicators)/sizeof(UINT)))</p>
<p>{</p>
<p>TRACE0(&quot;Failed to create status bar/n&quot;);</p>
<p>return -1; // fail to create</p>
<p>}</p>
<p>…</p>
<p>}</p>
<p>关于工具栏、状态栏将在后续有关章节作详细讨论。</p>
<p>在MFC中，还提供了一种动态创建技术。动态创建的过程实际上也如上所述分两步，只不过MFC使用这个技术是由框架自动地完成整个过程的。通常框架窗口、文档框架窗口、视使用了动态创建。介于MFC的结构，CFrameWnd和CView及其派生类的实例即使不使用动态创建，也要用new在堆中分配。理由见窗口的销毁（2.2.5节）。</p>
<p>至于动态创建技术，将在下一章具体讨论。</p>
<p>在Windows窗口的创建过程中，将发送一些消息，如：</p>
<p>在创建了窗口的非客户区(Nonclient area)之后，发送消息WM_NCCREATE；</p>
<p>在创建了窗口的客户区（client area）之后，发送消息WM_CREATE；</p>
<p>窗口的窗口过程在窗口显示之前收到这两个消息。</p>
<p>如果是子窗口，在发送了上述两个消息之后，还给父窗口发送WM_PARENATNOTIFY消息。其他类或风格的窗口可能发送更多的消息，具体参见SDK开发文档。</p>

<h4><strong>MFC窗口的使用</strong>
</h4>
<p>MFC提供了大量的窗口类，其功能和用途各异。程序员应该选择哪些类来使用，以及怎么使用他们呢？</p>
<p>直接使用MFC提供的窗口类或者先从MFC窗口类派生一个新的C++类然后使用它，这些在通常情况下都不需要程序员提供窗口注册的代码。是否需要派生新的C++类，视MFC已有的窗口类是否能满足使用要求而定。派生的C++类继承了基类的特性并改变或扩展了它的功能，例如增加或者改变对消息、事件的特殊处理等。</p>
<p>主要使用或继承以下一些MFC窗口类（其层次关系图见图1-1）：</p>
<p>框架类CFrameWnd，CMdiFrameWnd；</p>
<p>文档框架CMdiChildWnd；</p>
<p>视图CView和CView派生的有特殊功能的视图如：列表CListView，编辑CEditView，树形列表CTreeView，支持RTF的CRichEditView，基于对话框的视CFormView等等。</p>
<p>对话框CDialog。</p>
<p>通常，都要从这些类派生应用程序的框架窗口和视窗口或者对话框。</p>

<p>工具条CToolBar</p>
<p>状态条CStatusBar</p>
<p>其他各类控制窗口，如列表框CList，编辑框CEdit，组合框CComboBox，按钮Cbutton等。</p>
<p>通常，直接使用这些类。</p>

<h4><strong>在MFC下窗口的销毁</strong>
</h4>
<p>窗口对象使用完毕，应该销毁。在MFC下，一个窗口对象的销毁包括HWND窗口对象的销毁和MFC窗口对象的销毁。一般情况下，MFC编程框架自动地处理了这些。</p>
<p>（1）对CFrameWnd和CView的派生类</p>
<p>这些窗口的关闭导致销毁窗口的函数DestroyWindow被调用。销毁Windows窗口时，MFC框架调用的最后一个成员函数是OnNcDestroy函数，该函数负责Windows清理工作，并在最后调用虚拟成员函数PostNcDestroy。CFrameWnd和CView的PostNcDestroy调用delete this<a name="baidusnap2" target="_blank" id="baidusnap2"></a><strong>删除</strong>自身这个MFC窗口对象。</p>
<p>所以，对这些窗口，如前所述，应在堆（Heap）中分配，而且，不要对这些对象使用delete操作。</p>

<p>（2）对Windows Control窗口</p>
<p>在它们的析构函数中，将调用DestroyWidnow来销毁窗口。如果在栈中分配这样的窗口对象，则在超出作用范围的时候，随着析构函数的调用，MFC窗口对象和它的Windows window对象都被销毁。如果在堆（Heap）中分配，则显式调用delete操作符，导致析构函数的调用和窗口的销毁。</p>
<p>所以，这种类型的窗口应尽可能在栈中分配，避免用额外的代码来销毁窗口。如前所述的CMainFrame的成员变量m_wndStatusBar和m_wndToolBar就是这样的例子。</p>
<p>（3）对于程序员直接从CWnd派生的窗口</p>
<p>程序员可以在派生类中实现上述两种机制之一，然后，在相应的规范下使用。</p>
<p>后面章节将详细的讨论应用程序退出时关闭、清理窗口的过程。</p>

<h4><strong>设备描述表</strong>
</h4>

<strong>设备描述表概述</strong>

<p>当一个应用程序使用GDI函数时，必须先装入特定的设备驱动程序，然后为绘制窗口准备设备描述表，比如指定线的宽度和颜色、刷子的样式和颜色、字体、剪裁区域等等。不像其他Win32结构，设备描述表不能被直接访问，只能通过系列Win32函数来间接地操作。</p>
<p>如同Windows“窗口类”一样，设备描述表也是一种Windows数据结构，用来描述绘制窗口所需要的信息。它定义了一个坐标映射模式、一组GDI图形对象及其属性。这些<strong>GDI对象</strong>包括用于画线的笔，绘图、填图的刷子，位图，调色板，剪裁区域，及路径(Path)。</p>
<p>表2-2列出了设备描述表的结构和各项缺省值，表2-3列出了设备描述表的类型，表2-4显示设备描述表的类型。</p>
<p>表2-2 设备描述表的结构</p>
<table id="tbrowser">
<col width="20%" />
<col width="80%" />
  <tbody>
    <tr>
      <td>属性</td>
      <td>缺省值</td>
    </tr>
    <tr>
      <td>Background color</td>
      <td>Background color setting from Windows Control Panel (typically, white)</td>
    </tr>
    <tr>
      <td>Background mode</td>
      <td>OPAQUE</td>
    </tr>
    <tr>
      <td>Bitmap</td>
      <td>None</td>
    </tr>
    <tr>
      <td>Brush</td>
      <td>WHITE_BRUSH</td>
    </tr>
    <tr>
      <td>Brush origin</td>
      <td>(0,0)</td>
    </tr>
    <tr>
      <td>Clipping region</td>
      <td>Entire window or client area with the update region clipped, as appropriate. Child and pop-up windows in the client area may also be clipped</td>
    </tr>
    <tr>
      <td>Palette</td>
      <td>DEFAULT_PALETTE</td>
    </tr>
    <tr>
      <td>Current pen position</td>
      <td>(0,0)</td>
    </tr>
    <tr>
      <td>Device origin</td>
      <td>Upper left corner of the window or the client area</td>
    </tr>
    <tr>
      <td>Drawing mode</td>
      <td>R2_COPYPEN</td>
    </tr>
    <tr>
      <td>Font</td>
      <td>SYSTEM_FONT (SYSTEM_FIXED_FONT for applications written to run with Windows versions 3.0 and earlier)</td>
    </tr>
    <tr>
      <td>Intercharacter spacing</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Mapping mode</td>
      <td>MM_TEXT</td>
    </tr>
    <tr>
      <td>Pen</td>
      <td>BLACK_PEN</td>
    </tr>
    <tr>
      <td>Polygon-fill mode</td>
      <td>ALTERNATE</td>
    </tr>
    <tr>
      <td>Stretch mode</td>
      <td>BLACKONWHITE</td>
    </tr>
    <tr>
      <td>Text color</td>
      <td>Text color setting from Control Panel (typically, black)</td>
    </tr>
    <tr>
      <td>Viewport extent</td>
      <td>(1,1)</td>
    </tr>
    <tr>
      <td>Viewport origin</td>
      <td>(0,0)</td>
    </tr>
    <tr>
      <td>Window extent</td>
      <td>(1,1)</td>
    </tr>
    <tr>
      <td>Window origin</td>
      <td>(0,0)</td>
    </tr>
  </tbody>
</table>

<h4>表2-3 设备描述表的分类</h4>
<table id="tbrowser">
  <tbody>
    <tr>
      <td>Display</td>
      <td>显示设备描述表，提供对视频显示设备上的绘制操作的支持</td>
    </tr>
    <tr>
      <td>Printer</td>
      <td>打印设备描述表，提供对打印机、绘图仪设备上的绘制操作的支持</td>
    </tr>
    <tr>
      <td>Memory</td>
      <td>内存设备描述表，提供对位图操作的支持</td>
    </tr>
    <tr>
      <td>Information</td>
      <td>信息设备描述表，提供对操作设备信息获取的支持</td>
    </tr>
  </tbody>
</table>
<p>表2-3中的显示设备描述表又分三种类型，如表2-4所示。</p>
<h4>表2-4 显示设备描述表的分类</h4>
<table id="tbrowser">
<col width="20%" />
<col width="30%" />
<col width="50%" />
  <tbody>
    <tr>
      <td>名称</td>
      <td>特点</td>
      <td>功能</td>
    </tr>
    <tr>
      <td>Class Device Contexts</td>
      <td>提供对Win16的向后兼容</td>
      <td>　</td>
    </tr>
    <tr>
      <td>Common Device Contexts</td>
      <td>在Windows系统的高速缓冲区，数量有限</td>
      <td>Applicaion获取设备描述表时，Windows用缺省值初始化该设备描述表，Application使用它完成绘制操作，然后释放</td>
    </tr>
    <tr>
      <td>Private Device Contexts</td>
      <td>没有数量限制，用完不需释放一次获取，多次使用</td>
      <td>多次使用过程中，每次设备描述表属性的任何修改或变化都会被保存，以支持快速绘制</td>
    </tr>
  </tbody>
</table>


<p>（1）使用设备描述表的步骤</p>
<p>要使用设备描述表，一般有如下步骤：</p>

<p>获取或者创建设备描述表；
</p>

<p>必要的话，改变设备描述表的属性；
</p>

<p>使用设备描述表完成绘制操作；
</p>

<p>释放或<strong>删除</strong>设备描述表。
</p>
<p>Common设备描述表通过::GetDC，::GetDCEx，::BeginPaint来获得一个设备描述表，用毕，用::ReleaseDC或::EndPaint释放设备描述表；</p>
<p>Printer设备描述表通过::CreateDC创建设备描述表，用::DeleteDC<strong>删除</strong>设备描述表。</p>
<p>Memory设备描述表通过::CreateCompatibleDC创建设备描述表，用::DeleteDC<strong>删除</strong>。</p>
<p>Information设备描述表通过::CreateIC创建设备描述表，用::DeleteDC<strong>删除</strong>。</p>
<p>（2）改变设备描述表属性的途径</p>
<p>要改变设备描述表的属性，可通过以下途径：</p>
<p>用::SelectObject选入新的除调色板以外的GDI Object到设备描述表中；</p>
<p>对于调色板，使用::SelectPalette函数选入逻辑调色板，并使用::RealizePalette把逻辑调色板的入口映射到物理调色板中。</p>
<p>用其他API函数改变其他属性，如::SetMapMode改变映射模式。</p>

<strong>设备描述表在MFC中的实现</strong>

<p>MFC提供了CDC类作为设备描述表类的基类，它封装了Windows的HDC设备描述表对象和相关函数。</p>

CDC类

<p>CDC类包含了各种类型的Windows设备描述表的全部功能，封装了所有的Win32 GDI 函数和设备描述表相关的SDK函数。在MFC下，使用CDC的成员函数来完成所有的窗口绘制工作。</p>
<p>CDC 类的结构示意图2-2所示。</p>

<p>CDC类有两个成员变量：m_hDC，m_hAttribDC，它们都是Windows设备描述表句柄。CDC的成员函数作输出操作时，使用m_Hdc；要获取设备描述表的属性时，使用m_hAttribDC。</p>
<p>在创建一个CDC类实例时，缺省的m_hDC等于m_hAttribDC。如果需要的话，程序员可以分别指定它们。例如，MFC框架实现CMetaFileDC类时，就是如此：CMetaFileDC从物理设备上读取设备信息，输出则送到元文件（metafile）上，所以m_hDC和m_hAttribDC是不同的，各司其责。还有一个类似的例子：打印预览的实现，一个代表打印机模拟输出，一个代表屏幕显示。</p>
<p>CDC封装::SelectObject(HDC hdc，HGDIOBJECT hgdiobject)函数时，采用了重载技术，即它针对不同的<strong>GDI对象</strong>，提供了名同而参数不同的成员函数：</p>
<p>SelectObject(CPen *pen)用于选入笔；</p>
<p>SelectObject(CBitmap* pBitmap)用于选入位图；</p>
<p>SelectObject(CRgn *pRgn)用于选入剪裁区域；</p>
<p>SelectObject(CBrush *pBrush)用于选入刷子；</p>
<p>SelectObject(CFont *pFont)用于选入字体；</p>
<p>至于调色板，使用SelectPalette(CPalette *pPalette，BOOL bForceBackground )选入调色板到设备描述表，使用RealizePalletter()实现逻辑调色板到物理调色板的映射。</p>

从CDC派生出功能更具体的设备描述表

<p>从CDC 派生出四个功能更具体的设备描述表类。层次如图2-3所示。</p>


<p>下面，分别讨论派生出的四种设备描述表。</p>

<h4>CCientDC</h4>

<p>代表窗口客户区的设备描述表。其构造函数CClientDC(CWnd *pWin)通过::GetDC获取指定窗口的客户区的设备描述表HDC，并且使用成员函数Attach把它和CClientDC对象捆绑在一起；其析构函数使用成员函数Detach把设备描述表句柄HDC分离出来，并调用::ReleaseDC释放设备描述表HDC。</p>

<h4>CPaintDC</h4>

<p>仅仅用于响应WM_PAINT消息时绘制窗口，因为它的构造函数调用了::BeginPaint获取设备描述表HDC，并且使用成员函数Attach把它和CPaintDC对象捆绑在一起；析构函数使用成员函数Detach把设备描述表句柄HDC分离出来，并调用::EndPaint释放设备描述表HDC，而::BeginPaint和::EndPaint仅仅在响应WM_PAINT时使用。</p>

<h4>CMetaFileDC</h4>

<p>用于生成元文件。</p>

<h4>CWindowDC</h4>

<p>代表整个窗口区(包括非客户区)的设备描述表。其构造函数CWindowDC(CWnd *pWin)通过::GetWindowDC获取指定窗口的客户区的设备描述表HDC，并使用Attach把它和CWindowDC对象捆绑在一起；其析构函数使用Detach把设备描述表HDC分离出来，调用::ReleaseDC释放设备描述表HDC。</p>

<strong><h4>MFC设备描述表类的使用</h4></strong>


<h4>使用CPaintDC、CClientDC、CWindowDC的方法
</h4>
<p>首先，定义一个这些类的实例变量，通常在栈中定义。然后，使用它。</p>
<p>例如，MFC中CView对WM_PAINT消息的实现方法如下：</p>
<p>void CView::OnPaint()</p>
<p>{</p>
<p>// standard paint routine</p>
<p>CPaintDC dc(this);</p>
<p>OnPrepareDC(&amp;dc);</p>
<p>OnDraw(&amp;dc);</p>
<p>}</p>
<p>在栈中定义了CPaintDC类型的变量dc，随着构造函数的调用获取了设备描述表；设备描述表使用完毕，超出其有效范围就被自动地清除，随着析构函数的调用，其获取的设备描述表被释放。</p>
<p>如果希望在堆中创建，例如</p>
<p>CPaintDC *pDC；</p>
<p>pDC = new CPaintDC(this)</p>
<p>则在使用完毕时，用delete<strong>删除</strong>pDC:</p>
<p>delete pDC;</p>


<h4>直接使用CDC</h4>

<p>需要注意的是：在生成CDC对象的时候，并不像它的派生类那样，在构造函数里获取相应的Windows设备描述表。最好不要使用::GetDC等函数来获取一个设备描述表，而是创建一个设备描述表。其构造函数如下：</p>
<p>CDC::CDC()</p>
<p>{</p>
<p>m_hDC = NULL;</p>
<p>m_hAttribDC = NULL;</p>
<p>m_bPrinting = FALSE;</p>
<p>}</p>
<p>其析构函数如下：</p>
<p>CDC::~CDC()</p>
<p>{</p>
<p>if (m_hDC != NULL)</p>
<p>::DeleteDC(Detach());</p>
<p>}</p>
<p>在CDC析构函数中，如果设备描述表句柄不空，则调用DeleteDC<strong>删除</strong>它。这是直接使用CDC时最好创建Windows设备描述表的理由。如果设备描述表不是创建的，则应该在析构函数被调用前分离出设备描述表句柄并用::RealeaseDC释放它，释放后m_hDC为空，则在析构函数调用时不会执行::DeleteDC。当然，不用担心CDC的派生类的析构函数调用CDC的析构函数，因为CDC::~CDC()不是虚拟析构函数。</p>
<p>直接使用CDC的例子是内存设备上下文，例如：</p>
<p>CDC dcMem; //声明一个CDC对象</p>
<p>dcMem.CreateCompatibleDC(&amp;dc); //创建设备描述表</p>
<p>pbmOld = dcMem.SelectObject(&amp;m_bmBall);//更改设备描述表属性</p>
<p>…//作一些绘制操作</p>

<p>dcMem.SelectObject(pbmOld);//恢复设备描述表的属性</p>
<p>dcMem.DeleteDC(); //可以不调用，而让析构函数去<strong>删除</strong>设备描述表</p>

<strong><strong>GDI对象</strong></strong>

<p>在讨论设备描述表时，已经多次涉及到<strong>GDI对象</strong>。这里，需强调一下：<strong>GDI对象</strong>要选入Windows 设备描述表后才能使用；用毕，要恢复设备描述表的原<strong>GDI对象</strong>，并<strong>删除</strong>该<strong>GDI对象</strong>。</p>
<p>一般按如下步骤使用<strong>GDI对象</strong>：</p>
<p>Create or get a GDI OBJECT hNewGdi;</p>

<p>hOldGdi = ::SelectObject(hdc, hNewGdi)</p>
<p>……</p>
<p>::SelectObject(hdc, hOldGdi)</p>
<p>::DeleteObject(hNewGdi)</p>
<p>先创建或得到一个<strong>GDI对象</strong>，然后把它选入设备描述表并保存它原来的<strong>GDI对象</strong>；用毕恢复设备描述表原来的<strong>GDI对象</strong>并<strong>删除</strong>新创建的<strong>GDI对象</strong>。</p>
<p>需要指出的是，如果hNewGdi是一个Stock <strong>GDI对象</strong>，可以不<strong>删除</strong>（<strong>删除</strong>也可以）。通过</p>
<p>HGDIOBJ GetStockObject(</p>
<p>int fnObject // type of stock object</p>
<p>);</p>
<p>来获取Stock <strong>GDI对象</strong>。</p>


<h4>MFC GDI对象</h4>

<p>MFC用一些类封装了Windows <strong>GDI对象</strong>和相关函数，层次结构如图2-4所示：</p>

<img height="176" hspace="12" src="http://www.vczx.com/tutorial/mfc/image109.gif" width="373" align="left" alt="" />

<p>CGdiObject封装了Windows GDI Object共有的特性。其派生类在继承的基础上，主要封装了各类GDI的创建函数以及和具体<strong>GDI对象</strong>相关的操作。</p>

<img height="125" hspace="12" src="http://www.vczx.com/tutorial/mfc/image110.gif" width="372" align="left" alt="" />
<p>CGdiObject的构造函数仅仅让m_hObject为空。如果m_hObject不空，其析构函数将<strong>删除</strong>对应的Windows <strong>GDI对象</strong>。MFC <strong>GDI对象</strong>和Windows <strong>GDI对象</strong>的关系如图2-5所示。</p>

<h4>使用MFC GDI类的使用</h4>

<p>首先创建<strong>GDI对象</strong>，可分一步或两步创建。一步创建就是构造MFC对象和Windows <strong>GDI对象</strong>一步完成；两步创建则先构造MFC对象，接着创建Windows <strong>GDI对象</strong>。然后，把新创建的<strong>GDI对象</strong>选进设备描述表，取代原<strong>GDI对象</strong>并保存。最后，恢复原<strong>GDI对象</strong>。例如：</p>
<p>void CMyView::OnDraw(CDC *pDC)</p>
<p>{</p>
<p>CPen penBlack; //构造MFC CPen对象</p>
<p>if (penBlack.CreatePen(PS_SOLID, RGB(0, 0, 0)))</p>
<p>{</p>
<p>CPen *pOldPen = pDC-&gt;SelectObject(&amp;penBlack)); //选进设备表，保存原笔</p>
<p>…</p>
<p>pDC-&gt;SelectObject(pOldPen); //恢复原笔</p>
<p>}else</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>}</p>
<p>和在SDK下有一点不同的是：这里没有DeleteObject。因为执行完OnDraw后，栈中的penBlack被销毁，它的析构函数被调用，导致DeleteObject的调用。</p>
<p>还有一点要说明：</p>
<p>pDC-&gt;SelectObject(&amp;penBlack)返回了一个CPen *指针，也就是说，它根据原来PEN的句柄创建了一个MFC CPen对象。这个对象是否需要<strong>删除</strong>呢？不必要，因为它是一个临时对象，MFC框架会自动地<strong>删除</strong>它。当然，在本函数执行完毕把控制权返回给主消息循环之前，该对象是有效的。</p>
<p>关于临时对象及MFC处理它们的内部机制，将在后续章节详细讨论。</p>
<p>至此，Windows编程的核心概念：窗口、GDI界面（设备描述表、<strong>GDI对象</strong>等）已经陈述清楚，特别揭示了MFC对这些概念的封装机制，并简明讲述了与这些Windows Object对应的MFC类的使用方法。还有其他Windows概念，可以参见SDK开发文档。在MFC的实现上，基本上仅仅是对和这些概念相关的Win32函数的封装。如果明白了MFC的窗口、GDI界面的封装机制，其他就不难了。</p>
<p><a href="http://blog.csdn.net/xjh_love_paopao/article/details/2544409">ref</a></p>

<h3>C++ Windows对象和MFC对象的区别</h3>
<p>windows对象并不是我们平时所说的“面向对象”程序设计中的“类的对象”，而是一种windows资源实体，如画笔、字体等，</p>
<p>如果想要去使用这些windows对象我们需要用句柄来标识它们。</p>
<p>（好比在共产主义社会，句柄就像车钥匙，windows资源实体就是国家的大车库，按需去取，那些车只有配上你的车钥匙才能用）</p>
<p>而MFC对象则是真正的“面向对象”思想中的“类的对象”(必须用构造函数去创建)。</p>
<p>在windows编程中，除了普通的“类的对象”外，用得最多的“C++类的对象”应该是MFC对象了（如果你是用MFC编程的话），</p>
<p>MFC对象是指“封装了windows对象的C++对象”（也就是MFC对象中有一个控制window对象的控制器，那么控制器想工作就得和一个window对象链接起来，这样就能控制器就能控制这个对象了）。</p>
<p>就拿CWnd类来说，我们定义一个CWnd类的对象myWnd后，我们不能直接对它进行显示移动等操作（相当于我们还不能使用它），为什么呢？</p>
<p>因为我们还没有给它封装一个相应的windows对象（注意：CWnd类有一个成员变量　HWND m_hWnd　），所以我们要调用成员函数Create()。</p>
<p>而这个Create()的功能就是建立一个windows窗口类实例（它也是windows对象的一种，同样我们也是用句柄来标识它，这里我们用HWND类型句柄）并把这个窗口实例的句柄链到CWnd类的对象的成员变量m_hWnd上）。</p>

<p>当然，这里之所以用Create()这一个函数就能实现的功能，在用API函数来实现就比较麻烦，但可以让我们更清楚地了解这一过程：</p>

<p>CWnd myWnd;　　　//定义一个窗口类(CWnd)的对象</p>

<p>HWND hWnd;　　　//定义窗口句柄hwnd</p>

<p>hwnd=CreateWindows(……);　　//调用API函数CreateWindows(……)建立一个windows窗口类实例，返回的是一个句柄，并把这个句柄赋给hWnd句柄。</p>

<p>myWnd.Attach(hwnd);　　　//将窗口实例的句柄链到CWnd对象myWnd上。</p>

<p>……</p>

<p>Destrory Window(hwnd);</p>

<p></p>

<p>正为为很多人不知道其中的细节，所以在学习MFC Windows编程的时候，总是想不通为什么创建了一个MFC类的对象还要调用那么多初始化之类的函数，才能调用其它功能函数。而我们在平时创建一个C++对象之后总是能直接调用它的成员函数。</p>

<p>所谓Windows对象是Win32下用句柄表示的Windows操作系统对象；</p>
<p>所谓MFC对象就是C++对象，是一个C++类的实例.</p>

<p></p>

<p>一个MFC窗口对象是一个C++  CWnd类（或派生类）的实例，是程序直接创建的。</p>
<p>在程序执行中它随着窗口类构造函数的调用而生成，随着析构函数的调用而消失。</p>
<p></p>

<p></p>
<p>而Windows窗口则是Windows系统的一个内部数据结构的实例，由一个“窗口句柄”标识，Windows系统创建它并给它分配系统资源。</p>
<p>Windows窗口在MFC窗口对象创建之后，由CWnd类的Create成员函数创建，“窗口句柄”保存在MFC窗口对象的m_hWnd成员变量中。</p>
<p></p>

<p></p>
<p>Windows窗口可以被一个程序销毁，也可以被用户的动作销毁。</p>
<p> </p>
<p>MFC窗口的创建和windwos窗口的创建是有区别的,</p>
<p>MFC  Object通过构造函数由程序直接创建；</p>
<p>Windows  Object由相应的SDK函数创建。  </p>
<p> </p>
<p>MFC中，使用这些MFC 对象，一般分两步：</p>

<p>1、创建一个MFC  对象（在STACK中创建或者在HEAP中创建），这时MFC  对象的句柄实例变量为空也就是此时它不是一个有效的句柄。</p>

<p>2、调用MFC 对象的成员函数创建相应的Windows  对象，MFC的句柄变量存储一个有效句柄（这个句柄控制着Windows 对象）。</p>

<p></p>

<p>当然，可以在MFC  对象的构造函数中创建相应的Windows对象（给MFC对象的句柄变量实例化），</p>
<p>MFC的GDI类就是如此实现的，但从实质上讲，MFC 对象的创建和Windows  对象的创建是两回事。</p>

<p></p>

<p>无论是控制windows窗口的属性还是它的状态，两者基本上没有什么不同，</p>
<p>SetWindowText(...),SetIcon(...)，SetMenu(...),只不过window 对象多了一个句柄的参数罢了。 </p>
<h3></h3>
<div>
<div id="ftsize1"><a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em">大</a></div>
<div id="ftsize2"><a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em">中</a></div>
<div id="ftsize3"><a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em">小</a></div>
<div style="display:none" id="goTopBtn"><a target="_self" style="color:#fff;">&and;</a></div>
<div style="display:none" id="shangy">
	<a onclick="shangy()" target="_self" style="color:#fff;">&uarr;</a></div>
<div id="xiay">
	<a onclick="xiay()" target="_self" style="color:#fff;">&darr;</a></div>
<div id="goBottom">
	<a onclick="downn()" target="_self" style="color:#fff;">&or;</a></div>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>

<!--_____________________________________________________________________________________1 段落替换：</p>

<p>------------------</p>

<p>_____________________________________________________________________________________2 汉字中间的空格替换：([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])------------------$1$2_____________________________________________________________________________________3 段落前的空格替换[\s*</p>\s*][\s*<p>\s*]------------------</p>

<p>_____________________________________________________________________________________4 把第和章两个字去掉第(\S*)章------------------$1_____________________________________________________________________________________7 正则表达式参考：https://www.toutiao.com/i6370960744082571778/_____________________________________________________________________________________8<p class="picsay"><p class="picsay"><p class="code0"><p class="code2"><p class="code4">_____________________________________________________________________________________-->