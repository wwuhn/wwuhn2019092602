<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">

<p>构造函数是特殊的成员函数</p>

<p>构造函数是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型。而与其他成员函数相同的是，构造函数也有形参表（可能为空）和函数体。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。</p>

<p>构造函数的形参指定了创建类类型对象时使用的初始化式。通常，这些初始化式会用于初始化新创建对象的数据成员。构造函数通常应确保其每个数据成员都完成了初始化。</p>


<p>构造函数是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值。</p>

<p>用于初始化一个对象的实参类型决定使用哪个构造函数。</p>



<p>无参构造函数：定义对象的时候，对象后不能加括号。如：class stu{ stu(){"无参构造函数"}}; stu st;(正确定义对象)。</p>


<p>深拷贝意味着拷贝了资源（new了新内存空间）和指针，而浅拷贝只是拷贝了指针，没有拷贝资源。这样会使得两个指针指向同一份资源，造成对同一份析构两次，程序崩溃。临时对象的开销比局部对象小些。</p>




<p>调用默认的拷贝构造函数相当于执行下列操作：</p>

<p>        arr1.low = arr2.low;</p>

<p>        arr1.high = arr2.high;</p>

<p>        arr1.storage = arr2.storage;</p>

<p>       前两个操作没有问题，第三个操作中，storage是一个指针，第三个操作意味着使arr1的storage指针和arr2的storage指针指向同一块空间。</p>

<p>一个对象的修改将会影响另一个对象</p>

<p>如果两个对象的作用域不同，当一个对象析构时，另一个对象也将丧失它的空间</p>


<p>构造函数和析构函数的作用是什么？它们各有什么特征？ </p>

<p>构造函数是在对象定义时自动执行，为对象赋初值。析构函数是对象销毁时自动调用， </p>

<p>做一些善后工作。构造函数的名字就是类名，析构函数的名字是波浪号加类名。构造函数和析构函数都不需要写函数的返回类型。对象可能有不同的构造方法，所以类可以有一组重载的构造函数，但析构函数只能有一个。构造函数还可以有一个初始化列表。 </p>


<p>什么情况下类必须定义自己的复制构造函数？ </p>

<p>如果类的数据成员中含有指针，而指针指向的是一个动态变量，必须自己定义复制构造函数。或对复制构造有其他特殊的要求也需要定义复制构造函数。 </p>
<p>复制构造函数的参数为什么一定要用引用传递，而不能用值传递？ </p>

<p>值传递的参数在参数传递时有一个构造过程，即用实际参数的值构造形式参数，这个构造过程是由复制构造函数完成的。如果将复制构造函数的参数设计成值传递，会引起复制构造函数的递归调用。 </p>



<p>构造函数为什么要有初始化列表？ </p>

<p>构造函数的初始化列表可以将数据成员的构造和赋初值一起完成，提高对象构造的时间性能。除此之外，还有两种情况必须用初始化列表。第一种情况是数据成员中含有一些不能用赋值操作进行赋值的数据成员，例如常量数据成员或对象数据成员，这时必须在初始化列表中调用数据成员所属类型的构造函数来构造它们。第二种情况是在用派生的方法定义一个类时，派生类对象中的基类部分必须在构造函数的初始化列表中调用基类的构造函数完成。 </p>


<p>构造函数和析构函数是特殊的成员函数</p>

<p>构造函数：为对象分配空间，进行初始化。</p>

<p>析构函数：执行与构造函数相反的操作，通常执行一些清理工作，如释放分配给对象的空间等。</p>

<p>构造函数还有一个与普通函数不同的地方，就是可以包含一个构造函数初始化列表。</p>

<p>构造函数初始化列表位于函数头和函数体之间。它以一个冒号开头，接着是一个以逗号分隔的数据成员列表</p>

<p>每个数据成员的后面跟着一个放在圆括号中的对应于该数据成员的构造函数的实际参数表。</p>

<p>如IntArray的构造函数可写为</p>

<p>    IntArray :: IntArray(int lh, int rh): low(lh), high(rh)</p>

<p>    { storage = new int [high - low + 1];  }</p>

<p>事实上，不管构造函数中有没有构造函数初始化列表，在执行构造函数体之前，都要先初始化每个数据成员。</p>

<p>在构造函数初始化列表中没有提到的数据成员，系统会用该数据成员对应类型的默认构造函数对其初始化。</p>

<p>显然利用初始化列表可以提高构造函数的效率。在初始化的时候，同时完成了赋初始的工作。</p>

<p><strong>必须用初始化的情况：</strong></p>

<p>数据成员不是普通的内置类型，而是某一个类的对象，可能无法直接用赋值语句在构造函数体中为它赋初值</p>

<p>类包含了一个常量的数据成员，常量只能在定义时对它初始化，而不能对它赋值。因此也必须放在初始化列表中。</p>

<p>拷贝构造函数以一个同类对象引用作为参数，它的原型为：</p>

<p>     类名（const  <类名> &）；</p>

<p>如果用户没有定义拷贝构造函数，系统会定义一个缺省的拷贝构造函数。该函数将已存在的对象原式原样地复制给新成员</p>

<p>何时需要自定义拷贝构造函数</p>

<p>一般情况下，默认的拷贝构造函数足以满足要求。</p>

<p>但某些情况下可能需要设计自己的拷贝构造函数。</p>

<p>例如，我们希望对IntArray类增加一个功能，能够定义一个和另一个数组完全一样的数组。但默认的拷贝构造函数却不能胜任。如果正在构造的对象为arr1，作为参数的对象是arr2，调用默认的拷贝构造函数相当于执行下列操作：</p>

<p>        arr1.low = arr2.low;</p>

<p>        arr1.high = arr2.high;</p>

<p>        arr1.storage = arr2.storage;</p>

<p>       前两个操作没有问题，第三个操作中，storage是一个指针，第三个操作意味着使arr1的storage指针和arr2的storage指针指向同一块空间（特别是当有动态内存申请时）。 </p>

<p>使用同一块空间的问题：</p>

<p>一个对象的修改将会影响另一个对象</p>

<p>如果两个对象的作用域不同，当一个对象析构时，另一个对象也将丧失它的空间</p>


<pre>
IntArray(const IntArray &arr)
{
    low = arr.low;
    high = arr.high;
    storage = new int [high – low + 1];
    for (int i = 0; i < high –low + 1; ++i)  
        storage[i] = arr.storage[i];
}
</pre>

<p>拷贝构造函数的应用场合</p>

<p>对象定义时 </p>

<p>把对象作为参数传给函数时 </p>

<p>把对象作为返回值时</p>

<p>拷贝构造函数用于对象构造时有两种用法：直接初始化和拷贝初始化。</p>

<p>直接初始化将初始值放在圆括号中，直接调用与实参类型相匹配的构造函数。如</p>

<p>      IntArray array2(array1);</p>

<p>拷贝初始化是用“=”符号。当使用拷贝初始化时，首先会用“=”右边的表达式构造一个临时对象，再调用拷贝构造函数将临时对象复制到正在构造的对象。如</p>

<p>      IntArray array =  IntArray(20,30);</p>

<pre>
例：
    class A
    {    
        A(int size);        //构造函数
        const int SIZE;
    }
    A::A(int size) : SIZE(size)    //构造函数的初始化表
    {…}
    A a(100);    //对象a的SIZE的值为100
    A b(200);    //对象b的SIZE的值为200
</pre>



<p>如果构造函数中存在动态内存申请时，请要考虑深拷贝和浅拷贝了。</p>

<p>拷贝构造函数与赋值运算符的区别。</p>

<p>CTest a;</p>

<p>CTest b(a); //拷贝构造，因为B不存在，所以称为构造</p>

<p>CTtest c = a; //调用拷贝构造函数，也是因为C不存在；</p>

<p>c = b; //调用赋值运算符，此时对象C已经存在</p>


<p>析构函数(destructor)是类的成员函数，在类的对象离开作用域之后自动调用。例如，假定类类型的对象是某函数的局部变量，调用析构函数就是函数调用结束前采取的最后一项行动。析构函数销毁由对象创建的任何动态变量，将其占用的内存还给自由存储。析构函数还可执行其他清理工作。析构函数的名称必须由~符号和类名构成。</p>

<p>拷贝构造函数获取一个传引用参数，该参数具有与类相同的类型。参数必须传引用。通常，该参数也是常量参数，要在它前面附加参数修饰符const。只要某个函数返回类类型的值，就会自动调用那个类的拷贝构造函数。在类类型的传值参数位置“插入”实参时，也会自动调用拷贝构造函数。拷贝构造函数还可采取与其他构造函数相同的方式来使用。</p>

<p>凡是使用了指针和操作符new 的类，都应该有一个拷贝构造函数。</p>



<p>析构函数是类的一种特殊成员函数，在类的对象离开作用域时自动调用。析构函数的主要使命是将内存还给自由存储，使内存得以重用。</p>

<p>拷贝构造函数是一种特殊构造函数，它有一个参数，该参数具有与类相同的类型。定义了拷贝构造函数之后，只要函数返回类类型的值，或者在类类型的一个传值参数位置“插入”一个实参，就会自动调用这个构造函数。使用了指针和操作符new 的任何类都应包含一个拷贝构造函数。</p>


<p>C++支持使用赋值语法或者构造函数语法调用拷贝构造函数。</p>

<p>拷贝构造函数的形参必须采用别名（引用）生成方式，如果是赋值方式，则会造成拷贝构造函数的无穷递归调用。</p>

<p>默认拷贝构造函数：用源对象的每个数据成员来初始化目标对象的对应数据成员。</p>

<p>如果数据成员是一个指向动态数组的指针，那么，默认拷贝会导致新对象的指针和源对象的指针指向同一个动态数组。当新对象或者源对象其中之一消亡时，会通过delete指针释放掉动态数组，这时，另一个对象的指针就指向了无效的动态数组，成为虚悬指针，此时很有必要提供自己的拷贝构造函数。</p>

<p>拷贝构造函数不仅是在我们定义对象时会被调用，实际上，在需要通过同类对象克隆产生新对象的任何时候，都可能会调用拷贝构造函数。常见两种情况：</p>

<p>1 函数按值返回一个对象；</p>

<p>2 调用调用时克隆生成形参对象；</p>



<p>所谓构造式（constructor），就是对象诞生后第一个执行（并且是自动执行）的函数，它的函数名称必定要与类别名称相同。相对于构造式，自然就有个析构式（destructor），也就是在对象行将毁灭但未毁灭之前一刻，最后执行（并且是自动执行）的函数，它的函数名称必定要与类别名称相同，再在最前面加一个~ 符号。</p>

<p>一个有着阶层架构的类别群组，当衍生类别的对象诞生之时，构造式的执行是由最基础类别（most based）至最尾端衍生类别（most derived）；当对象要毁灭之前，析构式的执行则是反其道而行。</p>

<p>对于全域对象，程序一开始，其构造式就先被执行（比程序进入点更早）；程序即将结束前其析构式被执行。</p>

<p>对于区域对象，当对象诞生时，其构造式被执行；当程序流程将离开该对象的存活范围（以至于对象将毁灭），其析构式被执行。</p>


<p>对于以new 方式产生出来的区域对象，当对象诞生时其构造式被执行。析构式则在对象被delete 时执行。</p>


<p>指针在堆上new出一块内存时，需要手动释放这块内存，当异常发生时，即使有释放的代码，但也有可能因为异常而跳过释放内存的代码，而产生内存泄漏。</p>

<p>因为你在类中是不能直接给private中的类成员赋值的(类声明是不分配内存空间的，要在实例化时才分配内存空间。)，所以就靠构造函数，不过要注意有参构造和无参构造。</p>

<p>对于在全局作用域中定义的对象，它们的构造函数是在文件中所有其他函数（包括main）开始执行之前被调用的（但无法保证不同文件的全局对象构造函数的执行顺序）。对应的析构函数是在终止main之后调用的。</p>

<p>exit函数会迫使程序立即终止，而不会执行自动对象的析构函数。这个函数经常用来在检测到输入错误或者程序所处理的文件无法打开时终止程序。</p>

<p>abort函数与exit函数功能相似，但它会迫使程序立即终止，而不允许调用任何对象的析构函数。abort函数通常用来表明程序的非正常终止。</p>

<p>自动局部变量的构造函数是在程序的执行到达定义这个对象的位置时调用的，而对应的析构函数是在程序离开这个对象的作用域时调用的（即定义这个对象的代码完成了执行）。每次执行进入和离开自动对象的作用域时，都会调用它的构造函数和析构函数。如果程序调用了exit或abort函数而终止，则不会调用自动对象的析构函数。</p>

<p>静态局部对象的析构函数只调用一次，即执行首次到达定义这个对象的位置时。对应的析构函数是在main终止或程序调用exit函数时调用的。</p>



<h4>2</h4>

<p>拷贝构造函数生成新的类对象，而赋值运算符不能。当进行一个类的实例初始化时，调用的是构造函数，但如是用其他实例来初始化，则调用拷贝构造函数，非初始化时对这个实例进行赋值调用的是赋值运算符。</p>
<p>当类中的数据成员中使用new运算符，动态地申请存储空间进行赋初值时，必须在类中显式地定义一个完成拷贝功能的构造函数，以便正确实现数据成员的复制。</p>










</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>

<!--
_____________________________________________________________________________________

1 段落替换
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])


------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________

4 把第和章两个字去掉
第(\S*)章
------------------
$1
_____________________________________________________________________________________

7 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/
_____________________________________________________________________________________

8
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
9 将标注序号更改为上标，红色，需一个个替换，英文html中有[1]
(\[\d\])
------------------
<sup>$1</sup>
_____________________________________________________________________________________
10 替换章不是以1-9。?！…”“结尾的段落
([^1-90。?！…”：？“章])</p>
<p>
------------------
$1
-->


