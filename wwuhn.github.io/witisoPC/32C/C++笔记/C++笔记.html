<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script language="javascript"> 
//bg_even("表格ID属性名","奇数行背景色","偶数行背景色","鼠标经过背景色","点击后背景色");
function bg_even(o,a,b,c,d){
        var t=document.getElementById(o).getElementsByTagName("tr");
        for(var i=0;i<t.length;i++){
                t[i].style.backgroundColor=(t[i].sectionRowIndex%2==0)?a:b;
                t[i].onclick=function(){
                        if(this.x!="1"){
                                this.x="1";
                                this.style.backgroundColor=d;
                        }else{
                                this.x="0";
                                this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                        }
                }
                t[i].onmouseover=function(){
                        if(this.x!="1")this.style.backgroundColor=c;
                }
                t[i].onmouseout=function(){
                        if(this.x!="1")this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                }
        }
}

 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>C++笔记</title>

<style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.6em;
}
P{
margin:16px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 100px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 70px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#goBottom:hover{
background-color:white;
border:#ccc 1px solid;
color:red;
}
 
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}
.floatr{
float:right;
padding-right:5px;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
img{
border:0;
}
.picsay{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
}
.code0{
color:red;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:0em;
}
.code2{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:2em;
}
.code4{
color:blue;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
text-indent:4em;
}
sub,sup{
font-size:80%;
color:red;
}
</style>
</head>

<body> 
<div class="container">



<p>win32 Console application:手动在source file中添加main.cpp，以命令行窗口显示运行结果；</p>





<p>extern的作用是通知编译器，在本CPP中要用到某个符号，这个符号可能不在本CPP中定义。它表示在某个CPP文件中，存在这么一个函数/全局变量。</p>





<p>数据封装－结构体：现代程序设计语言的一大特点是能够将各自独立的数据或操作组织成一个整体。过程和函数可以将一组操作封闭成一个整体。在数据处理方面，数组可以将类型相同的一组有序数据封装成一个整体。需要时可以从数组中选出元素，并单独进行操作。也可以将他们作为一个整体，同时进行操作。此外，我们同样需要能够将一组无序的、异质的数据看作一个整体进行操作。在程序设计语言中，这样的一组数据被称为记录。在C++语言中，称为结构体。</p>




<p>同时,C++语言提供了丰富的数据类型，用以约定数据的规格，包括数据的存储空间大小、编码和解码方式以及数据可接受的运算处理。</p>
<p>1 内置数据类型：描述常用的整型、字符型、浮点型数据；</p>

<p>2 复合数据类型：描述常变量、数组、指针、引用等复合数据。</p>

<p>3 定制数据类型：定制我们自己的数据类型，约定数据的规格，包括存储空间大小、编码和解码方式及其可接受运算处理行为。</p>

<p>C++语言为描述数据处理过程提供了丰富的语法工具，包括：</p>

<p>1 描述最基本的数据运算行为：运算符和表达式语句；</p>

<p>2 描述数据处理的控制流程：流程控制语句；</p>

<p>3 描述复杂的输入和输出：输入输出流类库；</p>

<p>4 复杂的数据处理过程：复合语句和控制语句；</p>
<p>C++常见转义字符：\n换行；\r回车；\\反斜杠；\'单引号；\"双引号；\0空字符(NULL)；</p>




<p>对于C++应用程序来说，数据主要有两种存储方式，一种是栈存储方式，另一种是堆存储方式。栈存储方式通常用于存储占用空间小、生命周期短的数据，如局部变量和函数参数等。堆存储通常用于存储占用空间大、生命周期长的数据，如静态变量和全局变量等，以及用new运算符开辟出的空间。</p>






<p>变量的4个属性：变量名称、数据类型、变量地址、变量的值；变量地址由系统分配给变量一个内在单元编号。C++可以用&(地址运算符)加变量名称得到一个变量的地址；</p>







<p>C++是面向对象的编程语言。它提供了许多功能，如下所示。</p>
<p>简单(Simple)</p>
<p>机器独立或可移植(Portable)</p>
<p>中级编程语言(Mid-level)</p>
<p>结构化编程语言(Structured)</p>
<p>丰富的程序库(RichLibrary)</p>
<p>内存管理(MemoryManagement)</p>
<p>速度快(FastSpeed)</p>
<p>指针(Pointers)</p>
<p>递归(Recursion)</p>
<p>可扩展(Extensible)</p>
<p>面向对象(ObjectOriented)</p>
<p>基于编译器(Compilerbased)</p>

<p>1.简单</p>
<p>C++是一种简单的语言，它提供了结构化方法(将问题分解成几个小部分)，丰富的库函数集，数据类型等。</p>
<p>2.机器独立或移植</p>
<p>与汇编语言不同，C/C++语言程序可以在许多机器中执行，但可能有一点点或没有变化。但它不是平台无关的。</p>
<p>3.中级编程语言</p>
<p>C++也用于做低级编程。它用于开发系统应用程序，如内核，驱动程序等。它还支持高级语言的特性。这就是为什么它被称为中级语言。</p>
<p>4.结构化编程语言</p>
<p>C++是一种结构化编程语言，我们可以使用函数将程序分解为多个小部分。所以，它很容易理解和修改。</p>
<p>5.丰富程序库</p>
<p>C++提供了许多内置函数(程序库)，一些常用的功能不用再去重头开始编写，有助于提高开发速度。</p>
<p>6.内存管理</p>
<p>它支持动态内存分配的特性。在C++语言中，可以通过调用free()函数随时释放分配的内存。</p>
<p>7.运行速度快</p>
<p>C++语言的编译和执行时间都非常快。</p>
<p>8.指针功能</p>
<p>C++提供指针的功能。可以通过使用指针直接与内存交互。我们可以使用内存，结构，函数，数组等指针。</p>
<p>9.递归</p>
<p>在C++中，可以调用函数内的函数。它为每个函数提供代码可重用性。</p>
<p>10.可扩展</p>
<p>C++语言是可扩展的，因为它可以比较容易地采用新的功能。</p>
<p>11.面向对象</p>
<p>C++是面向对象的编程(OOP)语言。OOP使开发和维护变得更容易，因为在面向过程的编程语言中，如果代码随着项目规模的增长而增长，就不容易管理。</p>
<p>12.基于编译器</p>




<p>namespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。</p>


<p>C++在说明函数原型时，可以为一个或多个参数指定缺省值。调用此函数时，若缺省某一参数，C++自动以缺省值作为此参数的值。</p>
<p>如：     </p>

<p>int special(int x=2, float y=1.5) </p>

<p>调用时可用：     </p>

<p>special(5,3.2) //x=5; y=3.2     </p>

<p>special(6)     //x=6; y=1.5     </p>

<p>special( )     //x=2; y=1.5</p>



<p>C++是一种基于编译器的编程语言，意思是没有编译就没有C++程序可以执行。首先，我们需要使用编译器编译程序，然后才能执行这个编译后的程序。</p>


<p>学完C以后进阶到C++的第一本书就是这本CP4。CP4确实是经典，但是它却不适合初学者，我当时读了大概有一半了，但是对很多东西还是一知半解。因为这本书是站在编译器的角度来写的，很多东西非常细节，事无巨细的论述对初学者一点好处也没有。初学者需要快速能先吸引眼球的东西。我比较推崇C++新手能先大致了解C++的各方面特性（注意是大致了解不是去抠细节），先有个感性认识再说，而且这样你也会觉得很有趣，不然那些复杂的细节真的会把你搞晕，让你对C++失去兴趣。</p>

<p>有心要学C++的朋友可以这样：先看一本入门读物，我推荐钱能的《C++程序设计教程》，大致看一遍，习题做一做，然后再把C++高级特性认真再复习一遍（类，继承，多态这三个最重要）。至于这本CP4可以当做参考书或者字典一样用，在语法上遇到什么问题或者编译有问题都可以再这本书里找答案，CP4是非常权威的，毕竟Lippman大大是第一个C++编译器的实现者之一。至于之后的进阶可以看看C++之父的《C++程序设计语言（特别版）》。如果对C++的底层实现有兴趣的话可以看看Lippman的《Inside the C++ Object Model》（深度探索C++对象模型），这本书比较难理解，可能要花点时间。如果想用VC++做开发工具的朋友，侯捷的《深入浅出MFC》一定不能错过，看这书你可能会上瘾的（我就是这样）。孙鑫的VC++视频也可以看看。</p>

<p>另外，如果大家想学好C++，就一定要让自己对C++这门语言有兴趣，如果明明自己不喜欢，千万不要逼自己去学，这样没有好处。一旦你喜欢上了C++，你还怕学不好它吗？再次提醒：第一次接触C++的人千万不要去死扣那些非常细节的东西，一定要先从大局上把握C++，细节问题以后再了解一点也不迟。</p>

<p>伟大的操作和数据打包成为面向对象的“类”概念，第2是运算符重载。</p>

<p>广博如四库全书者有之（The C++ Programming Language、C++ Primer、Thinking in C++），</p>

<p>深奥如重山复水者有之（The Annotated C++ Reference Manual, Inside the C++ Object Model），</p>

<p>细说历史者有之（The Design and Evolution of C++, Ruminations on C++），</p>

<p>独沽一味者有之（Polymorphism in C++），</p>

<p>独树一帜者有之（Design Patterns, Large Scale C++ Software Design, C++ FAQs），</p>

<p>另辟蹊径者有之（Generic Programming and the STL），</p>

<p>程序库大全有之（The C++ Standard Library），</p>

<p>专家经验之累积亦有之（Effective C++, More Effective C++）</p>



<p>显式转换也称为强制类型转换（cast），包括以下列名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。</p>

<p>命名的强制类型转换符号的一般形式如下：</p>

<p>     cast-name<type>(expression);</p>

<p>其中 cast-name 为 static_cast、dynamic_cast、const_cast 和reinterpret_cast 之一，type 为转换的目标类型，而 expression 则是被强制转换的值。强制转换的类型指定了在 expression 上执行某种特定类型的转换。</p>

<p>要理解复合表达式（即含有多个操作符的表达式）就必须先了解优先级、结合性以及操作数的求值次序。每一个操作符都有自己的优先级别和结合性。优先级规定复合表达式中操作符结合的方式，而结合性则决定同一个优先级的操作符如何结合。</p>

<p>大多数操作符没有规定其操作数的求值顺序：由编译器自由选择先计算左操作数还是右操作数。通常，操作数的求值顺序不会影响表达式的结果。但是，如果操作符的两个操作数都与同一个对象相关，而且其中一个操作数改变了该对象的值，则程序将会因此而产生严重的错误——而且这类错误很难发现。</p>

<p>最后，可以使用某种类型编写表达式，而实际需要的是另一类型的值。此时，编译器自动实现类型转换（既可以是内置类型也可以是为类类型而定义的），将特定类型转换为所需的类型。C还提供了强制类型转换显式地将数值转换为所需的数据类型。</p>

<p>associativity（结合性）</p>

<p>决定同一优先级的操作符如何结合。C++的操作符要么是左结合（操作符从左向右结合）要么是右结合（操作符从右向左结合）。</p>


<p>只希望计算文本中元音的总数，而不是每一个元音的个数，则可以这样写：</p>
<pre>
     int vowelCnt = 0;
     // ...
     switch (ch)
     {
         // any occurrence of a,e,i,o,u increments vowelCnt
         case 'a':
         case 'e':
         case 'i':
         case 'o':
         case 'u':
             ++vowelCnt;
             break;
     }
</pre>

<p>for 语句的语法形式是：</p>

<p>     for (init-statement condition; expression)</p>

<p>           statement</p>

<p>在()中，三部分中的某一部分可以是空，但分号;不能省略，某一部分可以用逗号操作符连接多个表达式；</p>

<p>do while 语句</p>

<p>在实际应用中，可能会要求程序员编写一个交互程序，为用户实现某种计算。一个简单的例子是：程序提示用户输入两个数，然后输出读入数之和。在输出和值后，程序可以让用户选择是否重复这个过程计算下一个和。</p>
<pre>
     // repeatedly ask user for pair of numbers to sum
     string rsp; // used in the condition; can't be defined inside the do
     do {
        cout &lt;&lt; "please enter two values: ";
        int val1, val2;
        cin  >> val1 >> val2;
        cout &lt;&lt; "The sum of " &lt;&lt; val1 &lt;&lt; " and " &lt;&lt; val2
             &lt;&lt; " = " &lt;&lt; val1 + val2 &lt;&lt; "\n\n"
             &lt;&lt; "More? [yes][no] ";
        cin  >> rsp;
     } while (!rsp.empty() && rsp[0] != 'n');
</pre>
<pre>
// backward jump over declaration statement ok
begin:
  int sz = get_size();
  if (sz <= 0) {
      goto begin;
  }
</pre>

<p>函数调用做了两件事情：用对应的实参初始化函数的形参(创建变量并赋值)，并将控制权转移给被调用函数。主调函数的执行被挂起，被调函数开始执行。函数的运行以形参的（隐式）定义和初始化开始。</p>

<p>函数的按值传递或引用、指针传递，区别在于是否在函数体内改变参数的情形下；</p>

<p>值传递是因为变量之间没有关联。而引用或指针传递是因为引用只是变量的别名，而指针是指向某个变量，所以变量之间有关系，这样在修改函数参数时，没有关联的就没有影响，而有关联的就有影响。</p>

<p><p>Using (const) References to Avoid Copies</p></p>

<p><p>利用 const 引用避免复制</p></p>


<p>编写一个比较两个 string 对象长度的函数作为例子。这个函数需要访问每个 string 对象的 size，但不必修改这些对象。由于 string 对象可能相当长，所以我们希望避免复制操作。使用 const 引用就可避免复制：</p>

<pre>
 // compare the length of two strings
 bool isShorter(const string &s1, const string &s2)
 {
	 return s1.size() < s2.size();
 }
</pre>

其每一个形参都是 const string 类型的引用。因为形参是引用，所以不复制实参。又因为形参是 const 引用，所以 isShorter 函数不能使用该引用来修改实参。

<p>变量的作用域也可以理解为变量可以用多久及可以给到哪些空间用。</p>

<p>函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作；调用前要先保存寄存器，并在返回时恢复；复制实参；程序还必须转向一个新位置执行。</p>

<p>inline Functions Avoid Function Call Overhead</p>

<p>inline 函数避免函数调用的开销</p>

<p>阅读和理解函数的调用，要比读一条用等价的条件表达式取代函数调用表达式并解释它的含义要容易得多。</p>

<p>如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多。</p>

<p>使用函数可以确保统一的行为，每个测试都保证以相同的方式实现。</p>

<p>函数可以重用，不必为其他应用重写代码。</p>

<p>了解编译器执行代码时的动作。</p>

<p>在类的定义外面定义成员函数必须指明它们是类的成员：</p>

<p>double Sales_item::avg_price() const</p>








<p>命令空间std是类的包装容器（或者称作“更大的容器”）。</p>




<p>命名空间namespace可以防止命名不重复；</p>

<p>STL的namespace是std，standard的缩写；</p>

<p>目的是为了保证名字不出现歧义性；</p>

<p>如果未用using namespace声明命名空间，则使用STL中的函数和变量时需冠以前缀std::</p>

<p>C++标准库头文件是标准库的外在表现形式，使用标准库的唯一途径就是包含相应的头文件（不需要包含后缀.h）</p>

<p>类的成员相当于双重限定。</p>

<p>A class template defines the layout and operation for an unbounded set of related types.</p>

<p><strong>对一些非常紧密关系的数据类型，类模板定义了它们共同的设计（类的结构）和操作（子函数）等。</strong></p>

<p>在实例化过程中，需要声明一个类型为模板类的对象，即使用所需的具体类型替换通用类型名。</p>


<h4>C++入门经典 <a href="http://workbench.cadenhead.org/book/cpp-24-hours/" title="">C++经典配套网站</a></li></h4>



<p>C++程序是使用一组协同工作的工具开发的,这些工具称为编译器和链接器。
<p>编译器和链接器将C++转换成能够运行的形式，它将程序从适合人类阅读的形式（源代码）转换成机器能够运行的形式（机器代码）。编译器生成目标文件，链接器则根据目标文件生成可执行文件。
<p>1 使用文本编辑器创建源代码（.c、.cpp、.h）；
<p>2 使用编译器将源代码转换成目标代码(.c、.cpp、.h→.o)；
<p>3 使用链接器<strong>链接</strong>目标文件和必要的库，生成可执行的程序。
<p>创建C++程序时，将链接一个或多个目标文件以及一个或多个库。库是一系列可链接的文件，提供了有用的函数和类，可供您在程序中使用。函数是一个执行任务的代码块，如将两个数相乘或显示文本。类定义了一种新数据类型和相关的函数。
<p>一些编译器如GCC（命令行）将编译与链接合二为一，而一些IDE则提供图形用户界面，将编辑、编译、链接、调试、测试等多个功能就地完成。
<p>auto自动变量是较新的C++版本新增的类型，声明变量时，用auto代替变量类型，由编译器根据初始字面值来判断变量类型。

<p>C++程序的预处理区（preprocessor），预处理区的指令多以#开头，不过它不属于C++语言的一部分，主要是告诉编译器程序要引入C++语言中所定义的头文件或指令。一般最常使用的头文件为&lt;iostream>。在C++语言中，为了避免不同函数库使用相同的标识符名称，而设计了名称空间（namespace）的概念，它也将标准函数库中所定义的函数都封装在各自的函数名称空间中，也就是只有在该名称空间的区域才能看到或使用定义的名称，所以在引用标准函数库的函数时，需要加入下一行的语句：</p>

<p>using namespace std;</p>

<p>或</p>

<p>using std:: 函数库函数名称;</p>

<p>函数的传值调用：直接将参数的数值拿来传递，主程序中的参数和函数中的参数都各自拥有内存的地址，它的作用是避免函数中将参数的值改变后，影响到主程序中参数的值。</p>

<p>函数的传址调用：在声明和定义上的参数前加上&运算符。事实上，是将函数的参数地址指向主程序的参数地址，所以在内存上只有一个参数地址，所以无论是更改主程序或函数内的参数值，都会互相影响到彼此。</p>

<p>一个变量未赋初始值时，它或者是一个垃圾值，或者是一个空值NULL或零值0.一般的全局变量和静态变量是后者；</p>


<p>C++ 98 标准</p>

<p>C++标准第一版，1998年发布。正式名称为ISO/IEC 14882:1998 。</p>

<p>C++ 03 标准</p>

<p>C++标准第二版，2003年发布。正式名称为ISO/IEC 14882:2003。</p>

<p>C++ 11 标准</p>

<p>C++标准第三版，2011年8月12日发布。正式名称为ISO/IEC 14882:2011。</p>

<p>C++11对容器类的方法做了三项主要修改。</p>

<p>首先，新增的右值引用使得能够给容器提供移动语义。其次，由于新增了模板类initilizer_list，因此新增了将initilizer_list作为参数的构造函数和赋值运算符。第三，新增的可变参数模板（variadic template）和函数参数包（parameter pack）使得可以提供就地创建（emplacement）方法。</p>

<p>C++ 14 标准</p>

<p>C++标准第四版，2014年8月18日发布。正式名称为ISO/IEC 14882:2014。</p>

<p>C++14是C++11的增量更新，主要是支持普通函数的返回类型推演，泛型 lambda，扩展的 lambda 捕获，对 constexpr 函数限制的修订，constexpr变量模板化等。</p>

<p>C++11</p>

<p>1.对C++核心语言的扩充；</p>

<p>2.核心语言运行期的强化(右值引用和 move 语义；泛化的常数表达式；对POD定义的修正)；</p>

<p>3.核心语言建构期表现的加强(外部模板)；</p>

<p>4.核心语言使用性的加强(初始化列表；统一的初始化；类型推导[auto关键字]；以范围为基础的 for 循环；Lambda函数与表示法；另一种的函数语法；对象构建的改良；显式虚函数重载；空指针；强类型枚举；角括号；显式类型转换；模板的别名；无限制的；unions)</p>

<p>5.核心语言能力的提升(变长参数模板；新的字符串字面值；用户自定义的字面值；多任务存储器模型；thread-local的存储期限；使用或禁用对象的默认函数；long long int 类型；静态assertion；允许sizeof运算符作用在类型的数据成员上，无需明确的对象；)</p>

<p>6.C++标准程序库的变更(标准库组件的升级；线程支持；多元组类型；散列表；正则表达式；通用智能指针；可扩展的随机数功能；包装引用；多态函数对象包装器；用于元编程的类型属性；用于计算函数对象返回类型的统一方法)；</p>

<p>在C++11中，lambda函数参数需要被声明为具体的类型。C++14放宽了这一要求，允许lambda函数参数类型使用类型说明符auto。</p>

<p>auto lambda = [] (auto x, auto y) {return (x + y); }</p>


<p>多次包含防范使用#ifndef、#define和#endif，可避免头文件出现多次包含或递归包含错误，有时还可以提供编译速度。</p>



<p>typedef主要是为复杂的声明定义简单的别名。</p>
<p>结构默认的成员访问是公开的，而类是私有的。</p>


<p>赋值号=：右边的值赋给左边的变量；</p>

<p>函数和类：自定义功能单元和代码重用；</p>




<p>引用函数使得函数引用参数更加方便；</p>



<p>OOP将对象作为基本的程序单元。</p>

<p>每一个对象都能接受数据，处理数据，并能将数据传达给其它对象。</p>

<p>对象的属性、方法、事件；</p>


<p>多文档的框架窗口可以容纳多个子文档。</p>

<p>选项卡式文档：将每个文档放置到单独的选项卡上；</p>

<p>&&和||的短路操作虽然会简化计算过程，但也会带来副作用，如c&lt;0 && i = i+3在c>0时，程序就会跳过 i = i+3。</p>



<pre>
//变量的文件作用域
#include 
int i = 11;
void main()
{
    int i = 5;
    cout&lt;&lt;i&lt;&lt;endl;
    cout&lt;&lt;::i&lt;&lt;endl;
}

</pre>


<p>数据类型是所有程序语言的基础。C++程序的所有功能都是建立在内置于C++语言的基本数据类型基础之上的。数据类型可以告诉数据代表的意义以及程序可以对数据执行的哪些操作，它确定了数据和数据操作在程序中的意义。 </p>

<p>在C/C++中，数据类型分为两种，简单类型和结构类型。简单类型包括有整数类型、字符类型、浮点类型、指针类型、枚举类型和void类型等。结构类型包括有数组、字符串、记录和文件等。C/C++的基本数据类型属于简单类型。用户可以创建的所有数据类型都是根据基本类型定义的。 </p>

<p>C++语言定义了几种基本类型，分别是字符型、整型、浮点型等。C++还提供了可用于自定义数据类型的机制，标准库正是利用这些机制定义了许多更复杂的类型，例如，可变长字符串string和vector等。此外，程序员还能自己修改已有的基本类型以灵活定制复合数据类型。 </p>

<p>C/C++中的基础数据类型分为3种：整数型、浮点型和void型。程序中不能定义void类型的变量，它仅仅是用于说明函数没有返回值或说明指针是无类型的。C++中所有的表达式是都可转换或映射为void类型的。 </p>

<p>整型是用来表示没有小数位的数，在C/C++中，用来表示整数、字符和布尔值的算术类型合称为整型。可以用很直接的方式来表示整型字面量，-100、+110、120、8888等。 </p>

<p>修饰符是整型的一个重要表示，整型可以加上符号和长短的修饰符来表示不同的存储长度和数值范围。 </p>

<p>表示长短的修饰符有short、int、long等。一般来说，short代表半个机器字长；int代表一个机器字长；long代表一个或2个机器字长。 </p>

<p>另外，整型还可以是带符号的（signed），也可以是无符号的（unsigned）。带符号的整型可以表示正数也可以表示负数（包括0），而无符号的整型只能表示大于等于0的数。 </p>

<p>由于有了前缀，整型就可以细分为char（字符型）、unsigned char（无符号字符型）、signed char（有符号字符型）、int（整型）、unsigned int（无符号整型）、signed int（有符号整型）、short int（短整型）、unsigned short int（无符号短整型）、signed short int（有符号短整型）、long int（长整型）、signed long int（有符号长整型）、unsigned long int（无符号长整型）、bool（布尔型）等13种。</p>


<p>在C++中，变量有且仅有一次定义，而且变量在使用之前必须声明或者定义。 </p>

<p>C++程序通常由许多文件组成。为了让多个文件访问相同的变量，C++区分了声明和定义。定义和声明有相同的时候，但声明的主要目的是表明变量的类型和名称(extern)，而定义的主要目的是为变量分配存储空间。</p>

<p>作用域也可以理解为一种上下文；</p>

<p>在C++中，每个变量名都与唯一的实体（例如变量，函数和类型等）相关联。尽管有这样的要求，还是可以在程序中多次使用同一个变量名，只要它用在不同的区域中，且通过这些区域可以区分该变量名的不同意义。用来区分变量名的不同意义的区域称为作用域。大多数作用域是用花括号来划定界限的。 </p>

<p>C++标示符作用域分为全局作用域和局部作用域。</p>

<p>存储类型是从变量的存在时间（即生存期）来划分变量。变量的存储类型可分为静态存储方式和动态存储方式。对于动态存储变量，当程序运行到该变量处时才为其分配存储空间，当程序运行到该变量所在作用域的结束处时自动收回为其分配的存储空间，因此它的生存期为所在作用域。在程序开始就执行就为其分配存储空间，直到程序结束时，才收回变量的存储空间，这种变量称为静态存储空间，其生命周期为整个程序执行的过程。 </p>

<p>在C++中，变量的存储类型有自动类型、寄存器类型、静态类型、外部类型等4种。 </p>

<p>（1）自动类型变量（auto） </p>

<p>自动类型只能是局部类型的变量，属于动态存储类型。 </p>

<p>（2）静态类型变量（static） </p>

<p>static，即在程序运行的过程中静态变量始终是占用一个存储空间。静态变量只能在他的作用范围内使用，使用局部静态变量是为了在下次调用该函数时，能使用上次调用后得到的该变量的值。 </p>

<p>（3）寄存器类型变量（register） </p>

<p>属于动态存储类型，编译器不为寄存器类型的变量分配内存空间，而是直接使用CPU的寄存器。以便提高对这类变量的存取速度。主要用于控制循环次数等不需要长期保存值得变量。 </p>

<p>（4）外部类型变量（extern） </p>

<p>外部类型变量必须是全局变量，在C++中，有两种情况需要使用外部类型变量。一种是在同一源程序文件中，当在全局的定义之前使用该变量时，在使用前要对该变量进行外部类型变量声明。另一种是当程序有多个文件组成时，若在一个源文件中要引用在另一个源文件中定义的全局变量，则在引用前必须对所引用的变量进行外部声明。 </p>

<p>如果在某文件中定义的全局变量不想被其他文件所调用，则必须将该变量声明为静态全局变量，也就是说，静态全局变量只能供所在的文件使用。</p>



<p>while循环与do-while循环的主要区别在于，如果循环条件语句为false，while语句不会执行循环，而do-while保证循环体执行一次。</p>

<p>C++典型循环语句包括for 循环语句、while 循环语句和do-while 循环语句。其中for 循环语句更多的用于需要遍历的情况，而while 和do-while 循环语句可以用于状态判断并且根据状态执行操作等。</p>

<p>continue 语句只能出现在循环语句中，而break 语句可以出现在switch 语句中，continue 语句不会退出循环，只会终止当次执行循环体并且进入下一次循环体的执行，break 语句会退出循环语句。</p>


<p>预处理程序预先（编译之前）对以#开头的语句进行处理。</p>

<p>宏定义是C++的预处理命令之一，它是一个替换操作，不做计算和表达式求解，不占用内存和编译时间。</p>


<p>在C++中，建议尽量避免使用指针和数组，指针和数组容易产生不可预料的错误。其中一部分是概念上的问题，因为指针用于低级操作，容易产生与繁琐细节相关的错误，而其他错误则源于使用指针的语法规则，特别是声明指针的语法。许多有用的程序都可以不使用数组或指针实现，现代C++程序采用vector类型和迭代器取代一般的数组、采用string类型取代C风格字符串。</p>


<p>面向对象是高级编程语言的特征，它以对象为语言的中心，用消息来进行驱动。（消息也是一个成员函数，只是其有消息映射机制，并会传入一个资源的ID号）</p>

<p>面向过程是一种以过程为中心的编程思想，以算法进行驱动。面向对象是一种以对象为中心的编程思想，以消息进行驱动。面向过程编程语言的组成为：程序=算法+数据，面向对象编程语言的组成为：程序=对象+消息。</p>










<p>数组：数据顺序存储，固定大小； </p>

<p>链表：数据可以随机存储，大小可动态改变。</p>




<p>全局对象的构造函数会在main()函数之前执行。</p>

<p>float x与“零值”比较的if语句 </p>

<p>x是一个变量，被定义为float，所以在比较时，零值并不是0，而是以下代码： </p>

<p>if(x>0.000001&&x<-0.000001) </p>

<p>一般来说，对于一个浮点数，不会只定义了不使用。通常我们都会对浮点数进行比较复杂的运算，那么在运算的过程中，就有可能发生四舍五入的情况。所以，对于一个进行了一些可能导致四舍五入的运算的浮点数而言，不能保证它的准确性（当然这里的误差是非常非常小的）。所以，在对浮点数比较的时候，就需要考虑到这些误差，方法之一就是，让浮点数与一段数值范围比较，而不是与一个确定的数值比较。</p>


<p>const关键字至少有下列n个作用： </p>

<p>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了。 </p>

<p>（2）对指针来说，可以指定指针本身为const；也可以指定指针所指的数据为const，或二者同时指定为const。 </p>

<p>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值。 </p>

<p>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量。 </p>

<p>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”，例如下面的代码： </p>

<p>const classA operator*(const classA& a1,const classA& a2); </p>

<p>operator*的返回结果必须是一个const对象。如果不是，这样的代码也不会编译出错。</p>

<p>预编译就是处理#开头的指令。例如，拷贝#include包含的文件代码，#define宏定义的替换和条件编译等。预编译就是为编译做的预备工作的阶段，主要处理#开始的预编译指令。 </p>

<p>预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</p>

<p>int (*s[10])(int)函数指针数组，将每个指针指向一个int func(int param)的函数。</p>

<p>（1）不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了“无所指”的引用，程序会进入未知状态。 </p>

<p>（2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其他尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露。 </p>
<p><strong>虽然避免返回函数内部new分配的内存的引用，但可以返回new的指针。</strong></p>
<p><font color="#FF0000"><strong>指针额外的两个很重要的作用：返回函数内部new分配的内存单元的指针；以及在多态中要使用到指针。</strong></font></p>
<p>（3）可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其他属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其他对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p>

<p>指针是多少位只要看地址总线的位数即可。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。应聘者要对操作系统有很好的了解，尤其是以前老式的386和486等。</p>


<p>（1）const 常量有数据类型，而宏常量没有数据类型。使用的时候，编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生一些意料不到的错误。 </p>

<p>（2）有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p>

<p>设变量名为var，分别给出bool、int、float指针变量与“零值”比较的if 语句。 </p>

<p>bool型变量的0判断完全可以写成if(var==0)，而int型变量也可以写成if(!var)，指针变量的判断也可以写成if(!var)，上述写法虽然程序都能正确运行，但是未能清晰地表达程序的意思。 </p>

<p>一般情况下，如果想让if判断一个变量的“真”、“假”，应直接使用if(var)、if(!var)，表明其为“逻辑”判断；如果用if判断一个数值型变量（short、int、long等），应该用 if(var==0)，表明是与0进行“数值”上的比较；而判断指针则适宜用if(var==NULL)，这是一种很好的编程习惯。 </p>

<p>浮点型变量并不精确，所以不可将float变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。</p>

<p>bool型变量：if(!var) </p>

<p>int型变量：if(var==0) </p>

<p>float型变量：const float EPSINON = 0.00001; </p>

<p>if ((x >= - EPSINON) && (x <= EPSINON) </p>

<p>指针变量：if(var==NULL)</p>

<p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p>

<p>用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p为指针得到的是一个指针变量的字节数，而不是p所指的内存容量。C++/C语言不能知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p>

<p>void，空类型，不指定指针指向一个固定的类型，当赋值给其它指针时，再进行强制类型转换，如：</p>



<pre>
int a;
int *p1;
void *p2 = p1;
int *p3 = (int *)p2;
</pre>

<p>枚举类型可以将一些整型常量融合到一起；</p>

<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>

<p>不管怎么说，回调函数是继承自C语言的。在C++中，应只在与C代码建立接口或与已有的回调接口打交道时，才使用回调函数。除了上述情况，<strong>在C++中应使用虚拟方法或仿函数（functor），而不是回调函数。</strong></p>

<p><strong><strong>作用域解析运算符是在指定的名称空间中搜索变量</strong>，如果前面为空，则是在全局名称空间中搜索</strong>，如果是std，表示是在std这个名称空间中搜索变量，如果是类名，则表示在这个类名中搜索。</p>

<p>枚举：具有特定值集的变量；</p>

<p>*与[]在与类型在一起时是声明，没有类型时是解引用或数组成员；</p>



<p>在C程序中，可以用带参数的宏。宏本身不是函数，但使用起来象函数。用复制宏代码的方式代替函数调用可以提高速度。最大缺点是容易出错。</p>




<p>数组元素的地址是通过数组首地址计算的。如数组的首地址是 1000，则第i 个元素的地址是1000 + i * 每个数组元素所占的空间长度</p>

<p>如执行了p=array，则*p与array[0]是等价的，对该指针可以进行任何有关数组下标的操作。</p>


<p>strcpy(q, "abcde");</p>

<p>assert（）宏在标准头文件cassert中 </p>

<p>assert()有一个参数，表示断言为真的表达式，预处理器产生测试该断言的代码。如果断言不是真，则在发出一个错误消息后程序会终止。</p>



<p>为什么不同类型的计算机可以运行同一个C++程序，而不同类型的计算机不能运行同一个汇编程序？因为不同类型的计算机上有不同的C++编译器，可以将同一个C++程序编译成不同机器上的机器语言表示的目标程序。而汇编程序仅是机器语言的另一种表现形式。不同类型的计算机有不同的机器语言，也就有不同的汇编语言。</p>


<p>静态链接是指把要调用的函数或者过程直接链接到可执行文件中，成为可执行文件的一部分。换句话说，函数和过程的代码就在程序的.exe文件中，该文件包含了运行时所需要的全部代码。静态链接的缺点是：当多个程序都调用相同函数时，内存中就会存在这个函数的多个复制，这样就浪费了内存资源。</p>

<p>动态链接是相对于静态链接而言的。动态链接调用的函数代码并没有被复制到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在操作系统的管理下，才在应用程序与相应的动态链接库（gynamic link library, dll）之间建立链接关系。<strong>当要执行.dll文件中的函数时，根据链接产生的重定位信息，操作系统才转去执行.dll文件中相应的函数代码。</strong></p>

<p>静态链接库就是使用.lib文件。</p>




<p>传址的实质也是传值，只是其值是一个地址值，函数体内操作的是地址值指向的数据。地址值可以由指针传递，也可以由引用来传递。</p>

<p>函数模板是自动生成重载函数的方法。</p>



<p>typeid(变量名)：可以获取对象的类型信息；使用头文件<typeinfo></p>




<p>因为效率，C++被设计为系统级的编程语言，效率是优先考虑的方向，c++秉持的一个设计哲学是不为不必要的操作付出任何额外的代价，所以它有别于java，不给成员变量和局部变量做默认初始化，如果需要赋初值，那就由程序员自己去保证。</p>
<p>结论：从安全的角度出发，定义变量的时候赋初值是一个好的习惯，很多错误皆因未正确初始化而起，C++11支持成员变量定义的时候直接初始化，成员变量尽量在成员初始化列表里初始化，且要按定义的顺序初始化。</p>



<p>用 struct 定义类型与用 class 定义类型有什么区别？ </p>

<p>在结构体中，缺省的访问特性是公有的。在类中，缺省的访问特性是私有的。 </p>


<p>在定义一个类时，哪些部分应放在头文件（.h文件）中，哪些部分应放在实现文件（.cpp文件）中？ </p>

<p>类的定义放在头文件中，类中成员函数的实现放在实现文件中。 </p>




<p>重载后的运算符的优先级和结合性与用于内置类型时有何区别？ </p>

<p>与内置类型完全一样。 </p>

<p>如何区分++和--的前缀用法和后缀用法的重载函数？ </p>

<p>后缀++的重载函数中增加了第二个参数：一个整型的参数。这个参数只是为了区分两个函数，它的值没有任何意义。当程序中出现前缀++时，编译器调用不带整型参数的operator++函数。如果是后缀的++，则调用带整型参数的operator++函数。--重载也是如此。 </p>



<p>强制类型转换在C++类型系统中引入了一个漏洞</p>

<p>为了方便查找这些错误，C++提供了在强制类型转换时指名转换的性质。</p>

<p>转换的性质有四种：</p>

<p>静态转换(static_cast)：用于编译器隐式执行的任何类型转换 </p>

<p>重解释转换(reinterpret_cast)</p>

<p>常量转换(const_cast)</p>

<p>动态转换(dynamic_cast)</p>

<p>格式 </p>

<p>转换类型<类型名> (表达式)</p>

<p>z = static_cast<double>(x) / y;</p>

<p>逻辑表达式在执行时，先处理左边。如左边已能决定此逻辑表达式的结果，则右边不执行。因此，在&& 逻辑表达式中，应把false可能性较大的条件放在左边，在||表达式中，应把true可能性较大的条件放在左边，这样可以减少程序执行的时间</p>


<p>设计库中的函数的实现：表现为一个源文件。</p>

<p>库的这种实现方法称为信息隐藏。</p>

<p>计算机的工作是建立在抽象的基础上。</p>

<p>机器语言和汇编语言是对机器硬件的抽象</p>

<p>高级语言是对汇编语言和机器语言的抽象</p>

<p>现有抽象的问题：</p>

<p>要求程序员按计算机的结构去思考，而不是按要解决的问题的结构去思考。 </p>

<p>当程序员要解决一个问题时，必须要在机器模型和实际要解决的问题模型之间建立联系。</p>

<p>而计算机的结构本质上还是为了支持计算，当要解决一些非计算问题时，这个联系的建立是很困难的</p>


<p>每个成员函数都有一个隐藏的指向本类型的指针形参this，它指向当前调用成员函数的对象  </p>

<p>通常，在写成员函数时可以省略this，编译时会自动加上它们。</p>

<p>如果在成员函数中要把对象作为整体来访问时，必须显式地使用this指针。这种情况常出现在函数中返回一个对调用函数的对象的引用，</p>

<p>某些类的对象，必须在对它进行了初始化以后才能使用。对于某些类的对象在消亡前，往往也需要执行一些操作，做一些善后的处理。</p>

<p>初始化和扫尾的工作给类的用户带来了额外的负担，使他们觉得类和内置类型还是不一样。</p>

<p>用户希望使用类的对象就和使用内置类型的变量一样，一旦定义了，就能直接使用。用完了，由系统自动回收。</p>


<p>对const对象只能调用const成员函数。</p>

<p>任何不修改数据成员的函数都应该声明为const类型。</p>

<p>const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。同一类的不同的对象其const数据成员的值可以不同。</p>

<p>不能在类声明中初始化const数据成员。</p>

<p>const数据成员的初始化只能在类构造函数的初始化表中进行，不能在构造函数中对他赋值。</p>



<p>如果作为类的成员函数，它的形式参数个数比运算符的运算对象数少1。这是因为成员函数有一个隐含的参数this。在C++中，把隐含参数this作为运算符的第一个参数。</p>




<p>设计算法最有效的手段就是将任务分解成多个子任务，再将每个子任务分解成更小的子任务，依此类推。最终，子任务会变得很小，很容易用C++代码实现。这种设计方法称为自顶向下设计。有时也称为逐步求精，或者更形象地称为分而治之。使用自顶向下方法，可将程序的任务分解为一组子任务，并通过子算法来解决这些子任务，从而完成一个程序的设计。</p>

<p>在C++程序里采用这种自顶向下结构，能使程序更容易理解，更容易更改，而且使程序更清晰，更容易编写、测试和调试。和大多数编程语言一样，C++提供了在程序中包括独立的子部分的机制。在其他编程语言里，这些子部分称为子程序、子过程或者方法。在C++里，这些子部分称为函数。通过函数将编程任务分解为子任务的好处在于，不同的人可以负责不同的子任务。构造大型程序(比如编译器或办公管理系统)时，如果程序开发时间有限，这种形式的团队协作就非常重要。</p>

<p>static_cast<double>(2)返回2.0。这称为强制类型转换。</p>

<p>函数声明指出写函数调用所需的全部细节。函数声明和函数定义至少要有一样放到函数调用之前。函数声明通常放在程序的main 部分之前。</p>

<p>为了理解函数，请谨记以下3 点。</p>

<p>函数定义如同小程序，调用函数相当于运行这个“小程序”。</p>

<p>函数使用形参(而不是cin)来输入。函数的实参就是实际输入的值，它们在形参位置代入。</p>

<p>函数(本章讨论的这一种)通常不向屏幕发送任何输出，但会将一种“输出”送还给程序。函数会返回一个值，该值好比函数的“输出”。函数进行这样的输出是用return 语句，而不是用cout 语句。</p>

<p>函数声明通常放到程序的main 部分之前，函数定义通常放到程序的main 部分之后(或者放到单独文件中)。这样也更有可读性。</p>

<p>“流”是第一个“对象”。对象乃是一种特殊变量，拥有自己的专用函数。某种意义上，这些函数是“附加”到变量上的。</p>


<p>对象是关联了函数的变量。这些函数称为成员函数。类是一种类型，它的变量就是对象。对象所属的类(即对象的类型)决定了对象有哪些成员函数。</p>


<p>使用数组的索引变量与使用数组基类型的其他任何变量没有区别。因为其名字也是内存单元的命名。</p>

<p>数组的索引变量在计算机内存中一个接一个地存储，所以整个数组会占用一个连续的内存存储区域。数组作为参数传给函数时，只有第一个索引变量(索引编号0)的地址才会传给调用函数。所以，使用数组形参的函数通常还需要另一个int 类型的形参来给出数组的长度。</p>



<p>指针是变量的内存地址。计算机内存被划分为许多编好号的内存位置(称为字节)，变量被实现为一组相邻的内存位置。C++系统有时将内存地址作为变量名使用。假定变量用3 个内存位置实现，就可以将第一个位置的地址作为变量名使用。例如，假定变量作为传引用参数使用，传给调用函数的就是这个地址，而非变量的标识符名称。</p>

<p>用变量起始处的内存地址命名变量，该地址就称为指针，因为可以认为该地址“指向”变量。之所以说地址“指向”变量，是因为是用变量的位置(而不是变量名)标识变量。例如，在提到位于位置编号1007 的变量时，可以说：“它是在位置1007 的变量。”前面许多地方用过指针。如前所述，在函数调用中将变量作为传引用参数使用时，是以指针形式向函数提供实参。这是指针的一个重要而且强大的用途，但具体过程是由C++系统自动完成的。</p>

<p>操作符delete 可销毁动态变量，并将其占用的内存还给自由存储，使内存得以重用。假定p 是指向动态变量的指针变量，以下语句会销毁p 指向的动态变量，将占用的内存还给自由存储：delete p;像这样调用delete，p 的值会进入未定义状态，现在的p 应被视为一个未初始化变量。</p>

<p>如变量是函数的局部变量，调用函数时变量会由C++系统创建，并在函数调用结束时销毁。由于程序的main 部分本质上是一个名为main 的函数，所以在main 部分中声明的变量也会这样处理。由于对main 的调用直到程序终止才结束，所以main 中声明的变量直到程序终止才销毁。无论main 还是其他函数，局部变量都这样处理。我们过去用过的普通变量(也就是在main 或者其他函数定义中声明的变量)称为自动变量，因为它们的动态属性由系统自动控制；调用函数时，函数内部声明的变量自动创建，函数调用结束后，自动销毁。我们通常将这些变量称为普通变量，但也有一些书把它们称为自动变量。</p>


<p>操作符::是作用域解析操作符，作用和圆点操作符相似。无论圆点操作符，还是作用域解析操作符，都指出一个成员函数具体是谁的成员。但作用域解析操作符::作用于类名，而圆点操作符作用于对象(类的变量)。作用域解析操作符必须是连续两个冒号，中间不能有空格。操作符前的类名为类型限定符，它使函数名具体化，指出该函数从属（限定）于哪个类型。</p>

<p>圆点操作符和作用域解析操作符</p>

<p>两个操作符都随成员名称一起使用，指出它们具体是谁的成员。例如，假设声明一个名为DayOfYear 的类，并像下面这样声明它的一个名为today 的对象：</p>

<p>DayOfYear today;</p>

<p>那么要用圆点操作符指定today 对象的成员。例如，output 是DayOfYear 类的成员函数(在图10.3 中定义)，以下函数调用输出存储在today 对象中的数据值：</p>

<p>today.output();</p>

<p>为成员函数给出函数定义时，则要使用作用域解析操作符::指定类名。例如，成员函数output 的函数定义头是：</p>

<p>void DayOfYear::output()</p>

<p>记住，作用域解析操作符::用于类名，而圆点操作符用于那个类的对象。</p>

<p>冒号:可以在构造函数后跟参数列表。可以在前面跟一个标识，用于跳转的开始处。或者是用在条件运算符中。</p>

<p>类是变量为对象的类型。对象可拥有成员变量和成员函数。</p>


<p>类的友元函数其实就是普通函数，只是能像成员函数那样访问类的私有成员。</p>

<p>如果类有一套完整的取值函数getval()和赋值函数setval()，将函数变成友元的唯一理由就是简化函数定义，并提高它的效率——但这些理由通常就足够了。（是说普通函数不能访问私有成员数据，但可以他用取值函数来访问，这样会影响效率，相对于直接访问私有成员）</p>

<p>对于不被函数更改的类类型参数，通常应将其设为常量参数。</p>


<p>数组基类型可以是结构或类类型。结构或类可将数组作为自己的成员变量。</p>


<p>可为一个类重载赋值操作符=，使它具有你希望的行为。但它必须作为类的成员来重载，不能作为友元。使用了指针和new 操作符的任何类都应重载作用于那个类的赋值操作符。</p>


<p><strong>两个简单的规则可帮你选择成员函数和非成员函数</strong>：</p>

<p>函数要执行的任务只涉及一个对象，就使用成员函数。</p>

<p>要执行的任务涉及多个对象，就使用非成员函数。将它作为非成员(友元)函数。</p>

<p>友元函数一般以在参数中引用类对象，当然在定义中引用对象成员也要限定对象。</p>

<p>C++允许将程序分解成多个部分，保存到独立的文件中，独立编译，并在程序运行时（或在运行前）链接到一起。可将类定义（以及相关函数定义）放到一个文件中，使这个文件独立于使用该类的程序。这样就可方便地建立起一个类库，以便多个程序使用相同的类。类只需编译一次，即可在多个程序中使用，和使用预定义库一样。此外，类也可用两个文件来定义，将这个类的使用规范与类的实现细节分开，如果类按规则定义，以后只需重新编译类的实现文件。其他文件（包括使用类的程序文件）不需要更改，甚至不需要重新编译。</p>

<p>就是说接口文件是头文件，做为界面，要保持一定的稳定性，而实现文件，也只是.cpp，用于实现头文件的声明。这样当头文件被调用时，引用的只是头文件的声明。当实现文件做出改变时，并不影响接口被引用。</p>

<p>如果使用数据类型的程序员访问不到值和操作的实现细节，就可将这种数据类型称为抽象数据类型（ADT）。你定义的所有类都应该是ADT。ADT类确保了类的接口和实现的分离，这是良好的编程实践。</p>

<p>常量NULL实际是数字0，对于以下重载函数：</p>

<p>void func(int *p);</p>

<p>void func(int i);</p>

<p>func(NULL)实际调用哪个函数，由于NULL是数字0，所以两者均为有效，C++11的解决方案是引入新常量<strong>nullptr</strong>。nullptr不是整数零，而是代表空指针的字面值常量。</p>

<font color="#990066"><p>基类构造函数不被派生类继承，但可在派生类构造函数的定义中调用基类构造函数。</p>

<p>由于有大量标准数据结构用于容纳数据，人们觉得有必要为这些数据结构提供标准的、可移植的实现。</p></font>

<p><strong>声明（引入名字或作为接口）：</strong></p>

<p>一个没有具体说明函数体的函数；</p>

<p>包含一个extern说明符，并且没有初始化程序或函数体；</p>

<p>一个类定义内的静态类数据成员的声明；</p>

<p>一个类名的声明；</p>

<p>一个typedef声明；</p>

<p><strong>定义（实现内存分配）</strong>：</p>

<p>静态类数据成员；</p>

<p>一个non-inline成员函数。</p>

<p>一个声明将一个名字引入作用域。在C++中，声明和定义的区别在于：在一个给定的作用域中重复一个声明是合法的；相比这下，在程序中使用的每个实体（如类、对象、枚举器、函数等）必须只有一个定义。</p>

<p>一个定义提供了一个实体（例如，类型、实例、函数）在一个程序中的唯一描述。</p>

<p>声明：</p>

<p></p>
<pre>
int func(int,int);
class IntSetIter;
typedef int Int;
friend IntSetIter;
extern int globalVariable;
</pre>

<p>是声明也是定义：</p>
<p></p>
<pre>
int x;
char *p;
extern int globalVariable = 1;
static int s_instancecount;
static int f(int,int){;}
inline int h(int,int{;}
enum Color { RED, GREEN, BLUE};
const double DEFAULT_TOLERANCE = 1.0e-6;
class Stack {;};
struct Util{;};
template<class T> void sort(const T**arr, int size){;}
</pre>

<p>函数和静态数据成员声明是例外。它们虽然没有定义，但是在一个类的定义中也不能重复：</p>

<p></p>
<pre>
class Nogood
{
    static int i;
public:
    int f();
};
</pre>

<p>编译一个.c或.cpp文件时，预处理器首先（递归地）包含头文件，形成包含所有必要信息的单个源文件。之后，编译这个中间文件（称为编译单元）生成一个和根文件名字一样的.o文件（目标文件）。链接程序把各种编译单元内产生的符号链接起来，生成一个可执行程序。有两种不同的链接：内部链接和外部链接。链接类型将会直接影响我们将一个给定的逻辑构造合并到物理设计中。</p>

<p>如果一个名字对于它的编译单元来说是局部的，并且在链接时与在其他编译单元中定义的标识符名称不冲突，那么这个名字有内部链接。</p>

<p>链接意味着对这个定义的访问受到当前编译单元的限制。也就是说，一个有内部链接的定义对于任何其他编译单元都是不可见的，因此在链接过程中不能用来解析未定义的符号。</p>

<p>如果一个名字有外部链接，那么在多文件程序中，在链接时这个名字可以和其他编译单元交互。其标识符在整个程序中必须是唯一的。</p>

<p>在C++中，将一个带有外部链接的定义旋转在一个h文件中往往属于编程错误。</p>

<p>在C++中，在一个头文件的作用域内旋转一个带有内部链接的定义，例如静态函数或者静态数据，是合法的。但不推荐。</p>

<p><strong>头文件中可以包含的内容：</strong></p>

<pre>
class Radio
{
    static int s_count;
    static const double s_PI;
    int d_size;
public:
    int size() const;
};
inline int Radio::size() const 
{
    return d_size;
}
</pre>

<p>头文件中不应该包括：</p>
<p></p>
<pre>
extern int LENGTH = 11;
int z;
const int WIDTH= 5 //void
static void func() {;} //void
int Radio::s_count;
double Radio::SPI = 3.141592;
int Radio:: size() const {;}
</pre>

<p>在标准C++中，指针容纳的是另一个变量或函数的内存地址。这意味着可用指针间接引用变量。</p>

<p>枚举（简称enum）是一组命名的整数常量。枚举适合表示从一组固定值中取其一的类型，比如一周中的日子或者一年中的月份。</p>

<p>dynamic_cast是C++的运行时动态转型机制，类型不匹配会返回一个nullptr。</p>

<p>Various number types have different memory requirements</p>

<p>More precision requires more bytes of memory</p>

<p>Very large numbers require more bytes of memory</p>

<p>Very small numbers require more bytes of memory</p>

<p>键盘、磁盘文件文件、鼠标都是输入设备，C++不可能为每一种输入设备都提供一个专用的输入语句。</p>

<p>cin、cout对象声明在 iosteam中。</p>

<p>对于一个源文件，C++编译器通过编译预处理，将该源文件中的#include包含指令和#define宏定义指令替换掉，从而生成一份完整的源代码文件。该源代码文件就编译器进行编译处理的基本单元，称为一个编译单元（translation unit）。</p>

<p>通过独立编译或分别编译成目标文件（.obj）。</p>

<p><strong>目标文件可以被计算机理解，但是还不能被计算机直接执行，因为在多个目标文件之间可能会共享同一个函数或者变量，需要建立这些共享名字之间的链接关系。此外，目标文件中还缺乏程序执行的启动代码。</strong></p>

<p>链接处理，就利用链接器建立多个目标文件以及c++库文件之间的链接关系，并连同操作系统启动代码，一起打包成一个可执行文件。</p>

<p>C++的头文件和独立编译机制，支持我们将程序代码非常方便自然地组织到多个文件中，非常适合于团队协作编写规模较大的程序。</p>

<p>那么，作为团队成员，我们在编写自己的程序代码时必须清晰地把握：</p>

<p>在我的程序代码中哪些变量或者函数是供自己使用的，不能与其他成员的程序代码冲突；哪些变量和函数是需要与其他成员共享的，应该如何实现它们的的共享。C++语言提供了一系统语法约定，用以避免函数和变量等程序实体的冲突并实现共享。</p>

<p>1 约定程序实体所在的空间范围：作用域；</p>

<p>2 约定程序实体生成的时间范围：生存期；</p>

<p>3 在多文件之间共享程序实体：链接属性；</p>

<p>4 避免全局程序实体的冲突机制：名字空间；</p>

<p>C++规定了四种作用域</p>

<p>1 局部作用域，位置；</p>

<p>2 文件作用域，extern</p>

<p>3 名字空间作用域，::或using namespacing</p>

<p>4 类作用域，::</p>

<p>在局部域中定义或者声明的变量或函数，其右见性从声明点开始，一直延伸到匹配的花括号的结束外。（VC6在for循环中初始化循环变量时，其作用域会超出函数块）</p>

<p>C++约定的局部作用域有三种：复合语句的块域、函数域和函数声明域。</p>

<p>函数参数只是一个占位符，最终总是需被赋值，用常量赋实值，用变量赋实值或地址值或别名，其本身并不存在什么作用域。</p>

<p>所在不能并引用，在调用被赋值或初始化时或是实值或是其外部变量的引用（地址址）或引用的别名。</p>

<p>unsing namespace 名字空间名</p>

<p>using 名字空间名::成员名</p>

<p>using namespace std;</p>

<p>using std::cout;</p>

<p>指针：间接操作其他变量；</p>

<p>引用：直接操作其他变量；</p>

<p>引用不就是一个常量指针吗？</p>

<p>const pointer可以初始化为NULL，而&不行，即引用总是指向某个对象。</p>

<p>1) 引用必须被初始化，指针不必。 </p>

<p>2) 引用初始化以后不能被改变，指针可以改变所指的对象。</p>

<p>3) 不存在指向空值的引用，但是存在指向空值的指针。</p>

<p>1  非空的差别任何情况下都不能使用指向空值的引用。一个引用必须总是指向某</p>

<p>2 合法性区别在使用引用之前不需要测试他的合法性。指针必须测试。 </p>

<p>3 可修改区别 指针可以被重新赋值给另一个不同的对象。但是引用总是指向在初始化的时候被制定的对象，以后不能改变。但是指定的对象其内容可以改变。 </p>

<p><strong>应该使用指针的情况</strong>: 可能存在不指向任何对象的可能性，需要在不同的时刻指向不同的对象(此时，你能够改变指针的指向) 。返回函数体中new出的内存空间的地址。多态中使用指针。</p>

<p><strong>应该使用引用的情况</strong>: 如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，使用此时应使用引用。  </p>


<p>数组用作函数形式参数时会丢失数组元素个数的信息，即退化为指针；</p>

<p>函数返回数组名，实际返回的是指向数组首元素的指针；</p>

<p>界面，函数的函数头，类或对象的声明中的public部分。对象之间通过对象的public方法进行交互，另外，类成员可以是其他对象。</p>

<p>方法可以利用过程化语法工具来完成描述。</p>

<p>一个对象的成员数据也是顺序存储在一起的，或者是按各自长度存储，或者编译器基于效率因素增加一些额外字节以使存储边界对齐。</p>

<p>这样对象名就是这块内存空间的首地址，而成员就是内存空间的偏移。</p>

<p>同样的，通过对象名和成员函数名，也可以定位到其对应的函数地址。</p>

<p>运算符本质上是函数。</p>

<p>通过在构造函数体中给数据成员赋值，或者使用初始化列表进行初始化。两种方式效果相同，但本质不同。</p>

<p>其中，在构造函数的函数体中，对象已经产生出来，只是初始状态不符合我们的要求，因此，我们通过赋值修改对象的状态。</p>

<p>在初始化列表中，对象正在产生，且使用初始化列表设置初始状态。</p>

<p>在一些情况下，对象一旦产生，它的某些数据成员就不允许修改，便即常量数据成员或者引用型数据成员，此时，就必须使用初始化列表的方式。</p>

<p>通常，默认构造函数仅负责创建对象，基本上不做什么初始化工作。</p>

<p>通过默认参数和初始化列表，可以使用灵活的对象定义方式：</p>

<p>CDate::CDate(int y =1900,int m=1,int d=1):year(y),month(m),day(d){}</p>


<p>接口sort()（放在.h文件中），用户用它，而无须了解其是如何实现的，实现者可以更改sort()的实现（放在.cpp中），可以使用快速排序，也可以使用选择排序或归并排序。</p>

<p>virtual是告诉编译器，不要静态链接到该函数，而是在运行时根据基类指针指向动态链接。</p>

<p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>


<p>在C++中，我们使用访问标签（private、public、protected）来定义类的抽象接口。一个类可以包含零个或多个访问标签。</p>

<p>析构函数通常在对象生命期结束时被系统自动调用。如，静态对象在程序结束时、局部对象在出了局部域时、临时对象生命期结束时、通过delete删除动态对象时。</p>

<p>在成员函数中访问自身对象成员：可以访问所有成员，直接使用成员名；</p>

<p>在成员函数中访问同类对象成员：可以访问所有成员，使用点号或者箭头语法；</p>

<p>在外部函数中访问对象成员：只能访问公有成员，使用点号或者箭头语法。</p>

<p>自身对象是定义成员函数时假设存在的对象，未来谁调用该成员函数，谁就是自身对象。C++语言提供了一个隐含的this指针专门用于指向自身对象。</p>


<p>在C++中处理C++类需要包含头文件和使用命名空间：</p>

<p>#include &lt;iostream.h></p>

<p>#include &lt;string></p>

<p>using namespace std;</p>



<p>以C++中，用new来申请堆内存空间，用delete来释放堆内存空间。</p>

<p>delete [] 指向堆内存空间首元素的地址;</p>

<p>如果只申请了一个堆内存变量，[]也可以省略。</p>



<p>C++在说明函数原型时，可以为一个或多个参数指定缺省值。调用此函数时，若缺省某一参数，C++自动以缺省值作为此参数的值。如：</p>

<p>     int special(int x=2, float y=1.5)</p>

<p> 调用时可用：</p>

<p>     special(5,3.2) //x=5; y=3.2</p>

<p>     special(6)     //x=6; y=1.5</p>

<p>     special( )     //x=2; y=1.5</p>

<p>缺省参数无论有几个，都必须放在参数序列的最后，</p>



<p>在函数调用时，若某个参数省略，则其后的参数皆应省略而取其缺省值</p>

<p>double *p, *q, *t;</p>

<p>p new double;</p>

<p>q = new double(1.0);  // q指向的单元被初始化为1.0</p>

<p>t = new double[10];  // 为t分配一个长度为10的一维数组；</p>

<p>如果分配失败，则返回一个空指针；</p>


<p>std::priority_queque：以特定顺序存储元素。因为优先级最高的元素总是位于队列开头。</p>


<p>把模板的实现和声明都写在头文件吧。</p>





<p>很多时候是一种宏替换操作，如define、typedef、inline；</p>

<p>函数重载和函数模板都是为了增加重用，一个是函数名的重用，一个是函数体的重用。</p>

<p>结构体是一组变量的集合，类是一组变量和函数的集合。</p>

<p>集合和元素的名称分别对应内存空间的基地址和偏移地址。</p>

<p>对于类，除了多了函数成员以外，还定义了偏移空间的访问权限。</p>



<p>可以用extern或::在局部域引用外面的变量；</p>


<p>在C++中，赋值与初始化是不一样的，赋值是删除原值，赋予新值，初始化则是开辟空间和初始化同时完成，直接给予一个新值；</p>




<p>有两种方法可用于定义类型别名：传统的方法是使用关键字typedef；C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用using.</p>

<p>关键字typedef作为声明语句中的基本数据类型的一部分出现。含有typedef的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。</p>

<p>C++11中用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>


<p>初始化列表和右值都是C++11


<p>在C++中，我们是通过抽象基类（abstract base class）来实现接口与实现分离的。</p>

<p>从某种意义上说，模板只不过是语法宏的一种受限形式。以类型作为参数并产生代码。与普通宏不同，模板足够安全。</p>




<p>string类与vector,后者也不只是字符串。</p>


<p>Pointers and References as Modifiers So far, you’ve seen the basic data types char, int, float, and double, along with the specifiers signed, unsigned, short, and long, which can be used with the basic data types in almost any combination. Now you’ve added pointers and references that are orthogonal to the basic data types and specifiers, so the possible combinations have just tripled.</p>



<p>函数在编译时被分配给一个入口地址。这个入口地址就称为函数的地址，也是函数的指针。</p>
<p>指针数组与二级指针：</p>
<p>char  *str[ ]={“China”, “Japan”, “America”};</p>

<p>**str</p>

<p>*(*(str+0)+0)</p>

<p>//C</p>









<p>实际上，线性表相当于一个整型数组，List为数组的首地址，nMax为数组在内存开辟的空间数，nElem为数组中实际存放的元素个数。只不过数组的空间是动态开辟的。</p>


<p>随机数是对某个“初始数”进行某种迭代运算而产生的，如每次取三角函数结果的第N位等。</p>









</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>
