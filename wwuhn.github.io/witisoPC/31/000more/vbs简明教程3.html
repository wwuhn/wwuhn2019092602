<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 <script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>vbs简明教程3</title>

 <style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.4em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 105px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 30px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 80px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 55px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 
 img{
 border:0;
 }
 
 \s*</p>

<p>\s*
 
 
</p>

<p>
</style>
</head>

<body>

<div class="container">
<p>WMI即Windows 管理规范(
    Windows Management Instrumentation )，是用户管理本地和远程计算机的一种模型。通过它可以访问、配置、管理和监视几乎所有的 Windows 资源。WMI的语法十分简单，基本上常见的命名空间、对象等用几乎一模一样。它对应的是Windows里的WMI服务（winmgmt）。</p>

<p>一、WMI的起源</p>

<p>几年前，几家资深的计算机公司由于系统管理领域缺少标准，委托DMTF启动了CIM（通用信息模型）项目，理想的CIM是一种不受限制于任何特定实现环境的管理工具。WMI是CIM的微软实现，它有很多类是从CIM中派生出来的。</p>

<p>二、WMI的命名空间</p>

<p>那么命名空间是做什么作用的呢？我简单这样说，在同一段代码中，如果有两个变量或函数的名字完全相同，就会出现冲突。命名空间就是为解决变量、函数的命名冲突而服务的。解决的办法就是将你的变量定义在一个不同名字的命名空间中。就好像财政局有个张三，公安局也有个张三，但我们清楚，就是因为他们分属不同的单位。有些地方可能不太准确，但大致意思就是这样了。</p>

<p>WMI的命名空间创建了一个层次结构，有点类似于我们的目录文件结构。</p>

<p>1、  root-作为所有其他名字的占位符；</p>

<p>2、  root\default-与注册表操作有关的类；</p>

<p>3、  root\security-与系统安全有关的类；</p>

<p>4、  root\cimv2-从CIM派生的类，代表我们最常用的工作环境。</p>

<p>三、WMI的对象路径</p>

<p>WMI的对象路径用来在CIM库中定位类和它的事例，对象路径用两个反斜杠\\开头，第一个元素是目标计算机的名字，第二个元素是相应的WMI命名空间，第三个元素是相应的类名，并用  ： 将它与命名空间分隔开来。例如：\\..\root\cimv2:win32_service</p>

<p>其中那个 . 代表是本地系统。</p>

<p>四、WMI的查询语言——WQL仅仅是ANSI SQL的一个子集，只能用于数据的提取。</p>

<p>数据、事件查询的基本语法为：</p>

<p>Select pro1 , pro2 , pro3   from myclass（myclassevent）</p>

<p>例如：Select  name , path from Win32_share  说明：列出所有共享的名称和路径</p>

<p>也可以使用通配符 * ，例如：Select *  from Win32_share</p>

<p>关键字Where 用于限定查询的范围。</p>

<p>例如：Select *  from Win32_share where name=”Admin”</p>

<p>五、WMI脚本中使用的三个步骤</p>

<p>步骤 1：连接到 WMI 服务</p>

<p>在任何 WMI 脚本中，第一个步骤都是建立一个到目标计算机上的 Windows 管理服务的连接。方法是调用 VBScript 的 Getobject 函数并将 WMI 脚本库的名字对象的名称（即“winmgmts:”，后跟目标计算机的名称）传递到 Getobject，并返回一个对象的引用，此时，您就可以调用其提供的方法如：InstancesOf，正如方法名所示，InstancesOf 返回由资源的类名标识的托管资源的所有实例。</p>

<p>步骤 2：检索 WMI 托管资源的实例</p>

<p>一般采用WQL来实现。</p>

<p>步骤 3：显示 WMI 托管资源的属性</p>

<p>最后一个步骤是枚举 检索得到集合的内容。一般采用</p>

<p>For each enum in  myclass</p>

<p>……</p>

<p>Next       结构来实现。</p>


<p>今天，我沼泽将给大家介绍个朋友，它就是Microsoft Windows Management Instrumentation (WMI)。中文名字叫Windows管理规范。从Windows  2000开始，WMI（Windows 管理规范）就内置于操作系统中，并且成为了Windows系统管理的重要组成部分。所以大家很容易就能见到它的，因为我们至少也应该是个Windows 2000的使用者了。下面我将详细介绍它的每个细节，让你从不认识它到喜欢上它。</p>

<p>WMI能做什么？</p>

<p>WMI不仅可以获取想要的计算机数据，而且还可以用于远程控制。远程控制计算机可是大家都喜欢的东西。很多远程监视控制类软件通常的做法是：在远程计算机上运行服务端后台程序，在本地计算机上运行一个客户器端控制程序，通过这二个程序的勾结来实现对计算机的远程控制。这种作法的缺点是十分明显的，当服务端程序关了，这种远程监控就无法实现了，因为没有内线了。而WMI实现的远程监视和控制完全不需要另外装什么服务端的东西，系统默认就将WMI服务给开了。具体说来，WMI的本领如下：</p>

<p>1．获取本地和远程计算机的硬件软件信息。</p>

<p>2．监视本地和远程计算机的软件和服务等运行状况。</p>

<p>3．控制本地和远程计算机的软件和服务运行。</p>

<p>4．高级应用。</p>
<p>如何访问WMI？</p>

<p>当我们知道WMI的某些本领后，我们已经很想知道如何认识他并利用他了。利用WMI有许多途径，简单说来有三种了：</p>

<p>1．通过微软给我们提供的各种工具来实现普通查询和操作。主要包括命令提示符下面的WMIC，还有就是微软给我们提供的WMI TOOL，大家可以到微软的网站上免费下载，当然我也可以给大家免费提供。</p>

<p>2．通过自己编写脚本来实现更灵活操作。要想真正灵活实用，对WSH脚本的熟悉是必须的，当然如果你不熟悉也没有关系，稍后我会给大家详细解释的。</p>

<p>3. 通过编写我们自己的程序来访问并操作它。什么语言都行。如果用.NET类程序要简单些了，如果用VC等要复杂些了，起码我是这么认为的。</p>

<p>4．还有个访问它的方法，就是到它的一个巢穴。在C:\WINDOWS\system32\wbem目录中的东西都和它有密切联系，有日志和各种工具，在里面你可以找到很多答案的。不过这些东西一般都不适合我们新手玩了，感觉有点吓人。</p>
<p>我们今天的任务？</p>

<p>今天我们的任务有五个：</p>

<p>任务一：利用WMIC列出远程计算机上的所有进程。</p>

<p>任务二：利用WMIC关闭本地进程。</p>

<p>任务三：通过WMIC把远程主机的进程信息保存在一个网页中</p>

<p>任务四：利用脚本实时监视对方进程</p>

<p>任务五：利用脚本给对方开放共享</p>

<p>查看和监视进程，还要把进程给杀掉，最后还要给对方开个共享，我们这位朋友快把坏事做尽了。明白了我们的任务，我们就可以上路了。这次我们将主要借助WMIC和脚本来实现我们的任务，所以我们将主要分为两大部分来讲解。在五个任务的实战中我们将更加深入地理解它，没有基础没有关系，我将尽力去解释所有的所谓的基础，让大家能很轻松地和这位朋友交流。</p>
<p>第一部分：利用WMIC来认识WMI</p>

<p>WMIC是Windows Management Instrumentation Commandline的简称，WMIC扩展WMI，提供了从命令行接口和批命令脚本执行系统管理的支持。为WMI名称空间提供了一个强大的、友好的命令行接口。有了WMIC，WMI就显的平易近人了。</p>

<p>执行“WMIC”命令将启动WMIC命令行环境。第一次执行WMIC命令时，Windows首先要安装WMIC，然后显示出WMIC的命令行提示符。在WMIC命令行提示符上，命令将以交互的方式执行。如果你不知道该如何和它交互，请敲个“/?”，细细看完全部的说明，你就知道了。WMIC也可以按照非交互的模式运行。如果要执行某个单步的任务，或者运行批命令中的一系列WMIC命令，非交互模式就很有用。要使用非交互模式，只要在同一个命令行上启动WMIC并输入要执行的命令就可以了。</p>
<p>1．任务一：利用WMIC列出远程计算机上的所有进程</p>

<p>这是一个实现起来很简单的任务，和你用一个DOS命令一样简单，因为我们要循序渐进嘛，所以安排了这么一个热身任务。在命令提示符下敲入下面的命令，我们将看到。</p>

<p>WMIC /node:192.168.1.2 /user:net process</p>

<p>解说：</p>

<p>1）上面命令中的NODE和USER是全局开关。如果你不愿意另外输一次密码，你也可以用PASSWORD开关，后面写上密码就可以了（WMIC /node:192.168.1.2 /user:net /password:password process）。千万要注意，这里的用户名和密码都必须是管理员级别的，其它的无效。WMIC提供了大量的全局开关、别名、动词、命令和丰富的命令行帮助增强用户接口。全局开关是用来配置整个WMIC会话的选项。</p>

<p>2）Process是个别名，执行了一个Win32_process类的WQL查询，至于说是WMI的类是什么东西，感兴趣的就自己找资料多多了解，如果你很懒的话，就等我有时间给你开课讲解。别名是用户和WMI名称空间一个简化语法的中间层。当你指定一个别名时，动词（Verb）表示要执行的动作。</p>

<p>3）如果你愿意，你可以在该后面加上个动词等，比如 LIST FULL等（如：WMIC /node:192.168.1.2 /user:net /password:password process），这样你就看得更清楚了。</p>
<p>小提示：安装了WMIC的机器可以连接到任何一台安装了WMI的机器，被连接的机器不需要安装WMIC。</p>
<p>2．任务二：利用WMIC关闭本地进程</p>

<p>执行下面的命令将关闭正在运行的QQ。我比较胆小，所以不敢关别人的QQ，只能拿我的QQ试验了，如果你的智商还够用的话，胆子比较大的话，你很快就会去关别人的了。</p>

<p>WMIC</p>

<p>process where name=”qq.exe” call terminate</p>

<p>解说：</p>

<p>1）这次我们是用交互式的方法来执行任务，具体界面我就不多说了，图上画的比我说的好多了。</p>

<p>2）Call也是个动词，这个动词可是厉害了，控制类的没有不用它的，它就是可以调用各种类的各种方法的大将。这里我们调用了terminate方法。从字面上你就可以看出是恶狠狠的。</p>

<p>3）Where能够让你查询和筛选。在超级多的实例中找到你想要的。实例就是指每个类的具体实现了。前面的例子中看到的各个进程都分别算是WIN32_PROCESS中的一个实例。</p>
<p>3．任务三：通过WMIC把远程主机的进程信息保存在一个网页中</p>

<p>这个任务和任务一中的大致相同，是任务一的加强。在任务一中信息以文本的形式显示出来了。其实除了文本形式的输出之外，WMIC还能够以其他形式返回命令执行结果，例如XML、HTML或者CSV（逗号分隔的文本文件），如图3所示。我们可以敲入下面的命令：</p>

<p>wmic /output:C:\1.html /node:192.168.1.2 /user:net process list full  /format:hform.xsl</p>

<p>输入密码 :******</p>
<p>解释：</p>

<p>1）全局开关OUTPUT指明将这些信息保存在什么地方。</p>

<p>2）全局开关FORMAT指明了用什么样的格式，至于说有那些格式可以用，你可以参看C:\WINDOWS\system32\wbem目录中的*.xsl文件，你甚至不用管它们从哪里来的，用就是了。挨着看看，一定可以找到你喜欢的。</p>

<p></p>

<p>第二部分：利用脚本来认识WMI</p>

<p>命令提示符的工具确实好用，但是却显示不出我们是高手，高手都是能利用程序来实现目的的。下面我们就开始用脚本来实现我们的任务，功能将更加强大，操作将更加灵活。</p>

<p>无论脚本还是真正意义上的程序，要检索 WMI 托管资源信息进而查询并利用WMI，都需要遵循以下三个步骤的。</p>

<p>1．连接到 WMI 服务。建立一个到目标计算机上的 Windows 管理服务的连接。</p>

<p>2．检索 WMI 托管资源的实例。主要取决于要执行的任务。</p>

<p>3．显示WMI 某实例属性和调用其方法。</p>
<p>1．任务四：利用脚本实时监视对方进程</p>

<p>在任务一和任务三中我们都是在查看对方的进程，出来的结果对我们意义不是很大，在这个任务中我们要从现在开始每当他开一个任务我们就察觉到，并把它记录下来。我们要在他开进程的那一秒开始报告并记录，我们要清楚他所开的程序所在的位置，我们要比他更清楚地知道这些信息。</p>

<p>现在我们就按照前面提到的三个步骤来实现任务。</p>

<p>首先，我们连接到对方的WMI。在这里我们首先调用  VBScript 的中的Createobject（）来得到一个对象，然后利用这个特殊的对象的方法来连接到远程的计算机上。这个特殊的对象就是wbemscripting.swbemlocator。</p>

<p>set olct=createobject(&quot;wbemscripting.swbemlocator&quot;)</p>

<p>set wbemServices=olct.connectserver(strComputer,&quot;root\cimv2&quot;,strUser,strPwd)</p>

<p>注意其中的strComputer就是你所要连接的计算机的名称或者IP地址，strUser，strPwd当然就是用户名和密码了，我们说过这个用户必须是具有管理员权限的才可以。root\cimv2是WMI的命名空间，关于WMI的命名空间，大家可以到“计算机管理\WMI控件”中看到，这里面的学问就大了，得慢慢琢磨，为了我们的任务快速实现，我就不多解释了。用这种方法连接到WMI，返回一个对SWbemServices对象的引用，一旦有一个对 SWbemServices对象的引用。我们就可以进行第二个步骤了。</p>

<p>在第二个步骤中，我们将得到WMI  托管资源的实例，我们利用WbemServices中的一个方法ExecNotificationQuery可以查询我们所要的类，进而可以得到该类中实例。</p>

<p>Set colMonitoredProcesses = wbemServices. _</p>

<p>ExecNotificationQuery(&quot;select * from __instancecreationevent  &quot; _</p>

<p>&amp; &quot; within 1 where TargetInstance isa 'Win32_Process'&quot;)</p>

<p>注意这里有个类似于SQL语言的查询语言，这里叫做WQL语言，懂SQL的一看就明白了，不懂的就在网上找找它的资料，满天都是。得到的colMonitoredProcesses是所查询的类的实例的集合。有了这些我们的第三个步骤就可以开始了。</p>

<p>在第三个步骤中，我们将显示出得到的实例中的属性。刚才我们得到的是实例的集合，在这里我们通过colMonitoredProcesses.NextEvent来获取每一个具体的实例，得到每一个具体的实例后，我们就可以显示出他们的属性，也就是我们想看的东西了。这里我们显示了CommandLine的属性值。</p>

<p>到现在你是否有些迷惑了，因为你还不知道到底WMI里面有那些类，具体类又有哪些属性，呵呵，没有关系的，用一些工具可以很轻松的得到这些信息。比如系统自带的wbemtest，在运行中敲入这个程序名，你就可以看到这些了，它也遵循连接、查询、枚举这三个步骤。自己慢慢玩吧，很快你就会发现WMI太大了，单是命名空间就有10多个，然后单是我们常用的空间root\CIMV2里面就有近1000个类，每个类里面又有好多的属性，有些类还有好多方法。哈哈，头晕了吧？没关系，其实你只需要知道其中的一些就好了。</p>

<p>看到这些估计你的头已经很大了，但是恭喜你，我们的这个任务已经完成了，是的，就是这么简单，下面我将完整代码奉献出来。</p>

<p>Set colArgs = WScript.Arguments</p>

<p>If WScript.arguments.count &lt; 3 then</p>

<p>WScript.Echo &quot;USAGE:&quot; &amp; vbCrLf &amp; &quot; Monitor  Computer User Password files&quot;</p>

<p>WScript.quit</p>

<p>End If</p>

<p>strComputer = wscript.arguments(0)</p>

<p>strUser = wscript.arguments(1)</p>

<p>strPwd = wscript.arguments(2)</p>

<p>strFile = wscript.arguments(3)</p>
<p>set olct=createobject(&quot;wbemscripting.swbemlocator&quot;)</p>

<p>set  wbemServices=olct.connectserver(strComputer,&quot;root\cimv2&quot;,strUser,strPwd)</p>

<p>Set colMonitoredProcesses = wbemServices. _</p>

<p>ExecNotificationQuery(&quot;select * from __instancecreationevent  &quot; _</p>

<p>&amp; &quot; within 1 where TargetInstance isa  'Win32_Process'&quot;)</p>
<p>i = 0</p>

<p>Do While i = 0</p>

<p>Set objLatestProcess = colMonitoredProcesses.NextEvent</p>

<p>Wscript.Echo now &amp; &quot; &quot; &amp;  objLatestProcess.TargetInstance.CommandLine</p>

<p>Set objFS = CreateObject(&quot;Scripting.FileSystemObject&quot;)</p>

<p>Set objNewFile = objFS.OpenTextFile(strFile,8,true)</p>

<p>objNewFile.WriteLine Now() &amp; &quot; &quot; &amp;  objLatestProcess.TargetInstance.CommandLine</p>

<p>objNewFile.Close</p>

<p>Loop</p>
<p>到这个程序的核心了吧？相信你已经懂了其中的很多，剩余的部分代码我稍后解释。我们先来感性认识一下，先看它该怎么用吧！把上面的代码拷贝到记事本中，然后保存为monitor.vbs的文件，然后在命令提示符下输入：</p>

<p>CSCRIPT monitor.vbs</p>

<p>回车，你就会看到帮助，下面举例说明这个脚本的具体用法：</p>

<p>CSCRIPT monitor.vbs 192.168.1.2 user password C:\1.txt</p>

<p>在命令提示符下敲入上面的命令就OK了，每当对方开一个程序的时候，你就可以看到时间，程序路径和程序名。如果你没有时间去看这些信息，你还可以等有时间的时候到C:\1.txt看到这些信息。</p>
<p> </p>
<p>

<h4>六、WMI 测试器  (wbemtest.exe)验证脚本执行结果</h4>

<p>现在，您对可用于浏览和查看  CIM 的工具已经有了一些认识，让我们使用 WMI 测试器 (wbemtest.exe) 来检查 Win32_Process 类定义，以便从在您的本地计算机上运行的进程检索一些属性。</p>

<p>1.打开一个命令提示，键入 C:\&gt;wbemtest.exe，按下 Enter 来开始 WMI 测试器工具。请注意，大部分按钮在主 WMI 测试器窗口上是被禁用的，这说明此时您没有连接到 WMI。</p>

<p>2.单击  “连接”按钮 连接到本地或远程计算机上的  WMI 服务。显示“连接”对话框，它提供一个标记为  名称空间 的文本输入区域，该区域默认值为 root\default。将  名称空间 区域的值更改为  root\cimv2，单击“连接”对话框的  连接 按钮返回到主 WMI 测试器窗口。</p>

<p>3.主窗口中左上角的命名空间标识符应该显示为 root\cimv2。请注意，所有的按钮现在都已启用，这说明在当前凭据环境下，您已经成功连接到本地主机上的 WMI。单击  枚举类别 打开“超类信息”对话框。</p>

<p>4.在“超类信息”对话框中，不要填写  输入超类别名称 区域，单击 递归 选项，单击 确定 以枚举 root\cimv2 名称空间中定义的所有  CIM 类。</p>

<p>请注意，列于“查询结果”对话框顶部的类是以两个下划线为开头的。这些是系统类。系统类是预定义的 CIM 类，支持内部 WMI 配置与操作，例如提供程序注册、命名空间安全性及事件通知等。现在，忽略系统类，向下滚动“查询结果”对话框直至看到以 CIM_ 开头的类。名称以 CIM_ 开头的类是由 DMTF 维护的核心与公共基类。继续向下滚动直至到达以 Win32_ 开头的类。  名称以 Win32_ 开头的类是 Microsoft 扩展类，表示 Windows 特定的托管资源。如果这是您第一次检查 root\cimv2 命名空间，您可能希望熟悉root\cimv2 命名空间中的类的完整集合，尤其是有 Win32_ 前缀的类。</p>

<p>5.向下滚动“查询结果”对话框直至到达 Win32_Process 类，双击该类名打开 Win32_Process 对话框的对象编辑器。</p>

<p>6.“对象编辑器”对话框显示被选定类的定义和实现的详细信息（属性和方法）。选择 Hide System Properties 复选框隐藏系统属性。剩余的  Win32_Process 属性表示您可以从在本地或远程计算机上运行的进程检索的信息。</p>

<p>运行如下代码：</p>

<p>strComputer = &quot;.&quot;</p>

<p>Set wbemServices = Getobject(&quot;winmgmts:\\&quot; &amp;  strComputer)</p>

<p>Set wbemObjectSet =  wbemServices.InstancesOf(&quot;Win32_Process&quot;)</p>

<p>For Each wbemObject In wbemObjectSet</p>

<p>WScript.Echo  &quot;Name:          &quot; &amp;  wbemObject.Name      &amp; vbCrLf &amp; _</p>

<p>&quot;   Handle:      &quot; &amp; wbemObject.Handle     &amp; vbCrLf &amp; _</p>

<p>&quot;   Process ID: &quot; &amp;  wbemObject.ProcessID</p>

<p>Next</p>

<p>7.在运行脚本之后，您可以用 WIMI 测试器验证脚本的结果。在 Win32_Process 对话框的对象编辑器中，单击 Instances。产生的查询结果对话框列出在计算机上运行的进程的实例。双击一个指定的进程实例，查看该实例的详细信息</p>

<h4>阻止客人运行你不想运行的程序</h4>

<p>很多人都有这样的经验，刚刚装好的系统，让人运行了一些你不想他运行的程序，比如说QQ，又是聊天，又是下载表情，不过一会，流氓插件、病毒、木马已经盘踞了你的计算机，常常是忍痛将这个程序卸载，可是不知情的人很自觉的下载安装，使整个系统无法正常运行。</p>

<p>其实用vbs和wmi结合起来，使你的计算机上有相应的程序安装，别人又无法运行起来太容易了，现在给出代码：</p>

<p>On Error Resume Next    '忽略所有的错误</p>

<p>Dim bag,pipe,honker,good</p>

<p>Do</p>

<p>good=&quot;.&quot;     '定义为本地计算机</p>

<p>set bag=getobject(&quot;winmgmts:\\&quot;&amp; good &amp;&quot;\root\cimv2&quot;)     'l连接到cimv2命名空间</p>

<p>set pipe=bag.execquery(&quot;select * from win32_process where  name='qq.exe' or name='qqgame.exe' or name='winmine.exe'&quot;)    '看，这是我的计算机上不允许运行的程序，qq、qqgame、winmine（扫雷）如果你还有其他的程序不允许运行，很简单，在其中添加 or name='你不允许运行的程序名'</p>

<p>for each i in pipe</p>

<p>i.terminate()</p>

<p>msgbox &quot;发现盗版系统，现已进行功能限制！&quot; &amp; vbcrlf &amp; &quot;请使用正版软件！&quot;,,&quot;微软提示&quot;    '此行其实可有可无，有这行只是为了免去怀疑</p>

<p>next</p>

<p>wscript.sleep 60000    '每1分钟检测一次</p>

<p>loop</p>

<p>那么如果我自己想运行这些程序该怎么办呢？很简单，Ctrl+Alt+Del三个键齐按，打开windows任务管理器，在进程中结束Wscript.exe和wmiprvse.exe进程的运行就可以了</p>


<h4>dictionnary对象</h4>
<p>VBS中存在一个特殊的对象－dictionnary，是一个集合对象。一般情况霞，我把这个特殊的集合想象为数组，可以使用其中内建的函数完成存储和操纵数据等基本任务，无须担心数据是在哪些行列，而是使用唯一的键进行访问或者是一个只能运行在内存中的数据库，并只有两个字段分别是：key和item，在使用中，字段key是索引字段。</p>

<p>set sdict=CreateObject(&quot;Scripting.Dictionary&quot;)</p>

<p>sdict.add &quot;a&quot;,&quot;apple&quot;</p>

<p>sdict.add &quot;b&quot;,&quot;banana&quot;</p>

<p>sdict.add &quot;c&quot;,&quot;copy&quot;</p>

<p>for each key in sdict.keys</p>

<p>msgbox     &quot;键名&quot;  &amp;   key     &amp; &quot;是&quot; &amp; &quot;  = &quot; &amp; sdict (key)</p>

<p>next</p>

<p>sdict.removeall</p>

<p>这个脚本很简单，就是定义了一个 dictionary 对象的实例sdict，并加入了三条数据，然后对每一条数据进行了枚举，最后，将对象的实例清空。</p>

<p>Dictionary 对象的成员概要</p>

<p>属性和说明</p>

<p>CompareMode    设定或返回键的字符串比较模式</p>

<p>Count     只读。返回 Dictionary  里的键/条目对的数量</p>

<p>Item(key)  设定或返回指定的键的条目值</p>

<p>Key(key)  设定键值</p>

<p>方法和说明</p>

<p>Add(key,item)  增加键/条目对到  Dictionary</p>

<p>Exists(key)  如果指定的键存在，返回  True，否则返回 False</p>

<p>Items()  返回一个包含  Dictionary 对象中所有条目的数组</p>

<p>Keys()  返回一个包含  Dictionary 对象中所有键的数组</p>

<p>Remove(key)  删除一个指定的键/条目对</p>

<p>RemoveAll()   删除全部键/条目对</p>

<p>Abs 函数：返回数的绝对值。</p>

<p>Array 函数：返回含有数组的变体。</p>

<p>Asc 函数：返回字符串首字母的 ANSI 字符码。</p>

<p>Atn 函数：返回数值的反正切。</p>

<p>CBool 函数：返回已被转换为 Boolean 子类型的变体的表达式。</p>

<p>CByte 函数：返回已被转换为字节子类型的变体的表达式。</p>

<p>CCur 函数：返回已被转换为货币子类型的变体的表达式。</p>

<p>CDate 函数：返回已被转换为日期子类型的变体的表达式。</p>

<p>CDbl 函数：返回已被转换为双精度子类型的变体的表达式。</p>

<p>Chr 函数：返回与指定的 ANSI 字符码相关的字符。</p>

<p>CInt 函数：返回已被转换为整形子类型的变体的表达式。</p>

<p>CLng 函数；返回已被转换为Long子类型的变体的表达式。</p>

<p>Cos 函数：返回角度的余弦。</p>

<p>CreateObject 函数：创建并返回对“自动”对象的引用。</p>

<p>CSng 函数：返回已被转换为单精度子类型的变体的表达式。</p>

<p>CStr 函数：返回已被转换为字符串子类型的变体的表达式。</p>

<p>Date 函数：返回当前系统日期。</p>

<p>DateAdd 函数：返回的日期已经加上了指定的时间间隔。</p>

<p>DateDiff 函数：返回两个日期之间的间隔。</p>

<p>DatePart 函数：返回给定日期的指定部分。</p>

<p>DateSerial 函数：返回指定年月日的日期子类型的变体。</p>

<p>DateValue 函数：返回日期子类型的变体。</p>

<p>Day 函数：返回日期，取值范围为 1 至 31。</p>

<p>Eval 函数：计算表达式并返回结果。</p>

<p>Exp 函数：返回 e （自然对数的底）  的多少次方。</p>

<p>Filter 函数：根据指定的筛选条件,返回含有字符串数组子集的、下限为 0 的数组。</p>

<p>Fix 函数：返回数的整数部分。</p>

<p>FormatCurrency 函数：返回的表达式为货币值格式，其货币符号采用系统控制面板中定义的。</p>

<p>FormatDateTime 函数：返回的表达式为日期和时间格式。</p>

<p>FormatNumber 函数：返回的表达式为数字格式。</p>

<p>FormatPercent 函数：返回的表达式为百分数（乘以 100）格式，后面有 % 符号。</p>

<p>GetObject 函数：返回从文件对“自动”对象的引用。</p>

<p>GetRef 函数：返回对能够绑定到一事件的过程的引用。</p>

<p>Hex 函数：返回一字符串，代表一个数的十六进制值。</p>

<p>Hour 函数：返回表示钟点的数字，取值范围为 0 至 23。</p>

<p>InputBox 函数：在对话框中显式一提示，等待用户输入文本或单击按钮，并返回文本框的内容。</p>

<p>InStr 函数：返回一个字符串在另一个字符串中首次出现的位置。</p>

<p>InStrRev 函数；返回一个字符串在另一个字符串中出现的位置，但是从字符串的尾部算起。</p>

<p>Int 函数：返回数的整数部分。</p>

<p>IsArray 函数：返回 Boolean 值，反映变量是否为数组。</p>

<p>IsDate 函数：返回 Boolean 值，反映表达式能否转换为日期。</p>

<p>IsEmpty 函数：返回 Boolean 值，反映变量是否已被初始化。</p>

<p>IsNull 函数：返回 Boolean 值，反映表达式是否含有无效数据(Null)。</p>

<p>IsNumeric 函数：返回 Boolean 值，反映表达式能否转换为数字。</p>

<p>IsObject 函数：返回 Boolean 值，反映表达式是否引用了有效的“自动”对象。</p>

<p>Join 函数：返回通过连接许多含有数组的子串而创建的字符串。</p>

<p>LBound 函数；返回指定维数数组的最小有效下标。</p>

<p>LCase 函数：返回的字符串已被转换为小写字母。</p>

<p>Left 函数：返回字符串最左边的指定数量的字符。</p>

<p>Len 函数：返回字符串中的字符数或存储变量所需的字节数。</p>

<p>LoadPicture 函数：返回图片对象。只用于 32 位平台。</p>

<p>Log 函数：返回数的自然对数。</p>

<p>LTrim 函数；返回去掉前导空格的字符串。</p>

<p>Mid 函数：从字符串中返回指定数量的字符。</p>

<p>Minute 函数：返回分钟数，取值范围为 0 至 59。</p>

<p>Month 函数：返回表示月份的数，取值范围为 1 至 12。</p>

<p>MonthName 函数：返回表示月份的字符串。</p>

<p>MsgBox 函数：在对话框中显示消息，等待用户单击按钮，并返回表示用户所击按钮的数值。</p>

<p>Now 函数：返回计算机的当前系统日期和时间。</p>

<p>Oct 函数：返回表示该数八进制数值的字符串。</p>

<p>Replace 函数：返回一字符串，其中指定的子串已被另一个子串替换了规定的次数。</p>

<p>RGB 函数：返回代表 RGB 颜色值的数字。</p>

<p>Right 函数：返回字符串最右边的指定数量的字符。</p>

<p>Rnd 函数：返回随机数。</p>

<p>Round 函数：返回指定位数、四舍五入的数。</p>

<p>RTrim 函数：返回去掉尾部空格的字符串副本。</p>

<p>ScriptEngine 函数：返回反映使用中的脚本语言的字符串。</p>

<p>ScriptEngineBuildVersion 函数：返回使用中的脚本引擎的编译版本号。</p>

<p>ScriptEngineMajorVersion 函数：返回使用中的脚本引擎的主版本号。</p>

<p>ScriptEngineMinorVersion 函数：返回使用中的脚本引擎的次版本号。</p>

<p>Second 函数：返回秒数，取值范围为 0 至 59。</p>

<p>Sgn 函数：返回反映数的符号的整数。</p>

<p>Sin 函数：返回角度的正弦值。</p>

<p>Space 函数：返回由指定数量的空格组成的字符串。</p>

<p>Split 函数：返回下限为 0 的、由指定数量的子串组成的一维数组。</p>

<p>Sqr 函数：返回数的平方根。</p>

<p>StrComp 函数：返回反映字符串比较结果的数值。</p>

<p>String 函数：返回指定长度的重复字符串。</p>

<p>StrReverse 函数：返回一字符串，其中字符的顺序与指定的字符串中的顺序相反。</p>

<p>Tan 函数：返回角度的正切值。</p>

<p>Time 函数：返回表示当前系统时间的“日期”子类型的“变体”。</p>

<p>Timer 函数：返回时经子夜 12：00 AM 后的秒数。</p>

<p>TimeSerial 函数：返回含有指定时分秒时间的日期子类型的变体。</p>

<p>TimeValue 函数：返回含有时间的日期子类型的变体。</p>

<p>Trim 函数：返回去掉前导空格或尾部空格的字符串副本。</p>

<p>TypeName 函数：返回一字符串，它提供了关于变量的变体子类型信息。</p>

<p>UBound 函数：返回指定维数数组的最大有效下标。</p>

<p>UCase 函数：返回的字符串已经被转换为大写字母。</p>

<p>VarType 函数：返回标识变体子类型的数值。</p>

<p>Weekday 函数：返回表示星期几的数值。</p>

<p>WeekdayName 函数：返回表示星期几的字符串。</p>

<p>Year 函数：返回表示年份的数值。</p>

<h4>事件<a name="shi" id="shi"></a></h4>
<p>什么是事件？在我看来，事件就象我们手机上的闹钟，闹钟一响，我们就要去做某些特定的事情。或者这样说，事件就像警钟，当程序运行时，有特殊的事情发生，就会激发事件，事件本身就是一条消息，如果你编写的脚本要对事件进行处理，就需要一个特殊的过程或者函数来接受和处理事件。那么这个特殊的过程或者函数在程序运行时，就不断的监听，看系统是否传来了相应的事件，一旦接受到事件，脚本对此作出反应。</p>
<p>那么事件是从那里来的呢？是否需要我们在脚本中对事件进行编写呢？一般情况下，[作者：临汾市外事旅游局薛靖澜，转载请注明出处]事件是某个程序在运行中的特殊状态发出的，我们不需要对事件进行编写，只需要编写处理事件的函数。比如说我们用vbs建立了ie的一个实例，那么当ie的窗口被关闭的时候，就会激发出一个叫做OnQuit的事件。</p>
<p>是不是脚本自然而然就能接受事件并进行处理呢？我们说不是的，在创建对象的时候，我们将使用WSH的createobject命令，例如：</p>
<p>Set objie=Wscript.createobject(“internetexplorer.application”,”event_”)</p>
<p>注意到了吗？多了一个参数，这个参数的作用是什么呢？它叫做事件接收端，当脚本连接的对象包含事件时，如果对象调用的事件是OnBegin，那么WSH将会在脚本中调用一个event_OnBegin的事件处理程序。当然事件接受端并不是固定的，如果对象将其定义为MyObj_的话，那么事件处理程序将是：MyObj_OnBegin。</p>
<p>是否很熟悉？在打造个性化QQ一讲中，曾经出现过Window_OnSize(cx,cy)函数，它其实就是一个事件处理程序。</p>
<p>让我们来举个实际的例子完整的看看事件的处理过程：</p>
<p>Set  objie=WScript.CreateObject(&quot;InternetExplorer.Application&quot;,&quot;event_&quot;)</p>
<p>objie.Visible=True</p>
<p>MsgBox &quot;请关闭浏览器窗口看看效果！&quot;,vbSystemModal</p>
<p>Wscript.sleep 6000</p>
<p>MsgBox &quot;现在已经正常关闭了&quot;</p>
<p>&nbsp;</p>
<p>Sub event_onquit()</p>
<p>MsgBox &quot;您确定要关闭浏览器吗？&quot;,vbSystemModal</p>
<p>End Sub</p>
<p>这段脚本打开了一个IE窗口，然后要求你关闭IE窗口，当你关闭窗口的时候，自动调用事件响应程序。</p>


</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>
