<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>DLL后门原理</h3>

<p>一，DLL的原理
</p>

<p>1，动态链接程序库
</p>

<p>动态链接程序库，全称：Dynamic Link Library，简称：DLL，作用在于为应用程序提供扩展功能。应用程序想要调用DLL文件，需要跟其进行“动态链接”；从编程的角度，应用程序需要知道DLL文件导出的API函数方可调用。由此可见，DLL文件本身并不可以运行，需要应用程序调用。正因为DLL文件运行时必须插入到应用程序的内存模块当中，这就说明了：DLL文件无法删除。这是由于Windows内部机制造成的：正在运行的程序不能关闭。所以，DLL后门由此而生！
</p>

<p>2，DLL后门原理及特点
</p>

<p>把一个实现了后门功能的代码写成一个DLL文件，然后插入到一个EXE文件当中，使其可以执行，这样就不需要占用进程，也就没有相对应的PID号，也就可以在任务管理器中隐藏。DLL文件本身和EXE文件相差不大，但必须使用程序（EXE）调用才能执行DLL文件。DLL文件的执行，需要EXE文件加载，但EXE想要加载DLL文件，需要知道一个DLL文件的入口函数（既DLL文件的导出函数），所以，根据DLL文件的编写标准：EXE必须执行DLL文件中的DLLMain（）作为加载的条件（如同EXE的mian（））。做DLL后门基本分为两种：1）把所有功能都在DLL文件中实现；2）把DLL做成一个启动文件，在需要的时候启动一个普通的EXE后门。
</p>

<p>常见的编写方法：
</p>

<p>(1)，只有一个DLL文件
</p>

<p>这类后门很简单，只把自己做成一个DLL文件，在注册表Run键值或其他可以被系统自动加载的地方，使用Rundll32.exe来自动启动。Rundll32.exe是什么？顾名思意，“执行32位的DLL文件”。它的作用是执行DLL文件中的内部函数，这样在进程当中，只会有Rundll32.exe，而不会有DLL后门的进程，这样，就实现了进程上的隐藏。如果看到系统中有多个Rundll32.exe，不必惊慌，这证明用Rundll32.exe启动了多少个的DLL文件。当然，这些Rundll32.exe执行的DLL文件是什么，我们都可以从系统自动加载的地方找到。
</p>

<p>现在，我来介绍一下Rundll32.exe这个文件，意思上边已经说过，功能就是以命令行的方式调用动态链接程序库。系统中还有一个Rundll.exe文件，他的意思是“执行16位的DLL文件”，这里要注意一下。在来看看Rundll32.exe使用的函数原型：
</p>

<p>Void CALLBACK FunctionName (
</p>

<p>HWND hwnd,
</p>

<p>HINSTANCE hinst,
</p>

<p>LPTSTR lpCmdLine,
</p>

<p>Int nCmdShow
</p>

<p>);
</p>

<p>其命令行下的使用方法为：Rundll32.exe DLLname,Functionname [Arguments]
</p>

<p>DLLname为需要执行的DLL文件名；Functionname为前边需要执行的DLL文件的具体引出函数；[Arguments]为引出函数的具体参数。
</p>

<p>(2)，替换系统中的DLL文件
</p>

<p>这类后门就比上边的先进了一些，它把实现了后门功能的代码做成一个和系统匹配的DLL文件，并把原来的DLL文件改名。遇到应用程序请求原来的DLL文件时， DLL后门就启一个转发的作用，把“参数”传递给原来的DLL文件；如果遇到特殊的请求时（比如客户端），DLL后门就开始，启动并运行了。对于这类后门，把所有操作都在DLL文件中实现最为安全，但需要的编程知识也非常多，也非常不容易编写。所以，这类后门一般都是把DLL文件做成一个“启动”文件，在遇到特殊的情况下（比如客户端的请求），就启动一个普通的EXE后门；在客户端结束连接之后，把EXE后门停止，然后DLL文件进入“休息”状态，在下次客户端连接之前，都不会启动。但随着微软的“数字签名”和“文件恢复”的功能出台，这种后门已经逐步衰落。
</p>

<p>提示：
</p>

<p>在WINNTsystem32目录下，有一个dllcache文件夹，里边存放着众多DLL文件（也包括一些重要的EXE文件），在DLL文件被非法修改之后，系统就从这里来恢复被修改的DLL文件。如果要修改某个DLL文件，首先应该把dllcache目录下的同名DLL文件删除或更名，否则系统会自动恢复。
</p>

<p>(3)，动态嵌入式
</p>

<p>这才是DLL后门最常用的方法。其意义是将DLL文件嵌入到正在运行的系统进程当中。在Windows系统中，每个进程都有自己的私有内存空间，但还是有种种方法来进入其进程的私有内存空间，来实现动态嵌入式。由于系统的关键进程是不能终止的，所以这类后门非常隐蔽，查杀也非常困难。常见的动态嵌入式有：“挂接API”“全局钩子（HOOK）”“远程线程”等。
</p>

<p>远程线程技术指的是通过在一个进程中创建远程线程的方法来进入那个进程的内存地址空间。当EXE载体（或Rundll32.exe）在那个被插入的进程里创建了远程线程，并命令它执行某个DLL文件时，我们的DLL后门就挂上去执行了，这里不会产生新的进程，要想让DLL后门停止，只有让这个链接DLL后门的进程终止。但如果和某些系统的关键进程链接，那就不能终止了，如果你终止了系统进程，那Windows也随即被终止！！！
</p>

<p>3，DLL后门的启动特性
</p>

<p>启动DLL后门的载体EXE是不可缺少的，也是非常重要的，它被称为：Loader。如果没有Loader，那我们的DLL后门如何启动呢？因此，一个好的DLL后门会尽力保护自己的Loader不被查杀。Loader的方式有很多，可以是为我们的DLL后门而专门编写的一个EXE文件；也可以是系统自带的Rundll32.exe，即使停止了Rundll32.exe，DLL后门的主体还是存在的。3721网络实名就是一个例子，虽然它并不是“真正”的后门。
</p>

<p>二，DLL的清除
</p>

<p>本节以三款比较有名的DLL后门例，分别为“SvchostDLL.dll”“BITS.dll”“QoServer.dll”。详细讲解其手工清除方法。希望大家在看过这三款DLL后门的清除方法之后，能够举一反三，灵活运用，在不惧怕DLL后门。其实，手工清除DLL后门还是比较简单的，无非就是在注册表中做文章。具体怎么做，请看下文。
</p>

<p>1，PortLess BackDoor
</p>

<p>这是一款功能非常强大的DLL后门程序，除了可以获得Local System权限的Shell之外，还支持如“检测克隆帐户”“安装终端服务”等一系列功能（具体可以参见程序帮助），适用Windows2000/xp/2003等系统。程序使用svchost.exe来启动，平常不开端口，可以进行反向连接（最大的特点哦），对于有防火墙的主机来说，这个功能在好不过了。
</p>

<p>在介绍清除方法之前，我们先来简单的介绍一下svchost.exe这个系统的关键服务：
</p>

<p>Svchost只是做为服务的宿主，本身并不实现什么功能，如果需要使用Svchost来启动服务，则某个服务是以DLL形式实现的，该DLL的载体Loader指向svchost，所以，在启动服务的时候由svchost调用该服务的DLL来实现启动的目的。使用svchost启动某个服务的DLL文件是由注册表中的参数来决定的，在需要启动服务的下边都有一个Parameters子键，其中的ServiceDll表明该服务由哪个DLL文件负责，并且这个DLL文件必须导出一个ServiceMain()函数，为处理服务任务提供支持。
</p>

<p>呵呵！看了上边的理论，是不是有点蒙（我都快睡着了），别着急，我们来看看具体的内容（如图1）。从图1中，我们可以看到HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesRpcSs下的Parameters子键，其键值为%SystemRoot%system32rpcss.dll。这就说明：启动RpcSs服务时。Svchost调用WINNTsystem32目录下的rpcss.dll。
</p>

<p>在来看看图2，这是注册表的HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSvchost，里边存放着Svchost启动的组和组内的各个服务，其中netsvcs组的服务最多。要使用Svchost启动某个服务，则该服务名就会出现在HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSvchost下。这里有四种方法来实现：
</p>

<p>1，添加一个新的组，在组里添加服务名
</p>

<p>2，在现有组里添加服务名
</p>

<p>3，直接使用现有组里的一个服务名，但是本机没有安装的服务
</p>

<p>4，修改现有组里的现有服务，把它的ServiceDll指向自己的DLL后门
</p>

<p>我测试的PortLess BackDoor使用的第三种方法。
</p>

<p>好了，我想大家看完了上边的原理，一定可以想到我们清除PortLess BackDoor的方法了，对，就是在注册表的Svchost键下做文章。好，我们现在开始。
</p>

<p>注：由于本文只是介绍清除方法，使用方法在此略过。
</p>

<p>后门的Loader把SvchostDLL.dll插入Svchost进程当中，所以，我们先打开Windows优化大师中的Windows进程管理2.5，查看Svchost进程中的模块信息（如图3），从图3中我们可以看到，SvchostDLL.dll已经插入到Svchost进程中了，在根据“直接使用现有组里的一个服务名，但是本机没有安装的服务”的提示，我们可以断定，在“管理工具”—“服务”中会有一项新的服务。图4证明了我的说法，此服务名称为：IPRIP，由Svchost启动，-k netsvcs表示此服务包含在netsvcs服务组中。
</p>

<p>我们把该服务停掉，然后打开注册表编辑器（开始—运行--regedit），来到HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesIPRIP下，查看其Parameters子键（如图5）。Program键的键值SvcHostDLL.exe为后门的Loader；ServiceDll的键值C:WINNTsystem32svchostdll.dll为调用的DLL文件，这正是后门的DLL文件。现在我们删除IPRIP子键（或者用SC来删除），然后在来到HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSvchost下，编辑netsvcs服务组，把49 00 70 00 72 00 69 00 70 00 00 00删除，这里对应的就是IPRIP的服务名，具体如图6所示。然后退出，重启。重启之后删除WINNTsystem32目录下的后门文件即可。
</p>

<p>2，BITS.dll
</p>

<p>这是榕哥的作品，也是DLL后门，和SvchostDLL.dll原理基本一样，不过这里使用的是上边介绍的第四种方法，即“修改现有组里的现有服务，把它的ServiceDll指向自己的DLL后门”。换句话说，该后门修改现有的某一个服务，把其原有服务的DLL指向自己（也就是BITS.dll），这样就达到了自动加载的目的；其次，该后门没有自己的Loader，而是使用系统自带的Rundll32.exe来加载。我们还是用Windows 进程管理2.5来查看，从图7中，我们可以看到bits.dll已经插入到Svchost进程当中。
</p>

<p>好，现在我们来看看具体的清除方法，由于该后门是修改现有服务，而我们并不知道具体是修改了哪个服务，所以，在注册表中搜索bits.dll，最后在HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesRasAuto下搜索到了bits.dll，查看Parameters子键下的ServiceDll，其键值为C:WINNTsystem32bits.dll（如图8）。原来，该后门把RasAuto服务原来的DLL文件替换为bits.dll了，这样来实现自动加载。知道了原因就好办了，现在我们把ServiceDll的键值修改为RasAuto服务原有的DLL文件，即%SystemRoot%System32rasauto.dll，退出，重启。之后删除WINNTsystem32目录下的bits.dll即可。
</p>

<p>3，NOIR--QUEEN
</p>

<p>NOIR--QUEEN(守护者)是一个DLL后门&木马程序，服务端以DLL文件的形式插入到系统的Lsass.exe进程里，由于Lsass.exe是系统的关键进程，所以不能终止。在来介绍清除方法之前，我先介绍一下Lsass.exe进程：
</p>

<p>这是一个本地的安全授权服务，并且它会为使用Winlogon服务的授权用户生成一个进程，如果授权是成功的，Lsass就会产生用户的进入令牌，令牌使用启动初始的Shell。其他的由用户初始化的进程会继承这个令牌。
</p>

<p>从上边的介绍我们就可以看出Lsass对系统的重要性，那具体怎么清除呢？请看下文。
</p>

<p>后门在安装成功后，会在服务中添加一个名为QoSserver的服务，并把QoSserver.dll后门文件插入到Lsass进程当中，使其可以隐藏进程并自动启动（如图9）。现在我们打开注册表，来到HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesQoSserver，直接删除QoSserver键，然后重启。重启之后，我们在来到服务列表中，会看到QoSserver服务还在，但没有启动，类别是自动，我们把他修改为“已禁用”；然后往上看，会发现一个服务名为AppCPI的服务，其可执行程序指向QoSserver.exe（原因后边我会说到），具体如图11所示。我们再次打开注册表，来到HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesAppCPI，删除AppCPI键，重启，再删除QoSserver，最后删除WINNTsystem32目录下的后门文件。
</p>

<p>本人和这个后门“搏斗”了3个多小时，重启N次。原因在于即使删除了QoSserver服务，后门还是在运行，而且服务列表中的QoSserver服务又“死灰复燃”。后来才知道原因：在我删除了QoSserver服务并重启之后，插入到Lsass进程当中的QoSserver.dll文件又恢复了QoSserver服务，并且生成了另外一个服务，即AppCPI，所以我们必须在到注册表中删除AppCPI服务才算是把该后门清除。由此可以看出，现在的后门的保护措施，真是一环扣环。
</p>

<p>注意：在删除QoSserver服务并重启之后，恢复的QoSserver的启动类别要修改为“已禁用”，否则即便删除了AppCPI服务，QoSserver服务又运行了。
</p>

<p>三，DLL的防范
</p>

<p>看了上边的例子，我想大家对清除DLL后门的方法有了一定的了解，但在现实中，DLL后门并不会使用默认的文件名，所以你也就不能肯定是否中了DLL后门。对于DLL后门，system32目录下是个好地方，大多数后门也是如此，所以这里要非常注意。下面我来具体介绍一下怎么发现DLL后门，希望对大家有所帮助。
</p>

<p>1，安装好系统和所有的应用程序之后，备份system32目录下的EXE和DLL文件：打开CMD，来到WINNTsystem32目录下，执行：dir *.exe>exe.txt & dir *.dll>dll.txt，这样，就会把所有的EXE和DLL文件备份到exe.txt和dll.txt文件中；日后，如发现异常，可以使用相同的命令再次备份EXE和DLL文件(这里我们假设是exe0.txt和dll0.txt)，并使用：fc exe.txt exe0.txt>exedll.txt & fc dll.txt dll0.txt>exedll.txt，其意思为使用FC命令比较两次的EXE文件和DLL文件，并将比较结果保存到exedll.txt文件中。通过这种方法，我们就可以发现多出来的EXE和DLL文件，并通过文件大小，创建时间来判断是否是DLL后门。
</p>

<p>2，使用内存/模块工具来查看进程调用的DLL文件，比如Windows优化大师中的Windows 进程管理 2.5。这样，可以发现进程到底调用了什么DLL文件，在结合上边用FC命令比较出来的结果，又能进一步来确定是否中了DLL后门。如果没有优化大师，可以使用TaskList，这个小工具也可以显示进程调用的DLL文件，而且还有源代码，方便修改。
</p>

<p>3，普通后门连接需要打开特定的端口，DLL后门也不例外，不管它怎么隐藏，连接的时候都需要打开端口。我们可以用netstat –an来查看所有TCP/UDP端口的连接，以发现非法连接。大家平时要对自己打开的端口心中有数，并对netstat –an中的state属性有所了解。当然，也可以使用Fport来显示端口对应的进程，这样，系统有什么不明的连接和端口，都可以尽收眼底。
</p>

<p>4，定期检查系统自动加载的地方，比如：注册表，Winstart.bat，Autoexec.bat，win.ini，system.ini，wininit.ini，Autorun.inf，Config.sys等。其次是对服务进行管理，对系统默认的服务要有所了解，在发现有问题的服务时，可以使用Windows 2000 Server Resource Kit中的SC来删除。以上这些地方都可以用来加载DLL后门的Loader，如果我们把DLL后门Loader删除了，试问？DLL后门还怎么运行？！
</p>

<p>通过使用上边的方法，我想大多数DLL后门都可以“现形”，如果我们平时多做一些备份，那对查找DLL后门会启到事半功倍的效果
</p>



<p style='float:right;'>本页共61段，7264个字符，16233 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
