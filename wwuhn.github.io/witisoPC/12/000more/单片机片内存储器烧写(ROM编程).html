<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>单片机片内存储器烧写(ROM编程)</h3>

<p>说通俗一点，也就是把程序保存到一种特殊的存储器中，这种存储器不同于普通硬盘、也不同于内存，所以也就需要特殊的保存方式，也就是烧写方式。
</p>

<p>单片机应用系统由硬件和软件组成，软件的载体是硬件的程序存储器，程序存储器采用只读存储器，这种存储器在电源关闭后，仍能保存程序，在系统上电后，CPU可取出这些指令重新执行。只读存储器(Read Only Memory,ROM)中的信息一旦写入，就不能随意更改，特别是不能在程序运行过程中写入新的内容，故称只读存储器。向ROM中写入信息称为ROM编程。根据编程方式不同可分为：
</p>

<p>1 掩模ROM
</p>

<p>在制造过程中编程，是以掩模工艺实现的，因此称为掩模ROM。这种芯片存储结构简单，集成度高，但是由于掩模工艺成本较高，只适合于大批量生产。
</p>

<p>2 可编程ROM(PROM).
</p>

<p>芯片出厂时没有任何程序信息，用独立的编程器写入。但是PROM只能写一次，写入内容后，就不能再修改。
</p>

<p>3 EPROM
</p>

<p>用紫外线擦除，用电信号编程。在芯片外壳的中间位置有一个圆形窗口，对该窗口照射紫外线就可擦除原有的信息，使用编程器可将调试完毕的程序写入。
</p>

<p>4 E2PROM(EEPROM)
</p>

<p>用电信号擦除，用电信号编程。对E2PROM的读写操作与RAM存储器几乎没什么差别，只是写入速度慢一些，但断电后仍能保存信息。
</p>

<p>5 Flash ROM
</p>

<p>闪速存储器(简称闪存)，是在EPROM和E2PROM的基础上发展起来的一种电擦除型只读存储器。特点是可快速在线修改其存储单元中的数据，改写次数达一万次(ROM都有改写次数)，读写速度快，存取时间可达70ns，而成本比E2PROM低得多，因此正逐步取代E2PROM。
</p>

<p><h4>单片机编程器</h4>
</p>

<p>单片机编程器(烧写器、烧录器)是用来将程序代码写入存储器芯片或者单片机内部的工具。编程器主要修改只读存储器中的程序，编程器通常与计算机连接，再配合编程软件使用。一个典型的编程器有集成电路插座(也有下载编程器，不用取下芯片，涉及ISP、ICP)，通过拨动手柄可以将置于其中的集成电路芯片锁紧或松开。编程时锁紧以保证接触好，编程完毕松开，可以更换下一片芯片。
</p>

<p>当芯片是双列直插形式时，直接插在座子上就可以烧写了，但是如果遇到各种封装形式的芯片，又如何烧写呢?一种方法是使用适配器。
</p>

<p><h4>下载器</h4>
</p>

<p>下载器(下载线)是将编译好的机器码写进单片机的工具。程序经过编译生成目标代码，然后通过下载软件和下载器下载到单片机的ROM或者Flash中。下载器主要来控制编程时序等。
</p>

<p><h4>仿真器(调试器)</h4>
</p>

<p>仿真器(调试器)指以调试单片机软件为目的而专门设计制作的一套专用的硬件装置。单片机在体系结构上与PC机是完全相同的，也包括中央处理器，输入输出接口，存储器等基本单元，因而与PC机等设备的软件结构也是类似的。因为单片机在软件开发的过程中需要对软件进行调试，观察其中间结果，排除软件中存在的问题。但是由于单片机的应用场合问题，其不具备标准的输入输出装置，受存储空间限制，也难以容纳用于调试程序的专用软件，因此要对单片机软件进行调试，就必须使用单片机仿真器。单片机仿真器具有基本的输入输出装置，具备支持程序调试的软件，使得单片机开发人员可以通过单片机仿真器输入和修改程序，观察程序运行结果与中间值，同时对与单片机配套的硬件进行检测与观察，可以大大提高单片机的编程效率和效果。(许多仿真器具有下载器的功能)
</p>

<p><h4>片内Flash存储器的编程器
</p>

<p></h4>
</p>

<p>Flash存储器是一种电擦除型只读存储器。它的主要特点是在不加电的情况下能长期保持存储的信息，又可快速在线修改其存储单元中的数据，其在线改写功能使单片机的程序改写和固化过程更加简便。目前很多单片机都用Flash作为片内程序存储器。当片内的Flash存储器满足要求时，不必扩展外部程序存储器。
</p>

<p>AT89S51单片机片内4KB的Flash存储器的特点：
</p>

<p>可擦写寿命10，000次；
</p>

<p>数据保存时间10年；
</p>

<p>最大读取时间150ns，页编程时间10ns；
</p>

<p>具有3级加密算法，使得AT89S系列单片机的解密变得不可能，程序的加密性大大加强；
</p>

<p>AT89S51出厂时，Flash存储器处于全部空白状态(各单元均为FFH)，可直接进行编程。若不全为空白状态(单元中有不是FFH的)，应首先将芯片擦除后，方可写入程序。(某些单片机出厂前会固化在ROM中一段Bootloader代码，其作用就是在启动操作系统之前进行初始化并引导系统，并能把我们下载在存储器中的程序加载到RAM中运行然后把控制权交还给系统。就好比PC上的BIOS。ROM编程跟Boot loader没有直接关系)
</p>

<p>片内Flash存储器有低电压编程(Vpp=5V)和高电压编程(Vpp=12V)两类芯片。低电压编程可用于在线编程，高电压编程与一般常用的EPROM编程器兼容。在AT89S51芯片的封装面上标有低电压编程还是高电压编程的编程标志。不同的单片机的烧写电压，要视数据手册来定。
</p>

<p>应用程序在PC中与在线仿真器以及用户目标板一起调试通过后，PC中调试完毕的程序代码文件(.HEX目标文件)，必须写入到AT89S51片内的Flash存储器中。目前常用的编程方法主要有两种：一种是使用通用编程器编程，另一种是使用下载型编程器进行编程。
</p>

<p><h4>通用编程器</h4>
</p>

<p>通用编程器即不同的器件(比如不同的公司生产，不同架构)能普遍使用的编程器，它是编程器的功能分类下的一个子类，与之相对的是专用编程器。在硬件上,通用编程器的管脚驱动采用具有各种功能的通用结构，只需更新软件就能支持新的器件，具有很好的灵活性，满足目前和未来的器件需要。通常通用编程器锁紧座的每一个管脚可以用作时钟信号、数据总线、地址总线、控制总线、地线、电源线、VCCQ电压、VPP编程电压、管脚接触不良测量专用总线等等。驱动电压可以从1.8V-25.0V，起码分256级可调。
</p>

<p><h4>下载型编程器</h4>
</p>

<p>常见的下载型编程器
</p>

<p>ISPro下载型编程器、ISP编程器、ICP编程器、ISP-ICP编程器…
</p>

<p><h4>几种烧写方式
</p>

<p></h4>
</p>

<p>ICP(In Circuit Programing):在电路编程(单片机通电即可写入程序，包括bootloader)
</p>

<p>ISP(In System Programing):在系统编程(单片机通电加上晶振，有bootloader引导的情况下，即可写入应用程序)
</p>

<p>IAP(In Application Programing):在应用编程(单片机在正常运行的程序中，内部程序对单片机局部重写数据)
</p>

<p>ICP、ISP、IAP详细介绍
</p>

<p>ISP是指可以在板级上进行编程，而不用把芯片拆下来放到烧写器中，即不脱离系统，所以称作“在系统编程”，它是对整个程序的擦除和写入，通过单片机专用的串行编程接口对单片机内部的Flash存储器进行编程。即使芯片焊接在电路板上，只要留出和上位机接口的串行口就能进行烧写。(芯片一般固化了用来ISP升级的boot程序)
</p>

<p>IAP同样是在板级上进行编程，MCU获取新代码并对程序的某部分重新编程，即可用程序来改变程序，修改程序的一部分达到升级、消除bug的目的，而不影响系统的其它部分，烧写过程中程序可以继续运行，另外接口程序是自已写的，这样可以进行远程升级而不影响应用。IAP的实现更加灵活,通常可利用单片机的串行口接到计算机的RS232口，通过专门设计的固件程序来编程内部存储器。(通常自己编写一个bootloader程序) (注: 有时候, ISP/IAP的分别并不是那么清楚!)
</p>

<p>ICP在电路编程，ICP (In-circuit programmer)，在电路编程方法允许使用商业编程器来实现编程和擦除功能，而无需将微控制器从系统中移出，可完全由微控器硬件完成，不需要外部引导器。(百度)
</p>

<p>ISP、IAP应用场合
</p>

<p>1、ISP 程序升级需要到现场解决,不过好一点的是不必拆机器了。
</p>

<p>2、IAP 如果有网管系统的话,用网管下载一切搞定,人不用跑来跑去。
</p>

<p>在线编程目前有两种实现方法：在系统编程(ISP)和在应用编程(IAP)。ISP一般是通过单片机专用的串行编程接口对单片机内部的Flash存储器进行编程,而IAP技术是从结构上将Flash存储器映射为两个存储体,当运行一个存储体上的用户程序时,可对另一个存储体重新编程,之后将控制从一个存储体转向另一个。ISP的实现一般需要很少的外部电路辅助实现,而IAP的实现更加灵活,通常可利用单片机的串行口接到计算机的RS232口,通过专门设计的固件程序来编程内部存储器。 ISP和IAP很相似，都是不需要把芯片从板子上拔出来，就达到了用PC-MCU的编程接口(JTAG、串口、双绞线、SPI等)搞定新版本的升级的目的。MCU内部都是首先执行一段独立的Boot代码(这段Boot代码一般是出厂预置，或使用编程器烧录的，通常只有1k或4k，SST通常是占用一块独立的Block，Philips通常是让BootROM地址与其他Flash重叠，以达到隐藏的效果)，Boot负责控制擦除程序存储器及给程序存储器编程的代码(或是处理器外部提供的执行代码)，然后通过某种与PC计算机的通信方式(如，ether网口)，将用户指定的某个在PC上编译完成的MCU可运行的二进制代码文件编程入MCU内的程序存储器。
</p>

<p>IAP的实现
</p>

<p>通常在用户需要实现IAP功能时，即用户程序运行中作自身的更新操作，需要在设计固件程序时编写两个项目代码，第一个项目程序不执行正常的功能操作，而只是通过某种通信管道(如USB、USART)接收程序或数据，执行对第二部分代码的更新;第二个项目代码才是真正的功能代码。这两部分项目代码都同时烧录在User Flash中，当芯片上电后，首先是第一个项目代码开始运行，它作如下操作：
</p>

<p>1)检查是否需要对第二部分代码进行更新
</p>

<p>2)如果不需要更新则转到4)
</p>

<p>3)执行更新操作
</p>

<p>4)跳转到第二部分代码执行
</p>

<p>第一部分代码必须通过其它手段，如JTAG或ISP烧入;第二部分代码可以使用第一部分代码IAP功能烧入，也可以和第一部分代码一道烧入，以后需要程序更新是再通过第一部分IAP代码更新。
</p>

<p>对于STM32来说，因为它的中断向量表位于程序存储器的最低地址区，为了使第一部分代码能够正确地响应中断，通常会安排第一部分代码处于Flash的开始区域，而第二部分代码紧随其后。
</p>

<p>在第二部分代码开始执行时，首先需要把CPU的中断向量表映像到自己的向量表，然后再执行其他的操作。
</p>

<p>ISP与ICP的差别
</p>

<p>For ISP
</p>

<p>(1) MCU必须处于可执行程序的状态 (除了上电, 还要接XTAL), 且必须预烧ISP-code在LDROM里面
</p>

<p>(2) 烧录范围只限于APROM, DataFlash或CONFIG (但对使用者来说, 应经够了!)
</p>

<p>(3) chip在LOCK的状态下, 仍然可以只更新某一区块 (APROM, DataFlash或CONFIG)
</p>

<p>(4) 因为烧录的动作取决于ISP-code的写法, 所以给系统设计者的弹性较大
</p>

<p>For ICP
</p>

<p>(1) MCU只要处于上电状态即可, 不必预烧任何code在MCU里面
</p>

<p>(2) 烧录范围涵盖整颗MCU, 包括 APROM, DataFlash, CONFIG, LDROM 和 ROMMAP
</p>

<p>(3) chip在LOCK的状态下, 无法只更新某一区块, 只能在erase-ALL之后, 更新某一区块, 再逐一烧回其它区块(因为ICP的本质就是走串行接口的Writer Mode, chip被LOCK之后, 除了erase-ALL, 所有烧录动作皆会被禁止)
</p>

<p>(4) 因为烧录纯粹是ICP硬件的行为, MCU无法自己更新自己, 所以给系统设计者的弹性较小(例如: 无法藉由ICP去实现IAP的功能)
</p>

<p>ISP与ICP的使用场合
</p>

<p>依这两者的特性, 配合客户的系统需求, 而后才建议客户使用ISP或ICP.
</p>

<p>注:上述差别的第(3)点和第(4)点, 可能是ICP带给使用者的最大限制. 站在使用者的观点, 若ISP与ICP只能择一的话, ISP会是必要的选择。
</p>

<p>ISP、IAP、ICP与传统烧写方式的区别
</p>

<p>1)在开发阶段
</p>

<p>改code时, 不再需要将MCU从板子上拔起来, 拿到烧录器上烧, 然后再装回去. 可以直接利用ISP/ICP Programmer做板上烧录, 为开发者提供了极大的便利性.
</p>

<p>2)在量产阶段
</p>

<p>客户可以采用”先焊到板子上再烧code”的方式, 将烧code的动作安排在生产线的某一站.
</p>

<p>那么传统的方式 (先将code烧好再焊到板子上)有什么缺点?
</p>

<p>传统的方式是这样的: 拆封–>从tray盘取出chip–>烧录–>把chip放回tray盘.
</p>

<p>这样的流程比起上面建议的方式: 增加了烧录时间, 容易造成QFP包装的chip弯脚, 或忘了烧code即放回tray盘.
</p>

<p>3)在成品阶段
</p>

<p>已组装好的成品若要改code, 可以透过预留的接口, 利用ISP或ICP, 更新MCU, 不需要拆机.
</p>



<p style='float:right;'>本页共82段，5378个字符，13358 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
