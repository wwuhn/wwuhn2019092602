<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 
<title>cpu和主存</title>

 <style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"mv boli","宋体";
width:75.29%;
line-height:1.4em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:5px;
margin-bottom:-15px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}
</style>
</head>

<body>
<div class="container">
<a href="http://baike.baidu.com/view/2089.htm">cpu</a>&nbsp;<a href="http://baike.baidu.com/view/1372797.htm">memory</a>
<h4>存储程序和自动执行程序是计算机工作的基本原理</h4>
<p>S1:存储程序－通过输入设备，把程序载入到存储器中临时存储起来；</p>
<p>S2:取得指令－控制器从存储器中放置程序的位置拿出一条 程序指令；</p>
<p>S3:解析指令－控制器对拿到的程序指令进行分析和解释，确定指令的含义和具体工作任务，然后产生与该任务对应的控制信息，发送给相应部件。</p>
<p>譬如，如果任务是做两个数的加法，则 发送控制信息指挥运算器从存储器中取出参与运算的两个数，进行加法运算；</p>

<p>S4:执行指令－各个部件收到控制命令后，执行对应的任务。</p>
<p>譬如，运算器收到加法控制命令和参与运算的两个数，就执行加法运算，运算产生的结果数据传送到存储器中临时保存起来。</p>
<p>到这里只是执行完成了程序的一条指令，接下来，控制器按顺序取得下一条程序指令，解析指令，然后各部件执行指令...如此循环往复持续不断，直到程序结束。</p>
<h4>控制器</h4>
<p>1 指令寄存器IR(Instruction Register)</p>
<p>2 程序计数器PC(Program Counter)</p>
<p>3 操作控制器OC(Operation Controler)  </p>
<p>指令寄存器的本质是存储部件，寄存器就是一个临时存储介质。计算机将当前执行或者即将执行的指令存储在该寄存器中；</p>
<p>程序计数器也称为指令计数器，是用来保存下一步将要执行指令的位置，所以通过该寄存器保存的地址就可以方便地将一步要执行的指令从内存中取出，放到指令寄存器中；</p>
<p>操作控制寄存器负责将指令进行译码，产生相应的控制信号，控制其他部件有序地运行。因为计算机只能看懂&quot;0&quot;,&quot;1&quot;组成的语言，需要将指令转换为机器语言，而这个寄存器就要实现该功能；</p>
<h4>运算器</h4>
<p>1 算术逻辑单元</p>
<p>2 累加器</p>
<p>3 状态寄存器</p>
<p>4 通用寄存器  </p>
<p>&nbsp;</p>
<p>CPU是如何执行程序的</p>
<p><img src="CPU是如何执行程序的.jpg" width="100%" /></p>
<p>cpu是如何进行计算工作的</p>
<p><img src="cpu是如何进行计算工作的.jpg" width="100%"  />

<p>访问存储器</p>
<p>机器语言可以被看作一种约定的形式，用处理器和寄存器来操控内存。</p>
<p>
为了读出程序、处理数据等，必须要在CPU与内存之间进行数据的传送。数据是利用称为数据总线（data bus）的传输途径进行交换的。所谓总线(bus)，就是计算机主板上的某种传输线路。总线的宽度（即传输线的条数），会因CPU而各异。比如，对于32位总线而言，每次可以交换32位的数据。但需要注意的是，总线位数并不是CPU的位数，而是指传输数据时的位数。例如，英特尔公司的奔腾系列为32位的CPU，其数据总线的宽度为64位。总线是与从CPU芯片里面引出来的，一根一根针（pin）脚相对应的。如果能对照CPU芯片或计算机主板的实物，找到称为总线的传输线路，对总线的概念，就会有感觉了。</p>
<p>
此外，为了从内在读出数据，或者将数据写入内存，就必须要指定读出的位置和写入的位置。因此，内存中的每个字节（Byte）都被分配了相应的编号（当然不一定都要以字节为单位，也有采用别的单位进行编号的），这种编号就称为地址（address）。当要访问内存时，就需要从CPU传送出指定地址的电信号。这种信号也是通过总线进行传送的，但它与传送数据所用的总线（数据总线）不同，是由地址总线的位数所决定的。</p>
<p>
比如，若地址总线只有16条（即16位总线），其所能存取访问的地址是，从0000 0000 0000 0000地址到1111 1111 1111 1111地址为止，只有65636个单元。现在市场上的奔腾系列CPU，其地址总线有32根。它可以直接访问的内在单元为232＝4GB（约40亿个字节）。
<p><img src="数据总线和地址总线.jpg" width="100%"  />
<p>
<table width="100%" border="1">
  <tr>
    <td width="9%">层次</td>
    <td width="12%">语言</td>
    <td width="22%">解释器或翻译器</td>
    <td width="21%">用语言写的程序</td>
    <td width="42%">编译或翻译后的程序</td>
  </tr>
  <tr>
    <td>高级语言</td>
    <td>a</td>
    <td>用b写</td>
    <td>用a写</td>
    <td>可以在n-1层的虚拟机上执行</td>
  </tr>
  <tr>
    <td>n-1</td>
    <td>b</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>操作系统</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>...</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>汇编语言</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>机器语言</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table></p>
<p>
<p>CPU内寄存器的位数一般等于CPU的位数</p>
<p>计算机基于固定的硬件平台，能够执行固定的指令集。同时，这些指令能够被当成构件模块，组成任意的程序。</p>
<p>PC(程序计数器)芯片的输出端被连接到ROM芯片的地址输入端.</p>
<p>CPU和操作系统的位数</p>
<p>
  常常使用32位或16位（bit）这样的字眼儿，去表示CPU的种类。比如，英特尔公司的奔腾系列CPU，是32位。这个位数，其实是指算术逻辑电路一次所能计算的数据量。在奔腾等系列的CPU中，可以把所有通用器都用于计算，也可以只使用其中的一部分。例如，EAX寄存器的长度为32位，可将其低端的16位，称作AX寄存器，也可以独立加以应用，如果计算的数值比较小的话，就可以使用AX寄存器与BX寄存器。其加法运算的程序指令，则为：</p>
<p>
  ADD AX，BX</p>
<p>
  为什么要这样做呢？主要理由，是为了确保CPU的“互换性”或“兼容性”。即使开发出新的（位数更多的）CPU，如果不能确保过去编制的程序，仍能原封不动地在新CPU上运行，那么新CPU就没有存在的意义了。要把迄今所编制的程序，只因出现了新型CPU就全部修改一遍，无论如何也是很不现实的事情。</p>
<p>
  比如，采用16位的CPU（或16位指令），也能计算32位的数据。只需将其分成高端16位与低端16位，分开计算2次，就可以了。但量，若用32位的CPU，使用32位的指令，只需计算一次就行了。</p>
<p>
  由于操作系统软件，也是由各种程序组成的，也有32位与16位的区分。过去老的16位操作系统（如windows3.1等），也可以用在32位的CPU上，只是不能充分发挥新32位硬件的优越性能而已。</p>
<p>
<h3>存储芯片的片选 </h3>
<p><a href="http://baike.baidu.com/view/2089.htm">CPU</a>要实现对<a href="http://baike.baidu.com/view/1223079.htm">存储单元</a>的访问，首先要选择<a href="http://baike.baidu.com/view/6546463.htm">存储芯片</a>，即进行片选；然后再从选中的芯片中依地址码选择出相应的存储单元，以进行数据的存取，这称为字选。片内的字选是由CPU送出的N条低位<a href="http://baike.baidu.com/view/706909.htm">地址线</a>完成的，地址线直接接到所有<a href="http://baike.baidu.com/view/6546463.htm">存储芯片</a>的地址输入端，而存储芯片的<a href="http://baike.baidu.com/view/1346927.htm">片选信号</a>则大多是通过高位地址译码后产生的。 </p><img border="0" width="220" height="176" src="table no_clip_image001_0001.jpg" alt="构造图" />
<p>
  线选法： </p>
<p>
  线选法就是用除片内寻址外的高位<a href="http://baike.baidu.com/view/706909.htm">地址线</a>直接分别接至各个<a href="http://baike.baidu.com/view/6546463.htm">存储芯片</a>的<a href="http://baike.baidu.com/view/2073349.htm">片选</a>端，当某地址线信息为0时，就选中与之对应的存储芯片。这些<a href="http://baike.baidu.com/view/2073349.htm">片选</a><a href="http://baike.baidu.com/view/706909.htm">地址线</a>每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片。线选法不能充分利用系统的<a href="http://baike.baidu.com/view/87682.htm">存储</a>器空间，把<a href="http://baike.baidu.com/view/1507129.htm">地址空间</a>分成了相互隔离的区域，给编程带来了一定困难 </p>
<p>
  全译码法： </p>
<p>
  全<a href="http://baike.baidu.com/view/189742.htm">译码</a>法将除片内<a href="http://baike.baidu.com/view/1303626.htm">寻址</a>外的全部高位<a href="http://baike.baidu.com/view/706909.htm">地址线</a>都作为地址<a href="http://baike.baidu.com/view/990160.htm">译码器</a>的输入，译码器的输出作为各芯片的<a href="http://baike.baidu.com/view/1346927.htm">片选信号</a>，将它们分别接到<a href="http://baike.baidu.com/view/6546463.htm">存储芯片</a>的片选端，以实现对存储芯片的选择。全<a href="http://baike.baidu.com/view/189742.htm">译码</a>法的优点是每片芯片的地址范围是唯一确定的，而且是连续的，也便于扩展，不会产生地址重叠的<a href="http://baike.baidu.com/view/87682.htm">存储</a>区，但全译码法对译码<a href="http://baike.baidu.com/view/134362.htm">电路</a>要求较高 </p>
<p>
  部分<a href="http://baike.baidu.com/view/189742.htm">译码</a>法：所谓部分译码法即用除片内寻址外的高位地址的一部分来译码产生<a href="http://baike.baidu.com/view/1346927.htm">片选信号</a>，部分译码法会产生地址重叠。 </p>
<h3><a name="sub1372797_5_3" id="sub1372797_5_3"></a>CPU与主存储器的连接 </h3>
<p>主存与CPU之间的<a href="http://baike.baidu.com/view/3746723.htm">硬连接</a>：主存与CPU的硬连接有三组连线：<a href="http://baike.baidu.com/view/238412.htm">地址总线</a>（AB）、<a href="http://baike.baidu.com/view/712987.htm">数据总线</a>（DB）和<a href="http://baike.baidu.com/view/712982.htm">控制总线</a>（CB）。把主存看作一个黑盒子，存储器地址寄存器（MAR）和存储器数据寄存器（MDR）是主存和CPU之间的接口。MAR可以接收由<a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>（PC）的指令地址或来自<a href="http://baike.baidu.com/view/147768.htm">运算器</a>的<a href="http://baike.baidu.com/view/420846.htm">操作数</a>的地址，以确定要访问的单元。MDR是向主存写入数据或从主存读出数据的缓冲部件。MAR和MDR从功能上看属于主存，但通常放在CPU内。 </p><img border="0" width="220" height="220" src="table no_clip_image002_0000.jpg" alt="模拟图" /><img src="1.jpg" />
<img src="2.gif" />
 

<p>
  CPU对主存的基本操作：CPU对主存进行读写操作时，首先CPU在地址总线上给出地址信号，然后发出相应的读写<a href="http://baike.baidu.com/view/446604.htm">命令</a>，并在数据总线上交换信息。读写基本操作如下： </p>
<p>
  读：读操作是指从CPU送来的地址所指定的<a href="http://baike.baidu.com/view/1223079.htm">存储单元</a>中取出信息，再送给CPU，其操作过程如下： </p>
<p>
  地址——&gt;MAR——ABCPU将地址信号送至地址总线 </p>
<h3><a name="sub1372797_5_4" id="sub1372797_5_4"></a>ReadCPU发读命令 </h3>
<p>WaitForMFC等待<a href="http://baike.baidu.com/view/87682.htm">存储</a>器工作完成信号 </p>
<p>
  M(MAR)——&gt;DB——&gt;MDR读出信息经数据总线至CPU </p>
<p>
  写：写操作是指将要写入的信息存入CPU所指定的<a href="http://baike.baidu.com/view/87682.htm">存储</a>单元中，其操作过程是： </p>
<p>
  地址——&gt;MAR——&gt;ABCPU将地址信号送至地址总线 </p>
<p>
  数据——&gt;MDR——&gt;DBCPU将要写入的数据送至数据总线 </p>
<h3><a name="sub1372797_5_5" id="sub1372797_5_5"></a>WriteCPU发写命令 </h3>
<p>WaitForMFC等待存储器工作完成信号 </p>
<p>
  CPU与主存之间的速度匹配：同步<a href="http://baike.baidu.com/view/87682.htm">存储</a>器读取和异步存储器读取。 </p>
<p>
  异步存储器读取：CPU和主存间没有统一的时钟，由主存工作完成信号（MFC）通知CPU“主存工作已完成” </p>
<p>
  同步存储器读取：CPU和主存采用统一时钟，同步工作，因为主存速度较慢，所以CPU与之配合必须放慢速度，在这种存储器中，不需要主存工作完成信号。</p>
  
  
  
  



  <p>中央处理器  </p>
<p>
    中央<a href="http://baike.baidu.com/view/50152.htm">处理器</a>（英文Central <a href="http://baike.baidu.com/view/1425612.htm">Processing</a> <a href="http://baike.baidu.com/view/1172818.htm">Unit</a>，CPU）是一台<a href="http://baike.baidu.com/view/3314.htm">计算机</a>的运算核心和控制核心。CPU、<a href="http://baike.baidu.com/view/2397718.htm">内部存储器</a>和<a href="http://baike.baidu.com/view/700406.htm">输入</a>/<a href="http://baike.baidu.com/view/700402.htm">输出</a>设备是<a href="http://baike.baidu.com/view/6373.htm">电子计算机</a>三大核心部件。其功能主要是解释<a href="http://baike.baidu.com/view/786118.htm">计算机指令</a>以及处理计算机<a href="http://baike.baidu.com/view/37.htm">软件</a>中的<a href="http://baike.baidu.com/view/38752.htm">数据</a>。CPU由<a href="http://baike.baidu.com/view/147768.htm">运算器</a>、<a href="http://baike.baidu.com/view/122229.htm">控制器</a>和<a href="http://baike.baidu.com/view/6159.htm">寄存器</a>及实现它们之间联系的数据、控制及状态的<a href="http://baike.baidu.com/view/1389.htm">总线</a>构成。差不多所有的CPU的运作原理可分为四个阶段：<a href="http://baike.baidu.com/view/2290232.htm">提取</a>（Fetch）、<a href="http://baike.baidu.com/view/657399.htm">解码</a>（Decode）、<a href="http://baike.baidu.com/view/278995.htm">执行</a>（Execute）和写回（Writeback）。 CPU从<a href="http://baike.baidu.com/view/87697.htm">存储器</a>或<a href="http://baike.baidu.com/view/496990.htm">高速缓冲存储器</a>中取出指令，放入<a href="http://baike.baidu.com/view/178142.htm">指令寄存器</a>，并对指令<a href="http://baike.baidu.com/view/189742.htm">译码</a>，并执行指令。所谓的<a href="http://baike.baidu.com/view/3314.htm">计算机</a>的可编程性主要是指对CPU的<a href="http://baike.baidu.com/view/3281.htm">编程</a>。 </p>
  <p>目录  </p>
<p>
      <a name="STAT_ONCLICK_UNSUBMIT_CATALOG" id="STAT_ONCLICK_UNSUBMIT_CATALOG"></a><a href="#1">历史 </a>   </p>
<p>
      <a href="#2">CPU的功能 </a>   </p>
<p>
      <a href="#2_1">1.  指令顺序控制 </a>   </p>
<p>
      <a href="#2_2">2.  操作控制 </a>   </p>
<p>
      <a href="#2_3">3.  时间控制 </a>   </p>
<p>
      <a href="#2_4">4.  数据加工 </a>   </p>
<p>
      <a href="#2_5">提取 </a>   </p>
<p>
      <a href="#2_6">解码 </a>   </p>
<p>
      <a href="#2_7">执行 </a>   </p>
<p>
      <a href="#2_8">写回 </a>   </p>
<p>
      <a href="#3">基本结构 </a>   </p>
<p>
      <a href="#3_1">运算逻辑部件 </a>   </p>
<p>
      <a href="#3_2">寄存器部件 </a>   </p>
<p>
      <a href="#3_3">控制部件 </a>   </p>
<p>
      <a href="#4">发展历史 </a>   </p>
<p>
      <a href="#5">性能指标 </a>   </p>
<p>
      <a href="#5_1">主频 </a>   </p>
<p>
      <a href="#5_2">外频 </a>   </p>
<p>
      <a href="#5_3">前端总线（FSB）频率 </a>   </p>
<p>
      <a href="#5_4">倍频系数 </a>   </p>
<p>
      <a href="#5_5">缓存 </a>   </p>
<p>
      <a href="#5_6">CPU扩展指令集 </a>   </p>
<p>
      <a href="#5_7">CPU内核和I/O工作电压 </a>   </p>
<p>
      <a href="#6">技术架构 </a>   </p>
<p>
      <a href="#6_1">制造工艺 </a>   </p>
<p>
      <a href="#6_2">指令集 </a>   </p>
<p>
      <a href="#6_3">超流水线与超标量 </a>   </p>
<p>
      <a href="#6_4">封装形式 </a>   </p>
<p>
      <a href="#6_5">多线程 </a>   </p>
<p>
      <a href="#6_6">多核心 </a>   </p>
<p>
      <a href="#6_7">SMP</a>   </p>
<p>
      <a href="#6_8">NUMA技术 </a>   </p>
<p>
      <a href="#6_9">乱序执行技术 </a>   </p>
<p>
      <a href="#6_10">分枝技术 </a>   </p>
<p>
      <a href="#6_11">CPU内部的内存控制器 </a>   </p>
<p>
      <a href="#7">2012CPU性能排行 </a>   </p>
<p>
    <a href="#8">选购CPU时需要注意的参数 </a> </p>
	<img src="4.jpg" />
<img src="5.jpg" />
  <p><a name="ref_[1]_14045" id="ref_[1]_14045"></a>在现今的中央处理器出现之前，如同<a href="http://baike.baidu.com/view/22486.htm">ENIAC</a>之类的计算机在执行不同程序时，必须经过一番线路调整才能启动。由于它们的线路必须被重设才能执行不同的程序，这些机器通常称为“固定程序计算机”（fixed-program computer）。而由于中央处理器这个词指称为执行软件（计算机程序）的装置，那些最早与储存程序型计算机一同登场的装置也可以被称为中央处理器。   </p>
<p>
      <a name="1_1" id="1_1"></a><a name="sub14045_1_1" id="sub14045_1_1"></a>分立晶体管与集成电路中央处理器  </p>
<p>
      <a name="1_2" id="1_2"></a><a name="sub14045_1_2" id="sub14045_1_2"></a>微处理器  </p>
<p>
      <a name="2" id="2"></a><a name="sub14045_2" id="sub14045_2"></a>CPU的功能  </p>
<p>
    <a href="http://baike.baidu.com/view/3314.htm">计算机</a>求解问题是通过执行程序来实现的。程序是由指令构成的序列，执行程序就是按指令序列逐条执行指令。一旦把程序装入主存储器（简称主存）中，就可以由CPU自动地完成从主存取指令和执行指令的任务。   </p>
<p>
  <a href="http://baike.baidu.com/picview/14045/14045/0/1f178a82b9014a90332f4c3fa9773912b31bee1b.html"><img border="0" width="200" height="130" src="table no_clip_image001.jpg" alt="英特尔和AMD主流CPU和CPU插槽" /></a>  </p>
<p>
  <a href="http://baike.baidu.com/picview/14045/14045/0/1f178a82b9014a90332f4c3fa9773912b31bee1b.html" title="查看图片">&nbsp;&nbsp;</a>英特尔和AMD主流CPU和CPU插槽  </p>
<p>
    CPU具有以下4个方面的基本功能：   </p>
<p>
  <a name="2_1" id="2_1"></a><a name="sub14045_2_1" id="sub14045_2_1"></a>1. 指令顺序控制  </p>
<p>
    这是指控制程序中指令的执行顺序。程序中的各指令之间是有严格顺序的，必须严格按程序规定的<a href="http://baike.baidu.com/view/2120589.htm">顺序执行</a>，才能保证<a href="http://baike.baidu.com/view/3314.htm">计算机</a>工作的正确性。   </p>
<p>
  <a name="2_2" id="2_2"></a><a name="sub14045_2_2" id="sub14045_2_2"></a>2. 操作控制  </p>
<p>
    一条指令的功能往往是由<a href="http://baike.baidu.com/view/3314.htm">计算机</a>中的部件执行一序列的操作来实现的。CPU要根据指令的功能，产生相应的操作<a href="http://baike.baidu.com/view/8407048.htm">控制信号</a>，发给相应的部件，从而控制这些部件按指令的要求进行动作。   </p>
<p>
  <a name="2_3" id="2_3"></a><a name="sub14045_2_3" id="sub14045_2_3"></a>3. 时间控制  </p>
<p>
    时间控制就是对各种操作实施时间上的定时。在一条指令的执行过程中，在什么时间做什么操作均应受到严格的控制。只有这样，<a href="http://baike.baidu.com/view/3314.htm">计算机</a>才能有条不紊地自动工作。   </p>
<p>
  <a name="2_4" id="2_4"></a><a name="sub14045_2_4" id="sub14045_2_4"></a>4. 数据加工  </p>
<p>
    即对数据进行算术运算和<a href="http://baike.baidu.com/view/397415.htm">逻辑运算</a>，或进行其他的信息处理。   </p>
<p>
    CPU从<a href="http://baike.baidu.com/view/87697.htm">存储器</a>或<a href="http://baike.baidu.com/view/496990.htm">高速缓冲存储器</a>中取出指令，放入<a href="http://baike.baidu.com/view/178142.htm">指令寄存器</a>，并对指令<a href="http://baike.baidu.com/view/189742.htm">译码</a>。它把指令分解成一系列的<a href="http://baike.baidu.com/view/4694343.htm">微操作</a>，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行。   </p>
<p>
    指令是计算机规定执行操作的类型和<a href="http://baike.baidu.com/view/420846.htm">操作数</a>的基本命令。指令是由一个<a href="http://baike.baidu.com/view/60408.htm">字节</a>或者多个字节组成，其中包括<a href="http://baike.baidu.com/view/178197.htm">操作码</a>字段、一个或多个有关<a href="http://baike.baidu.com/view/420846.htm">操作数</a><a href="http://baike.baidu.com/view/494802.htm">地址</a>的字段以及一些表征机器状态的状态字以及<a href="http://baike.baidu.com/view/1184428.htm">特征码</a>。有的指令中也直接包含操作数本身。   </p>
<p>
  <a name="2_5" id="2_5"></a><a name="sub14045_2_5" id="sub14045_2_5"></a>提取  </p>
<p>
    第一阶段，提取，从<a href="http://baike.baidu.com/view/87697.htm">存储器</a>或<a href="http://baike.baidu.com/view/496990.htm">高速缓冲存储器</a>中检索指令（为<a href="http://baike.baidu.com/view/3627588.htm">数值</a>或一系列数值）。由程序<a href="http://baike.baidu.com/view/259701.htm">计数器</a>（Program  Counter）指定<a href="http://baike.baidu.com/view/87697.htm">存储器</a>的位置。(<a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>保存供识别目前程序位置的<a href="http://baike.baidu.com/view/3627588.htm">数值</a>。换言之，<a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>记录了CPU在目前程序里的踪迹。)   </p>
<p>
    提取指令之后，程序计数器根据<a href="http://baike.baidu.com/view/1188015.htm">指令长度</a>增加<a href="http://baike.baidu.com/view/87697.htm">存储器</a>单元。指令的提取必须常常从相对较慢的<a href="http://baike.baidu.com/view/87697.htm">存储器</a>寻找，因此导致CPU等候指令的送入。这个问题主要被论及在现代<a href="http://baike.baidu.com/view/50152.htm">处理器</a>的快取和管线化架构。   </p>
<p>
  <a name="2_6" id="2_6"></a><a name="sub14045_2_6" id="sub14045_2_6"></a>解码  </p>
<p>
    CPU根据<a href="http://baike.baidu.com/view/87697.htm">存储器</a>提取到的指令来决定其执行行为。在解码阶段，指令被拆解为有意义的片断。根据CPU的<a href="http://baike.baidu.com/view/1119651.htm">指令集架构</a>（ISA）定义将<a href="http://baike.baidu.com/view/3627588.htm">数值</a>解译为指令。一部分的指令数值为运算码（Opcode），其指示要进行哪些运算。其它的<a href="http://baike.baidu.com/view/3627588.htm">数值</a>通常供给指令必要的信息，诸如一个<a href="http://baike.baidu.com/view/56133.htm">加法</a>（Addition）运算的运算目标。这样的运算目标也许提供一个常<a href="http://baike.baidu.com/view/3627588.htm">数值</a>（即立即值），或是一个空间的定址值：<a href="http://baike.baidu.com/view/238434.htm">暂存器</a>或<a href="http://baike.baidu.com/view/87697.htm">存储器</a>位址，以定址模式决定。在旧的设计中，CPU里的<a href="http://baike.baidu.com/view/827908.htm">指令解码</a>部分是无法改变的硬件设备。不过在众多抽象且复杂的CPU和<a href="http://baike.baidu.com/view/1119651.htm">指令集架构</a>中，一个微程序时常用来帮助转换指令为各种形态的<a href="http://baike.baidu.com/view/5392601.htm">讯号</a>。这些微程序在已成品的CPU中往往可以重写，方便变更解码指令。   </p>
<p>
  <a name="2_7" id="2_7"></a><a name="sub14045_2_7" id="sub14045_2_7"></a>执行  </p>
<p>
    在提取和解码阶段之后，紧接着进入执行阶段。该阶段中，连接到各种能够进行所需运算的CPU部件。   </p>
<p>
    例如，要求一个<a href="http://baike.baidu.com/view/56133.htm">加法</a>运算，<a href="http://baike.baidu.com/view/492754.htm">算术逻辑单元</a>（ALU，Arithmetic  Logic Unit）将会连接到一组输入和一组输出。输入提供了要相加的<a href="http://baike.baidu.com/view/3627588.htm">数值</a>，而输出将含有总和的结果。ALU内含<a href="http://baike.baidu.com/view/134362.htm">电路</a>系统，易于输出端完成简单的普通运算和<a href="http://baike.baidu.com/view/397415.htm">逻辑运算</a>（比如<a href="http://baike.baidu.com/view/56133.htm">加法</a>和位元运算）。如果<a href="http://baike.baidu.com/view/56133.htm">加法</a>运算产生一个对该CPU处理而言过大的结果，在标志<a href="http://baike.baidu.com/view/238434.htm">暂存器</a>里可能会设置运算<a href="http://baike.baidu.com/view/98452.htm">溢出</a>（Arithmetic  Overflow）标志。   </p>
<p>
  <a name="2_8" id="2_8"></a><a name="sub14045_2_8" id="sub14045_2_8"></a>写回  </p>
<p>
    最终阶段，写回，以一定<a href="http://baike.baidu.com/view/33401.htm">格式</a>将执行阶段的结果简单的写回。运算结果经常被写进CPU内部的<a href="http://baike.baidu.com/view/238434.htm">暂存器</a>，以供随后指令快速存取。在其它案例中，运算结果可能写进速度较慢，但<a href="http://baike.baidu.com/view/334600.htm">容量</a>较大且较便宜的主<a href="http://baike.baidu.com/view/167750.htm">记忆体</a>中。某些类型的指令会操作<a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>，而不直接产生结果。这些一般称作“跳转”（Jumps），并在程式中带来循环行为、条件性执行（透过条件跳转）和函式。许多指令会改变标志<a href="http://baike.baidu.com/view/238434.htm">暂存器</a>的状态位元。这些标志可用来影响程式行为，缘由于它们时常显出各种运算结果。例如，以一个“比较”指令判断两个值大小，根据比较结果在标志<a href="http://baike.baidu.com/view/238434.htm">暂存器</a>上设置一个<a href="http://baike.baidu.com/view/3627588.htm">数值</a>。这个标志可藉由随后跳转指令来决定程式动向。在执行指令并写回结果之后，<a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>值会递增，反覆整个过程，下一个<a href="http://baike.baidu.com/view/178156.htm">指令周期</a>正常的提取下一个顺序指令。如果完成的是跳转指令，<a href="http://baike.baidu.com/view/178145.htm">程序计数器</a>将会修改成跳转到的指令位址，且程序继续正常执行。许多复杂的CPU可以一次提取多个指令、解码，并且同时执行。这个部分一般涉及“经典RISC管线”，那些实际上是在众多使用简单CPU的电子装置中快速普及（常称为微控制（Microcontrollers））。   </p>
<p>
  <a name="3" id="3"></a><a name="sub14045_3" id="sub14045_3"></a>基本结构  </p>
<p>
    CPU包括运算逻辑部件、寄存器部件和控制部件等。　   </p>
<p>
  <a name="3_1" id="3_1"></a><a name="sub14045_3_1" id="sub14045_3_1"></a>运算逻辑部件  </p>
<p>
    运算逻辑部件，可以执行定点或<a href="http://baike.baidu.com/view/924477.htm">浮点</a>算术运算操作、移位操作以及逻辑操作，也可执行<a href="http://baike.baidu.com/view/494802.htm">地址</a>运算和转换。   </p>
<p>
  <a name="3_2" id="3_2"></a><a name="sub14045_3_2" id="sub14045_3_2"></a>寄存器部件  </p>
<p>
    <a href="http://baike.baidu.com/view/6159.htm">寄存器</a>部件，包括<a href="http://baike.baidu.com/view/1418486.htm">通用寄存器</a>、专用寄存器和<a href="http://baike.baidu.com/view/4092816.htm">控制寄存器</a>。   </p>
<p>
    通用<a href="http://baike.baidu.com/view/6159.htm">寄存器</a>又可分<a href="http://baike.baidu.com/view/686808.htm">定点数</a>和<a href="http://baike.baidu.com/view/339796.htm">浮点数</a>两类，它们用来保存指令执行过程中临时存放的<a href="http://baike.baidu.com/view/1635040.htm">寄存器操作数</a>和中间（或最终）的操作结果。   </p>
<p>
    通用<a href="http://baike.baidu.com/view/6159.htm">寄存器</a>是中央<a href="http://baike.baidu.com/view/50152.htm">处理器</a>的重要组成部分，大多数指令都要访问到通用寄存器。通用寄存器的<a href="http://baike.baidu.com/view/51849.htm">宽度</a>决定<a href="http://baike.baidu.com/view/3314.htm">计算机</a>内部的<a href="http://baike.baidu.com/view/1866929.htm">数据通路</a>宽度，其<a href="http://baike.baidu.com/view/259082.htm">端口数目</a>往往可影响内部操作的<a href="http://baike.baidu.com/view/149970.htm">并行性</a>。   </p>
<p>
    专用<a href="http://baike.baidu.com/view/6159.htm">寄存器</a>是为了执行一些特殊操作所需用的寄存器。   </p>
<p>
    控制<a href="http://baike.baidu.com/view/6159.htm">寄存器</a>通常用来指示机器执行的状态，或者保持某些<a href="http://baike.baidu.com/view/159417.htm">指针</a>，有处理<a href="http://baike.baidu.com/view/5048524.htm">状态寄存器</a>、<a href="http://baike.baidu.com/view/545723.htm">地址转换</a>目录的基<a href="http://baike.baidu.com/view/178150.htm">地址寄存器</a>、特权状态寄存器、条件码寄存器、处理异常事故寄存器以及检错寄存器等。   </p>
<p>
    有的时候，中央<a href="http://baike.baidu.com/view/50152.htm">处理器</a>中还有一些<a href="http://baike.baidu.com/view/907.htm">缓存</a>，用来暂时存放一些数据指令，缓存越大，说明CPU的<a href="http://baike.baidu.com/view/148612.htm">运算速度</a>越快，目前市场上的中高端中央处理器都有2M左右的<a href="http://baike.baidu.com/view/27650.htm">二级缓存</a>，高端中央处理器有4M左右的<a href="http://baike.baidu.com/view/27650.htm">二级缓存</a>。   </p>
<p>
  <a name="3_3" id="3_3"></a><a name="sub14045_3_3" id="sub14045_3_3"></a>控制部件  </p>
<p>
    控制部件，主要是负责对指令<a href="http://baike.baidu.com/view/189742.htm">译码</a>，并且发出为完成每条指令所要执行的各个操作的控制<a href="http://baike.baidu.com/view/54338.htm">信号</a>。   </p>
<p>
    其结构有两种：一种是以微存储为核心的<a href="http://baike.baidu.com/view/854128.htm">微程序</a>控制方式；一种是以逻辑硬布线结构为主的控制方式。   </p>
<p>
    微存储中保持微码，每一个微码对应于一个最基本的<a href="http://baike.baidu.com/view/4694343.htm">微操作</a>，又称<a href="http://baike.baidu.com/view/873614.htm">微指令</a>；各条指令是由不同序列的微码组成，这种微码序列构成微程序。中央<a href="http://baike.baidu.com/view/50152.htm">处理器</a>在对指令<a href="http://baike.baidu.com/view/189742.htm">译码</a>以后，即发出一定时序的<a href="http://baike.baidu.com/view/8407048.htm">控制信号</a>，按给定序列的顺序以微<a href="http://baike.baidu.com/view/120466.htm">周期</a>为节拍执行由这些微码确定的若干个<a href="http://baike.baidu.com/view/4694343.htm">微操作</a>，即可完成某条指令的执行。   </p>
<p>
    简单指令是由（3～5）个<a href="http://baike.baidu.com/view/4694343.htm">微操作</a>组成，复杂指令则要由几十个微操作甚至几百个微操作组成。   </p>
<p>
    逻辑硬布线<a href="http://baike.baidu.com/view/122229.htm">控制器</a>则完全是由<a href="http://baike.baidu.com/view/269420.htm">随机</a>逻辑组成。指令<a href="http://baike.baidu.com/view/189742.htm">译码</a>后，控制器通过不同的逻辑门的组合，发出不同序列的控制<a href="http://baike.baidu.com/view/3039272.htm">时序信号</a>，直接去执行一条指令中的各个操作。   </p>
<p>
  <a name="4" id="4"></a><a name="sub14045_4" id="sub14045_4"></a>发展历史  </p>
<p>
    计算机的发展主要表现在其核心部件——微处理器的发展上，每当一款新型的微处理器出现时，就会带动计算机系统的其他部件的相应发展，如计算机体系结构的进一步优化，存储器存取容量的不断增大、存取速度的不断提高，外围设备的不断改进以及新设备的不断出现等。   </p>
<p>
    根据微处理器的字长和功能，可将其发展划分为以下几个阶段。   </p>
<p>
  <a name="4_1" id="4_1"></a><a name="sub14045_4_1" id="sub14045_4_1"></a>第1阶段  </p>
<p>
    第1阶段（1971——1973年）是4位和8位低档微处理器时代，通常称为第1代，其典型产品是Intel4004和Intel8008微处理器和分别由它们组成的MCS-4和MCS-8微机。基本特点是采用PMOS工艺，集成度低（4000个晶体管/片），系统结构和指令系统都比较简单，主要采用机器语言或简单的汇编语言，指令数目较少（20多条指令），基本指令周期为20~50μs，用于简单的控制场合。   </p>
<p>
    Intel在1969年为日本<a href="http://baike.baidu.com/view/3314.htm">计算机</a>制造商Busicom的一项专案，着手开发第一款微处理器，为一系列可程式化计算机研发多款晶片。最终，英特尔在1971年11月15日向全球市场推出4004微处理器，当年<a href="http://baike.baidu.com/view/756350.htm">Intel 4004</a>处理器每颗售价为200美元。4004 是英特尔第一款微处理器，为日后开发系统智能功能以及个人电脑奠定发展基础，其<a href="http://baike.baidu.com/view/30363.htm">晶体管</a>数目约为2300颗。 </p>
  <p>翌年，Intel推出8008微处理器，其运算威力是4004的两倍。Radio Electronics于1974年刊载一篇文章介绍一部采用8008的Mark-8装置，被公认是第一部家用电脑，在当时的标准来看，这部电脑在制造、维护、与运作方面都相当困难。<a href="http://baike.baidu.com/view/756352.htm">Intel 8008</a><a href="http://baike.baidu.com/view/30363.htm">晶体管</a>数目约为3500颗。   </p>
<p>
      <a name="4_2" id="4_2"></a><a name="sub14045_4_2" id="sub14045_4_2"></a>第2阶段  </p>
<p>
    第2阶段（1971——1977年）是8位中高档微处理器时代，通常称为第2代，其典型产品是Intel8080/8085、Motorola公司、Zilog公司的Z80等。它们的特点是采用NMOS工艺，集成度提高约4倍，运算速度提高约10~15倍（基本指令执行时间1~2μs），指令系统比较完善，具有典型的计算机体系结构和中断、DMA等控制功能。软件方面除了汇编语言外，还有BASIC、FORTRAN等高级语言和相应的解释程序和编译程序，在后期还出现了操作系统。   </p>
<p>
    1974年，Intel推出8080<a href="http://baike.baidu.com/view/50152.htm">处理器</a>，并作为Altair个人电脑的运算核心，Altair在《星舰奇航》电视影集中是企业号太空船的目的地。电脑迷当时可用395美元买到一组Altair的套件。它在数个月内卖出数万套，成为史上第一款下订单后制造的机种。<a href="http://baike.baidu.com/view/756353.htm">Intel 8080</a><a href="http://baike.baidu.com/view/30363.htm">晶体管</a>数目约为6千颗。   </p>
<p>
  <a name="4_3" id="4_3"></a><a name="sub14045_4_3" id="sub14045_4_3"></a>第3阶段  </p>
<p>
    第3阶段（1978——1984年）是16位微处理器时代，通常称为第3代，其典型产品是Intel公司的8086/8088，Motorola公司的M68000，Zilog公司的Z8000等微处理器。其特点是采用HMOS工艺，集成度（20000~70000晶体管/片）和运算速度（基本指令执行时间是0.5μs）都比第2代提高了一个数量级。指令系统更加丰富、完善，采用多级中断、多种寻址方式、段式存储机构、硬件乘除部件，并配置了软件系统。这一时期著名微机产品有IBM公司的个人计算机。1981年IBM公司推出的个人计算机采用8088CPU。紧接着1982年又推出了扩展型的个人计算机IBM PC/XT，它对内存进行了扩充，并增加了一个硬磁盘驱动器。   </p>
<p>
    80286（也被称为286）是英特尔首款能执行所有旧款<a href="http://baike.baidu.com/view/50152.htm">处理器</a>专属软件的处理器，这种软件相容性之后成为英特尔全系列微处理器的注册商标，在6年的销售期中，估计全球各地共安装了1500万部286个人电脑。<a href="http://baike.baidu.com/view/722710.htm">Intel 80286</a>处理器<a href="http://baike.baidu.com/view/30363.htm">晶体管</a>数目为13万4千颗。1984年，IBM公司推出了以80286处理器为核心组成的16位增强型个人计算机IBM  PC/AT。由于IBM公司在发展个人计算机时采用  了技术开放的策略，使个人计算机风靡世界。   </p>
<p>
  <a name="4_4" id="4_4"></a><a name="sub14045_4_4" id="sub14045_4_4"></a>第4阶段  </p>
<p>
    第4阶段（1985——1992年）是32位微处理器时代，又称为第4代。其典型产品是Intel公司的80386/80486，Motorola公司的M69030/68040等。其特点是采用HMOS或CMOS工艺，集成度高达100万个晶体管/片，具有32位地址线和32位数据总线。每秒钟可完成600万条指令（Million Instructions Per Second，MIPS）。微型计算机的功能已经达到甚至超过超级小型计算机，完全可以胜任多任务、多用户的作业。同期，其他一些微处理器生产厂商（如AMD、TEXAS等）也推出了80386/80486系列的芯片。 <a href="http://baike.baidu.com/view/722713.htm">Intel 80386</a>微处理器内含275,000 个<a href="http://baike.baidu.com/view/30363.htm">晶体管</a>—比当初的4004多了100倍以上，这款32位元处理器首次支持<a href="http://baike.baidu.com/view/560598.htm">多工</a>任务设计，能同时执行多个程序。Intel 80386晶体管数目约为27万5千颗。   </p>
<p>
    <a href="http://baike.baidu.com/view/756361.htm">Intel 80486</a><a href="http://baike.baidu.com/view/50152.htm">处理器</a>世代让电脑从命令列转型至点选式（point to click）的图形化操作环境，开始能以大幅加快的速度进行<a href="http://baike.baidu.com/view/3983841.htm">桌面排版</a>作业。”Intel  80486处理器率先内建数学协同处理器，由于能扮演中央处理器处理复杂数学运算，因此能加快整体运算的速度。Intel 80486<a href="http://baike.baidu.com/view/30363.htm">晶体管</a>数目为120万颗。   </p>
<p>
  <a name="4_5" id="4_5"></a><a name="sub14045_4_5" id="sub14045_4_5"></a>第5阶段  </p>
<p>
    第5阶段（1993-2005年）是奔腾（pentium）系列微处理器时代，通常称为第5代。典型产品是Intel公司的奔腾系列芯片及与之兼容的AMD的K6系列微处理器芯片。内部采用了超标量指令流水线结构，并具有相互独立的指令和数据高速缓存。随着MMX（MultiMediaeXtended）微处理器的出现，使微机的发展在网络化、多媒体化和智能化等方面跨上了更高的台阶。   </p>
<p>
    1997年推出的Pentium II<a href="http://baike.baidu.com/view/50152.htm">处理器</a>结合了Intel MMX技术，能以极高的效率处理影片、音效、以及绘图资料，首次采用Single Edge Contact (S.E.C) 匣型封装，内建了高速快取<a href="http://baike.baidu.com/view/167750.htm">记忆体</a>。这款晶片让电脑使用者撷取、编辑、以及透过<a href="http://baike.baidu.com/view/3964529.htm">网际网络</a>和亲友分享数位相片、编辑与新增文字、音乐或制作家庭电影的转场效果、使用视讯<a href="http://baike.baidu.com/view/3248.htm">电话</a>以及透过标准电话线与网际网络传送影片，Intel Pentium II处理器晶体管数目为750万颗。   </p>
<p>
    Pentium III <a href="http://baike.baidu.com/view/50152.htm">处理器</a>加入70个新指令，加入<a href="http://baike.baidu.com/view/3964529.htm">网际网络</a>串流SIMD延伸集称为MMX，能大幅提升先进影像、3D、串流音乐、影片、语音辨识等应用的性能，它能大幅提升网际网络的使用经验，让使用者能浏览逼真的线上博物馆与商店，以及下载高品质影片，Intel首次导入0.25微米技术，Intel Pentium III<a href="http://baike.baidu.com/view/30363.htm">晶体管</a>数目约为950万颗。   </p>
<p>
    2000年推出的Pentium 4<a href="http://baike.baidu.com/view/50152.htm">处理器</a>内建了4200万个<a href="http://baike.baidu.com/view/30363.htm">晶体管</a>，以及采用0.18微米的<a href="http://baike.baidu.com/view/134362.htm">电路</a>，Pentium 4初期推出版本的速度就高达1.5GHz，晶体管数目约为4200万颗，翌年8月，Pentium 4 处理理达到2 GHz的里程碑。2002年英特尔推出新款Intel  Pentium 4<a href="http://baike.baidu.com/view/50152.htm">处理器</a>内含创新的Hyper-Threading(HT）<a href="http://baike.baidu.com/view/13611.htm">超线程技术</a>。超线程技术打造出新等级的高性能桌上型电脑，能同时快速执行多项运算应用，或针对支持多重线程的软件带来更高的性能。超线程技术让电脑性能增加25%。除了为桌上型电脑使用者提供超线程技术外，英特尔也达成另一项电脑里程碑，就是推出运作频率达3.06 GHz的Pentium 4处理器，是首款每秒执行30亿个运算周期的商业<a href="http://baike.baidu.com/view/1125.htm">微处理器</a>，如此优异的性能要归功于当时业界最先进的0.13微米制程技术，翌年，内建超线程技术的Intel Pentium 4处理器频率达到3.2 GHz。   </p>
<p>
  <a name="4_6" id="4_6"></a><a name="sub14045_4_6" id="sub14045_4_6"></a>第6阶段  </p>
<p>
    第6阶段（2005年至今）是酷睿（core）系列微处理器时代，通常称为第6代。“酷睿”是一款领先节能的新型微架构，设计的出发点是提供卓然出众的性能和能效，提高每瓦特性能，也就是所谓的能效比。早期的酷睿是基于笔记本处理器的。  酷睿2：英文名称为Core 2 Duo，是是英特尔在2006年推出的新一代基于Core微架构的产品体系统称。于2006年7月27日发布。酷睿2是一个跨平台的构架体系，包括服务器版、桌面版、移动版三大领域。其中，服务器版的开发代号为Woodcrest，桌面版的开发代号为Conroe，移动版的开发代号为Merom。   </p>
<p>
    酷睿2处理器的Core微架构是Intel的以色列设计团队在Yonah微架构基础之上改进而来的新一代英特尔架构。最显著的变化在于在各个关键部分进行强化。为了提高两个核心的内部数据交换效率采取共享式二级缓存设计，2个核心共享高达4MB的二级缓存。   </p>
<p>
    SNB(<a href="http://baike.baidu.com/view/1639147.htm">Sandy Bridge</a>）是英特尔在2011年初发布的新一代<a href="http://baike.baidu.com/view/50152.htm">处理器</a>微架构，这一构架的最大意义莫过于重新定义了“<a href="http://baike.baidu.com/view/1427003.htm">整合平台</a>”的概念，与处理器“无缝融合”的“<a href="http://baike.baidu.com/view/4508758.htm">核芯显卡</a>”终结了“<a href="http://baike.baidu.com/view/9082.htm">集成显卡</a>”的时代。这一创举得益于全新的32nm制造工艺。由于Sandy Bridge 构架下的处理器采用了比之前的45nm工艺更加先进的32nm制造工艺，理论上实现了CPU功耗的进一步降低，及其<a href="http://baike.baidu.com/view/134362.htm">电路</a>尺寸和性能的显著优化，这就为将整合图形核心（核芯显卡）与CPU封装在同一块基板上创造了有利条件。此外，第二代酷睿还加入了全新的<a href="http://baike.baidu.com/view/752328.htm">高清</a>视频处理单元。视频转解码速度的高与低跟处理器是有直接关系的，由于高清视频处理单元的加入，新一代<a href="http://baike.baidu.com/view/551937.htm">酷睿处理器</a>的视频处理时间比老款处理器至少提升了30%。   </p>
<p>
    在2012年4月24日下午北京天文馆，intel正式发布了<a href="http://baike.baidu.com/view/2721676.htm">ivy bridge</a>（IVB）<a href="http://baike.baidu.com/view/50152.htm">处理器</a>。22nm Ivy  Bridge会将执行单元的数量翻一番，达到最多24个，自然会带来性能上的进一步跃进。Ivy Bridge会加入对DX11的支持的<a href="http://baike.baidu.com/view/9082.htm">集成显卡</a>。另外新加入的XHCI  USB 3.0控制器则共享其中四条通道，从而提供最多四个USB 3.0，从而支持原生USB3.0。cpu的制作采用3D晶体管技术的CPU耗电量会减少一半。   </p>
<p>
  <a name="5" id="5"></a><a name="sub14045_5" id="sub14045_5"></a>性能指标  </p>
<p>
    计算机的性能在很大程度上由CPU的性能所决定，而CPU的性能主要体现在其运行程序的速度上。影响运行速度的性能指标包括CPU的工作频率、Cache容量、指令系统和逻辑结构等参数。   </p>
<p>
  <a name="5_1" id="5_1"></a><a name="sub14045_5_1" id="sub14045_5_1"></a>主频  </p>
<p>
    主频也叫<a href="http://baike.baidu.com/view/1087.htm">时钟频率</a>，单位是兆赫（MHz）或千兆赫（GHz），用来表示CPU的运算、处理数据的速度。通常，主频越高，CPU处理数据的速度就越快。   </p>
<p>
    CPU的主频=<a href="http://baike.baidu.com/view/1377.htm">外频</a>×<a href="http://baike.baidu.com/view/820849.htm">倍频系数</a>。主频和实际的运算速度存在一定的关系，但并不是一个简单的线性关系。　所以，CPU的主频与CPU实际的运算能力是没有直接关系的，主频表示在CPU内数字<a href="http://baike.baidu.com/view/717471.htm">脉冲信号</a>震荡的速度。在Intel的<a href="http://baike.baidu.com/view/50152.htm">处理器</a>产品中，也可以看到这样的例子：1 GHz Itanium芯片能够表现得差不多跟2.66 GHz<a href="http://baike.baidu.com/view/102947.htm">至强</a>（<a href="http://baike.baidu.com/view/416484.htm">Xeon</a>）/Opteron一样快，或是1.5 GHz  Itanium 2大约跟4 GHz Xeon/Opteron一样快。CPU的运算速度还要看CPU的流水线、总线等各方面的性能指标。   </p>
<p>
  <a name="5_2" id="5_2"></a><a name="sub14045_5_2" id="sub14045_5_2"></a>外频  </p>
<p>
    <a href="http://baike.baidu.com/view/1377.htm">外频</a>是CPU的基准频率，单位是MHz。CPU的<a href="http://baike.baidu.com/view/1377.htm">外频</a>决定着整块<a href="http://baike.baidu.com/view/1143.htm">主板</a>的运行速度。通俗地说，在<a href="http://baike.baidu.com/view/1437416.htm">台式机</a>中，所说的<a href="http://baike.baidu.com/view/870.htm">超频</a>，都是超CPU的<a href="http://baike.baidu.com/view/1377.htm">外频</a>（当然一般情况下，CPU的倍频都是被锁住的）相信这点是很好理解的。但对于<a href="http://baike.baidu.com/view/31389.htm">服务器CPU</a>来讲，超频是绝对不允许的。前面说到CPU决定着主板的运行速度，两者是同步运行的，如果把服务器CPU超频了，改变了<a href="http://baike.baidu.com/view/1377.htm">外频</a>，会产生异步运行，（台式机很多主板都支持异步运行）这样会造成整个<a href="http://baike.baidu.com/view/6396042.htm">服务器系统</a>的不稳定。   </p>
<p>
    目前的绝大部分<a href="http://baike.baidu.com/view/1356068.htm">电脑系统</a>中<a href="http://baike.baidu.com/view/1377.htm">外频</a>与主板<a href="http://baike.baidu.com/view/1083.htm">前端总线</a>不是同步速度的，而外频与前端总线（FSB）频率又很容易被混为一谈。   </p>
<p>
  <a name="5_3" id="5_3"></a><a name="sub14045_5_3" id="sub14045_5_3"></a>前端总线（FSB）频率  </p>
<p>
    前端总线（FSB)是将CPU连接到北桥芯片的总线。前端总线（FSB)频率（即<a href="http://baike.baidu.com/view/30203.htm">总线频率</a>）是直接影响CPU与内存直接数据交换速度。有一条公式可以计算，即数据<a href="http://baike.baidu.com/view/10821.htm">带宽</a>=（总线频率×数据<a href="http://baike.baidu.com/view/1128.htm">位宽</a>）/8，数据传输最大带宽取决于所有同时传输的数据的宽度和传输频率。比方，现在的支持64位的至强Nocona，前端总线是800MHz，按照公式，它的数据传输最大带宽是6.4GB/秒。   </p>
<p>
    <a href="http://baike.baidu.com/view/1377.htm">外频</a>与前端总线（FSB）频率的区别：前端总线的速度指的是数据传输的速度，外频是CPU与主板之间同步运行的速度。也就是说，100MHz<a href="http://baike.baidu.com/view/1377.htm">外频</a>特指数字脉冲信号在每秒钟震荡一亿次；而100MHz前端总线指的是每秒钟CPU可接受的数据传输量是100MHz×64bit÷8bit/Byte=800MB/s。   </p>
<p>
    其实现在“HyperTransport”构架的出现，让这种实际意义上的前端总线（FSB）频率发生了变化。IA-32架构必须有三大重要的构件：<a href="http://baike.baidu.com/view/18163.htm">内存控制器</a>Hub  (MCH),I/O控制器Hub和PCI Hub，像Intel很典型的<a href="http://baike.baidu.com/view/15282.htm">芯片组</a>Intel  7501.Intel7505芯片组，为双<a href="http://baike.baidu.com/view/102947.htm">至强</a><a href="http://baike.baidu.com/view/50152.htm">处理器</a>量身定做的，它们所包含的MCH为CPU提供了频率为533MHz的前端总线，配合DDR内存，前端<a href="http://baike.baidu.com/view/1159510.htm">总线带宽</a>可达到4.3GB/秒。但随着<a href="http://baike.baidu.com/view/50152.htm">处理器</a>性能不断提高同时给系统架构带来了很多问题。而“HyperTransport”构架不但解决了问题，而且更有效地提高了总线带宽，比方AMD Opteron<a href="http://baike.baidu.com/view/50152.htm">处理器</a>，灵活的HyperTransport <a href="http://baike.baidu.com/view/950897.htm">I/O总线</a><a href="http://baike.baidu.com/view/1188494.htm">体系结构</a>让它整合了内存控制器，使处理器不通过<a href="http://baike.baidu.com/view/65714.htm">系统总线</a>传给芯片组而直接和内存交换数据。这样的话，前端总线（FSB）频率在AMD Opteron<a href="http://baike.baidu.com/view/50152.htm">处理器</a>就不知道从何谈起了。   </p>
<p>
  <a href="http://baike.baidu.com/picview/14045/14045/0/adaf2edda3cc7cd92e98d7403901213fb90e91f6.html"><img border="0" width="220" height="217" src="table no_clip_image001_0000.jpg" alt="AMD 羿龙II X4 955黑盒" /></a>  </p>
<p>
  <a href="http://baike.baidu.com/picview/14045/14045/0/adaf2edda3cc7cd92e98d7403901213fb90e91f6.html" title="查看图片">&nbsp;&nbsp;</a>AMD 羿龙II X4 955黑盒  </p>
<p>
  </p>
<p>
  <a href="http://baike.baidu.com/picview/14045/14045/0/a8362712f3460411f819b8bb.html"><img border="0" width="220" height="166" src="table no_clip_image002.jpg" alt="中央处理器（Intel）" /></a>  </p>
<p>
  <a href="http://baike.baidu.com/picview/14045/14045/0/a8362712f3460411f819b8bb.html" title="查看图片">&nbsp;&nbsp;</a>中央处理器（Intel）  </p>
<p>
  <a name="5_4" id="5_4"></a><a name="sub14045_5_4" id="sub14045_5_4"></a>倍频系数  </p>
<p>
    倍频系数是指<a href="http://baike.baidu.com/view/194487.htm">CPU主频</a>与<a href="http://baike.baidu.com/view/1377.htm">外频</a>之间的相对比例关系。在相同的<a href="http://baike.baidu.com/view/1377.htm">外频</a>下，倍频越高CPU的频率也越高。但实际上，在相同<a href="http://baike.baidu.com/view/1377.htm">外频</a>的前提下，高倍频的CPU本身意义并不大。这是因为CPU与系统之间<a href="http://baike.baidu.com/view/2827566.htm">数据传输速度</a>是有限的，一味追求高主频而得到高倍频的CPU就会出现明显的“<a href="http://baike.baidu.com/view/83216.htm">瓶颈</a>”效应－CPU从系统中得到数据的极限速度不能够满足CPU运算的速度。一般除了工程样版的Intel的CPU都是锁了倍频的，少量的如Intel <a href="http://baike.baidu.com/view/304287.htm">酷睿2</a>核心的<a href="http://baike.baidu.com/view/1788253.htm">奔腾双核</a>E6500K和一些至尊版的CPU不锁倍频，而<a href="http://baike.baidu.com/view/810.htm">AMD</a>之前都没有锁，现在AMD推出了黑盒版CPU（即不锁倍频版本，用户可以自由调节倍频，调节倍频的超频方式比调节<a href="http://baike.baidu.com/view/1377.htm">外频</a>稳定得多）。   </p>
<p>
  <a name="5_5" id="5_5"></a><a name="sub14045_5_5" id="sub14045_5_5"></a>缓存  </p>
<p>
    <a href="http://baike.baidu.com/view/3749508.htm">缓存大小</a>也是CPU的重要指标之一，而且缓存的结构和大小对CPU速度的影响非常大，CPU内缓存的运行频率极高，一般是和<a href="http://baike.baidu.com/view/50152.htm">处理器</a>同频运作，<a href="http://baike.baidu.com/view/3456760.htm">工作效率</a>远远大于<a href="http://baike.baidu.com/view/404470.htm">系统内存</a>和硬盘。实际工作时，CPU往往需要重复读取同样的<a href="http://baike.baidu.com/view/702806.htm">数据块</a>，而缓存<a href="http://baike.baidu.com/view/334600.htm">容量</a>的增大，可以大幅度提升CPU内部读取数据的<a href="http://baike.baidu.com/view/1792463.htm">命中率</a>，而不用再到内存或者硬盘上寻找，以此提高系统性能。但是由于CPU芯片面积和成本的因素来考虑，缓存都很小。   </p>
<p>
    L1　Cache(<a href="http://baike.baidu.com/view/16882.htm">一级缓存</a>）是CPU第一层高速缓存，分为<a href="http://baike.baidu.com/view/32571.htm">数据缓存</a>和<a href="http://baike.baidu.com/view/1529137.htm">指令缓存</a>。内置的<a href="http://baike.baidu.com/view/541082.htm">L1高速缓存</a>的<a href="http://baike.baidu.com/view/334600.htm">容量</a>和结构对CPU的性能影响较大，不过<a href="http://baike.baidu.com/view/496990.htm">高速缓冲存储器</a>均由静态RAM组成，结构较复杂，在CPU管芯面积不能太大的情况下，L1级高速缓存的容量不可能做得太大。一般服务器CPU的<a href="http://baike.baidu.com/view/1211105.htm">L1缓存</a>的<a href="http://baike.baidu.com/view/334600.htm">容量</a>通常在32－256KB。   </p>
<p>
    L2　Cache（二级缓存）是CPU的第二层高速缓存，分内部和外部两种芯片。内部的芯片二级缓存运行速度与主频相同，而外部的二级缓存则只有主频的一半。L2高速缓存<a href="http://baike.baidu.com/view/334600.htm">容量</a>也会影响CPU的性能，原则是越大越好，以前家庭用CPU容量最大的是512KB，现在<a href="http://baike.baidu.com/view/7690.htm">笔记本电脑</a>中也可以达到2M，而服务器和<a href="http://baike.baidu.com/view/7977.htm">工作站</a>上用CPU的L2高速缓存更高，可以达到8M以上。   </p>
<p>
    L3　Cache(<a href="http://baike.baidu.com/view/84602.htm">三级缓存</a>），分为两种，早期的是外置，现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低<a href="http://baike.baidu.com/view/1060639.htm">内存延迟</a>，同时提升<a href="http://baike.baidu.com/view/6954399.htm">大数据</a>量计算时<a href="http://baike.baidu.com/view/50152.htm">处理器</a>的性能。降低内存延迟和提升<a href="http://baike.baidu.com/view/6954399.htm">大数据</a>量计算能力对游戏都很有帮助。而在服务器领域增加L3缓存在性能方面仍然有显著的提升。比方具有较大L3缓存的配置利用<a href="http://baike.baidu.com/view/138684.htm">物理内存</a>会更有效，故它比较慢的<a href="http://baike.baidu.com/view/157418.htm">磁盘</a>I/O子系统可以处理更多的数据请求。具有较大L3缓存的<a href="http://baike.baidu.com/view/50152.htm">处理器</a>提供更有效的<a href="http://baike.baidu.com/view/266589.htm">文件系统</a>缓存行为及较短消息和处理器队列长度。 </p>
  <p>其实最早的L3缓存被应用在AMD发布的K6-III<a href="http://baike.baidu.com/view/50152.htm">处理器</a>上，当时的L3缓存受限于<a href="http://baike.baidu.com/view/1146582.htm">制造工艺</a>，并没有被集成进芯片内部，而是集成在主板上。在只能够和<a href="http://baike.baidu.com/view/3189424.htm">系统总线频率</a>同步的L3缓存同主内存其实差不了多少。后来使用L3缓存的是<a href="http://baike.baidu.com/view/15281.htm">英特尔</a>为服务器市场所推出的Itanium<a href="http://baike.baidu.com/view/50152.htm">处理器</a>。接着就是P4EE和至强MP。Intel还打算推出一款9MB L3缓存的Itanium2<a href="http://baike.baidu.com/view/50152.htm">处理器</a>，和以后24MB L3缓存的<a href="http://baike.baidu.com/view/13560.htm">双核心</a>Itanium2处理器。   </p>
<p>
    但基本上L3缓存对<a href="http://baike.baidu.com/view/50152.htm">处理器</a>的性能提高显得不是很重要，比方配备1MB L3缓存的Xeon MP处理器却仍然不是Opteron的对手，由此可见前端总线的增加，要比缓存增加带来更有效的性能提升。   </p>
<p>
  <a name="5_6" id="5_6"></a><a name="sub14045_5_6" id="sub14045_5_6"></a>CPU扩展指令集  </p>
<p>
    CPU依靠指令来自计算和控制系统，每款CPU在设计时就规定了一系列与其硬件<a href="http://baike.baidu.com/view/134362.htm">电路</a>相配合的<a href="http://baike.baidu.com/view/178189.htm">指令系统</a>。指令的强弱也是CPU的重要指标，指令集是提高微处理器<a href="http://baike.baidu.com/view/47610.htm">效率</a>的最有效工具之一。   </p>
<p>
    从现阶段的主流<a href="http://baike.baidu.com/view/1188494.htm">体系结构</a>讲，<a href="http://baike.baidu.com/view/9174.htm">指令集</a>可分为<a href="http://baike.baidu.com/view/1177592.htm">复杂指令集</a>和<a href="http://baike.baidu.com/view/981569.htm">精简指令集</a>两部分（指令集共有四个种类），而从具体运用看，如Intel的MMX（Multi Media Extended，此为AMD猜测的全称，Intel并没有说明词源）、<a href="http://baike.baidu.com/view/65687.htm">SSE</a>、<a href="http://baike.baidu.com/view/65695.htm">SSE2</a>（Streaming-Single  instruction multiple data-Extensions 2）、<a href="http://baike.baidu.com/view/67912.htm">SSE3</a>、<a href="http://baike.baidu.com/view/660057.htm">SSE4</a>系列和AMD的3DNow！等都是CPU的<a href="http://baike.baidu.com/view/1576505.htm">扩展指令集</a>，分别增强了CPU的<a href="http://baike.baidu.com/view/3323.htm">多媒体</a>、图形图象和Internet等的处理能力。   </p>
<p>
    通常会把CPU的扩展指令集称为”CPU的指令集”。<a href="http://baike.baidu.com/view/492527.htm">SSE3指令集</a>也是目前规模最小的指令集，此前MMX包含有57条命令，SSE包含有50条命令，SSE2包含有144条命令，SSE3包含有13条命令。   </p>
<p>
  <a name="5_7" id="5_7"></a><a name="sub14045_5_7" id="sub14045_5_7"></a>CPU内核和I/O工作电压  </p>
<p>
    从586CPU开始，CPU的工作<a href="http://baike.baidu.com/view/10954.htm">电压</a>分为内核电压和I/O电压两种，通常CPU的<a href="http://baike.baidu.com/view/13617.htm">核心电压</a>小于等于I/O电压。其中内核电压的大小是根据CPU的生产工艺而定，一般制作工艺越小，内核工作电压越低；I/O电压一般都在1.6~5V。低电压能解决耗电过大和发热过高的问题。   </p>
<p>
  <a name="6" id="6"></a><a name="sub14045_6" id="sub14045_6"></a>技术架构  </p>
<p>
  <a name="6_1" id="6_1"></a><a name="sub14045_6_1" id="sub14045_6_1"></a>制造工艺  </p>
<p>
    制造工艺的微米是指IC内<a href="http://baike.baidu.com/view/134362.htm">电路</a>与电路之间的距离。制造工艺的趋势是向密集度愈高的方向发展。密度愈高的IC<a href="http://baike.baidu.com/view/134362.htm">电路</a>设计，意味着在同样大小面积的IC中，可以拥有密度更高、功能更复杂的电路设计。现在主要的180nm、130nm、90nm、65nm、<a href="http://baike.baidu.com/view/1134005.htm">45纳米</a>。intel已经于2010年发布<a href="http://baike.baidu.com/view/2775095.htm">32纳米</a>的制造工艺的<a href="http://baike.baidu.com/view/3029985.htm">酷睿i3</a>/<a href="http://baike.baidu.com/view/2791473.htm">酷睿i5</a>/<a href="http://baike.baidu.com/view/2187192.htm">酷睿i7</a>系列并于2012年4月发布了22纳米酷睿i3/i5/i7系列。并且已有15nm产品的计划。而AMD则表示、自己的产品将会直接跳过32nm工艺（2010年第三季度生产少许32nm产品、如Orochi、Llano）于2011年中期初发布28nm的产品（APU）   </p>
<p>
  <a name="6_2" id="6_2"></a><a name="sub14045_6_2" id="sub14045_6_2"></a>指令集  </p>
<p>
    ⑴<a href="http://baike.baidu.com/view/503997.htm">CISC指令集</a>   </p>
<p>
    CISC指令集，也称为复杂指令集，英文名是CISC，（Complex Instruction Set Computer的缩写）。在CISC<a href="http://baike.baidu.com/view/1125.htm">微处理器</a>中，<a href="http://baike.baidu.com/view/17674.htm">程序</a>的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。<a href="http://baike.baidu.com/view/2120589.htm">顺序执行</a>的优点是控制简单，但<a href="http://baike.baidu.com/view/3314.htm">计算机</a>各部分的利用率不高，执行速度慢。其实它是英特尔生产的x86系列（也就是IA-32架构）CPU及其兼容CPU，如AMD、VIA的。即使是现在新起的<a href="http://baike.baidu.com/view/74760.htm">X86-64</a>（也说成AMD64）都是属于CISC的范畴。   </p>
<p>
    要知道什么是<a href="http://baike.baidu.com/view/9174.htm">指令集</a>还要从当今的X86架构的CPU说起。X86<a href="http://baike.baidu.com/view/9174.htm">指令集</a>是Intel为其第一块16位CPU(i8086）专门开发的，IBM1981年推出的世界第一台PC机中的CPU－i8088(i8086简化版）使用的也是X86指令，同时电脑中为提高<a href="http://baike.baidu.com/view/924477.htm">浮点</a><a href="http://baike.baidu.com/view/51860.htm">数据处理</a>能力而增加了X87芯片，以后就将X86指令集和X87指令集统称为X86指令集。   </p>
<p>
    虽然随着CPU技术的不断发展，Intel陆续研制出更新型的i80386.i80486直到过去的PII至强、PIII至强、Pentium 3，Pentium 4系列，最后到今天的<a href="http://baike.baidu.com/view/304287.htm">酷睿2</a>系列、至强（不包括至强Nocona），但为了保证电脑能继续运行以往开发的各类<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>以保护和继承丰富的<a href="http://baike.baidu.com/view/37.htm">软件</a>资源，所以Intel公司所生产的所有CPU仍然继续使用X86<a href="http://baike.baidu.com/view/9174.htm">指令集</a>，所以它的CPU仍属于X86系列。由于Intel  X86系列及其兼容CPU（如AMD Athlon MP、）都使用X86<a href="http://baike.baidu.com/view/9174.htm">指令集</a>，所以就形成了今天庞大的X86系列及兼容CPU阵容。x86CPU目前主要有intel的服务器CPU和AMD的服务器CPU两类。   </p>
<p>
    ⑵<a href="http://baike.baidu.com/view/272961.htm">RISC指令</a>集   </p>
<p>
    RISC是英文“Reduced Instruction Set Computing ”的缩写，中文意思是“<a href="http://baike.baidu.com/view/981569.htm">精简指令集</a>”。它是在CISC指令系统基础上发展起来的，有人对CISC机进行测试表明，各种指令的使用频度相当悬殊，最常使用的是一些比较简单的指令，它们仅占指令总数的20%，但在程序中出现的频度却占80%。复杂的指令系统必然增加微处理器的复杂性，使处理器的研制时间长，成本高。并且复杂指令需要复杂的操作，必然会降低<a href="http://baike.baidu.com/view/3314.htm">计算机</a>的速度。基于上述原因，20世纪80年代RISC型CPU诞生了，相对于CISC型CPU,RISC型CPU不仅精简了指令系统，还采用了一种叫做“<a href="http://baike.baidu.com/view/1062226.htm">超标量</a>和<a href="http://baike.baidu.com/view/326793.htm">超流水线</a>结构”，大大增加了<a href="http://baike.baidu.com/view/494465.htm">并行处理</a>能力。RISC指令集是高性能CPU的发展方向。它与传统的CISC（复杂指令集）相对。相比而言，RISC的<a href="http://baike.baidu.com/view/178195.htm">指令格式</a>统一，种类比较少，<a href="http://baike.baidu.com/view/889427.htm">寻址方式</a>也比复杂指令集少。当然处理速度就提高很多了。目前在中高档服务器中普遍采用这一指令系统的CPU，特别是高档服务器全都采用RISC指令系统的CPU。RISC指令系统更加适合高档服务器的<a href="http://baike.baidu.com/view/880.htm">操作系统</a>UNIX，现在Linux也属于类似UNIX的操作系统。RISC型CPU与Intel和AMD的CPU在软件和硬件上都不兼容。   </p>
<p>
    目前，在中高档服务器中采用RISC指令的CPU主要有以下几类：PowerPC<a href="http://baike.baidu.com/view/50152.htm">处理器</a>、<a href="http://baike.baidu.com/view/167688.htm">SPARC处理器</a>、PA-RISC处理器、<a href="http://baike.baidu.com/view/167695.htm">MIPS处理器</a>、Alpha处理器。   </p>
<p>
    ⑶<a href="http://baike.baidu.com/view/1062218.htm">IA-64</a>   </p>
<p>
    EPIC（Explicitly Parallel Instruction Computers，精确并行指令<a href="http://baike.baidu.com/view/3314.htm">计算机</a>）是否是RISC和CISC体系的继承者的争论已经有很多，单以EPIC体系来说，它更像Intel的<a href="http://baike.baidu.com/view/50152.htm">处理器</a>迈向RISC体系的重要步骤。从理论上说，EPIC体系设计的CPU，在相同的主机配置下，处理Windows的<a href="http://baike.baidu.com/view/7886.htm">应用软件</a>比基于Unix下的应用软件要好得多。   </p>
<p>
    Intel采用EPIC技术的服务器CPU是<a href="http://baike.baidu.com/view/102955.htm">安腾</a>Itanium（开发代号即Merced）。它是<a href="http://baike.baidu.com/view/838140.htm">64位处理器</a>，也是IA－64系列中的第一款。<a href="http://baike.baidu.com/view/2353.htm">微软</a>也已开发了代号为Win64的操作系统，在软件上加以支持。在Intel采用了X86<a href="http://baike.baidu.com/view/9174.htm">指令集</a>之后，它又转而寻求更先进的64-bit<a href="http://baike.baidu.com/view/1125.htm">微处理器</a>，Intel这样做的原因是，它们想摆脱<a href="http://baike.baidu.com/view/334600.htm">容量</a>巨大的x86架构，从而引入精力充沛而又功能强大的指令集，于是采用EPIC指令集的IA-64架构便诞生了。IA-64 在很多方面来说，都比x86有了长足的进步。突破了传统IA32架构的许多限制，在数据的处理能力，系统的稳定性、安全性、可用性、可观理性等方面获得了突破性的提高。   </p>
<p>
    IA-64<a href="http://baike.baidu.com/view/1125.htm">微处理器</a>最大的缺陷是它们缺乏与x86的兼容，而Intel为了IA-64处理器能够更好地运行两个朝代的软件，它在IA-64处理器上（Itanium、Itanium2 ……）引入了x86-to-IA-64的<a href="http://baike.baidu.com/view/1079.htm">解码器</a>，这样就能够把x86指令翻译为IA-64指令。这个解码器并不是最有效率的解码器，也不是运行x86代码的最好途径（最好的途径是直接在x86<a href="http://baike.baidu.com/view/50152.htm">处理器</a>上运行x86代码），因此Itanium  和Itanium2在运行x86应用程序时候的性能非常糟糕。这也成为X86-64产生的根本原因。   </p>
<p>
  <a name="6_3" id="6_3"></a><a name="sub14045_6_3" id="sub14045_6_3"></a>超流水线与超标量  </p>
<p>
    在解释超流水线与超标量前，先了解流水线（Pipeline）。流水线是Intel首次在486芯片中开始使用的。流水线的工作方式就象<a href="http://baike.baidu.com/view/1714883.htm">工业生产</a>上的装配流水线。在CPU中由5－6个不同功能的<a href="http://baike.baidu.com/view/134362.htm">电路</a>单元组成一条指令处理流水线，然后将一条X86指令分成5－6步后再由这些电路单元分别执行，这样就能实现在一个<a href="http://baike.baidu.com/view/1876127.htm">CPU时钟周期</a>完成一条指令，因此提高CPU的运算速度。经典奔腾每条整数流水线都分为四级流水，即<a href="http://baike.baidu.com/view/3658731.htm">指令预取</a>、<a href="http://baike.baidu.com/view/189742.htm">译码</a>、执行、写回结果，<a href="http://baike.baidu.com/view/924477.htm">浮点</a>流水又分为八级流水。<a href="http://baike.baidu.com/view/1062226.htm">超标量</a>是通过内置多条流水线来同时执行多个<a href="http://baike.baidu.com/view/50152.htm">处理器</a>，其实质是以空间换取时间。而<a href="http://baike.baidu.com/view/326793.htm">超流水线</a>是通过细化流水、提高主频，使得在一个<a href="http://baike.baidu.com/view/713240.htm">机器周期</a>内完成一个甚至多个操作，其实质是以时间换取空间。例如Pentium 4的流水线就长达20级。将流水线设计的步（级）越长，其完成一条指令的速度越快，因此才能适应工作主频更高的CPU。但是流水线过长也带来了一定副作用，很可能会出现主频较高的CPU实际运算速度较低的现象，Intel的<a href="http://baike.baidu.com/view/502769.htm">奔腾4</a>就出现了这种情况，虽然它的主频可以高达1.4G以上，但其运算性能却远远比不上AMD 1.2G的<a href="http://baike.baidu.com/view/261293.htm">速龙</a>甚至奔腾III。   </p>
<p>
  <a name="6_4" id="6_4"></a><a name="sub14045_6_4" id="sub14045_6_4"></a>封装形式</p>
  <p><a href="http://baike.baidu.com/view/52049.htm">CPU封装</a>是采用特定的材料将CPU芯片或CPU<a href="http://baike.baidu.com/view/22845.htm">模块</a>固化在其中以防损坏的保护措施，一般必须在封装后CPU才能交付用户使用。CPU的<a href="http://baike.baidu.com/view/3473353.htm">封装方式</a>取决于CPU安装形式和器件集成设计，从大的分类来看通常采用Socket<a href="http://baike.baidu.com/view/294606.htm">插座</a>进行安装的CPU使用PGA（栅格阵列）方式封装，而采用Slot x槽安装的CPU则全部采用SEC（单边接插盒）的形式封装。现在还有PLGA(Plastic Land Grid Array）、OLGA(Organic Land  Grid Array）等<a href="http://baike.baidu.com/view/34754.htm">封装技术</a>。由于市场竞争日益激烈，目前<a href="http://baike.baidu.com/view/816474.htm">CPU封装技术</a>的发展方向以节约成本为主。   </p>
<p>
      <a name="6_5" id="6_5"></a><a name="sub14045_6_5" id="sub14045_6_5"></a>多线程  </p>
<p>
    同时多<a href="http://baike.baidu.com/view/1053.htm">线程</a>Simultaneous  Multithreading，简称<a href="http://baike.baidu.com/view/10599.htm">SMT</a>。SMT可通过复制<a href="http://baike.baidu.com/view/50152.htm">处理器</a>上的结构状态，让同一个处理器上的多个<a href="http://baike.baidu.com/view/6501899.htm">线程同步</a>执行并共享处理器的执行资源，可最大限度地实现宽发射、乱序的<a href="http://baike.baidu.com/view/1062226.htm">超标量</a>处理，提高处理器运算部件的利用率，缓和由于数据相关或Cache未命中带来的访问内存延时。当没有多个线程可用时，SMT<a href="http://baike.baidu.com/view/50152.htm">处理器</a>几乎和传统的宽发射<a href="http://baike.baidu.com/view/1062226.htm">超标量</a>处理器一样。SMT最具吸引力的是只需小规模改变<a href="http://baike.baidu.com/view/3957.htm">处理器核心</a>的设计，几乎不用增加额外的成本就可以显著地提升效能。<a href="http://baike.baidu.com/view/2476093.htm">多线程技术</a>则可以为高速的运算核心准备更多的待处理数据，减少运算核心的闲置时间。这对于<a href="http://baike.baidu.com/view/79807.htm">桌面</a>低端系统来说无疑十分具有吸引力。Intel从3.06GHz Pentium 4开始，所有<a href="http://baike.baidu.com/view/50152.htm">处理器</a>都将支持SMT技术。   </p>
<p>
  <a name="6_6" id="6_6"></a><a name="sub14045_6_6" id="sub14045_6_6"></a>多核心  </p>
<p>
    <a href="http://baike.baidu.com/view/757340.htm">多核心</a>，也指<a href="http://baike.baidu.com/view/1062228.htm">单芯片多处理器</a>（Chip  Multiprocessors，简称CMP）。CMP是由<a href="http://baike.baidu.com/view/282776.htm">美国斯坦福大学</a>提出的，其思想是将大规模并行处理器中的SMP（对称多处理器）集成到同一芯片内，各个处理器<a href="http://baike.baidu.com/view/160033.htm">并行执行</a>不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向，称为并行处理。与CMP比较，SMT<a href="http://baike.baidu.com/view/50152.htm">处理器</a>结构的灵活性比较突出。但是，当<a href="http://baike.baidu.com/view/19928.htm">半导体</a>工艺进入0.18微米以后，线延时已经超过了门延迟，要求<a href="http://baike.baidu.com/view/1125.htm">微处理器</a>的设计通过划分许多规模更小、局部性更好的<a href="http://baike.baidu.com/view/693012.htm">基本单元</a>结构来进行。相比之下，由于CMP结构已经被划分成多个<a href="http://baike.baidu.com/view/50152.htm">处理器</a>核来设计，每个核都比较简单，有利于优化设计，因此更有发展前途。目前，IBM 的Power 4芯片和Sun的MAJC5200芯片都采用了CMP结构。<a href="http://baike.baidu.com/view/2797908.htm">多核处理器</a>可以在处理器内部共享缓存，提高缓存利用率，同时简化多处理器系统设计的复杂度。但这并不是说明，核心越多，性能越高，比如说16核的CPU就没有8核的CPU运算速度快，因为核心太多，而不能合理进行分配，所以导致运算速度减慢。在买电脑时请酌情选择。2005年下半年，Intel和AMD的新型<a href="http://baike.baidu.com/view/50152.htm">处理器</a>也将融入CMP结构。新<a href="http://baike.baidu.com/view/388413.htm">安腾处理器</a>开发代码为Montecito，采用<a href="http://baike.baidu.com/view/13560.htm">双核心</a>设计，拥有最少18MB片内缓存，采取90nm工艺制造。它的每个单独的核心都拥有独立的L1，L2和L3 cache，包含大约10亿支<a href="http://baike.baidu.com/view/30363.htm">晶体管</a>。   </p>
<p>
  <a name="6_7" id="6_7"></a><a name="sub14045_6_7" id="sub14045_6_7"></a>SMP  </p>
<p>
    SMP（Symmetric Multi-Processing），<a href="http://baike.baidu.com/view/1062233.htm">对称多处理结构</a>的简称，是指在一个计算机上汇集了一组<a href="http://baike.baidu.com/view/50152.htm">处理器</a>（多CPU），各CPU之间<a href="http://baike.baidu.com/view/120892.htm">共享内存</a>子系统以及<a href="http://baike.baidu.com/view/576327.htm">总线结构</a>。在这种技术的支持下，一个<a href="http://baike.baidu.com/view/6396042.htm">服务器系统</a>可以同时运行多个<a href="http://baike.baidu.com/view/50152.htm">处理器</a>，并共享内存和其他的<a href="http://baike.baidu.com/view/23880.htm">主机</a>资源。像双至强，也就是所说的二路，这是在对称<a href="http://baike.baidu.com/view/50152.htm">处理器</a>系统中最常见的一种（至强MP可以支持到四路，AMD  Opteron可以支持1-8路）。也有少数是16路的。但是一般来讲，SMP结构的机器可扩展性较差，很难做到100个以上多<a href="http://baike.baidu.com/view/50152.htm">处理器</a>，常规的一般是8个到16个，不过这对于多数的用户来说已经够用了。在高性能服务器和工作站级主板架构中最为常见，像UNIX服务器可支持最多256个CPU的系统。   </p>
<p>
    构建一套SMP系统的必要条件是：支持SMP的硬件包括主板和CPU；支持SMP的系统平台，再就是支持SMP的应用软件。为了能够使得SMP系统发挥高效的性能，操作系统必须支持SMP系统，如WINNT、LINUX、以及UNIX等等32位操作系统。即能够进行多任务和多线程处理。多任务是指操作系统能够在同一时间让不同的CPU完成不同的任务；多线程是指操作系统能够使得不同的CPU并行的完成同一个任务。   </p>
<p>
    要组建SMP系统，对所选的CPU有很高的要求，首先、CPU内部必须内置APIC（Advanced Programmable Interrupt Controllers）单元。Intel 多处理规范的核心就是高级<a href="http://baike.baidu.com/view/2348508.htm">可编程中断控制器</a>（Advanced  Programmable Interrupt Controllers–APICs）的使用；再次，相同的产品型号，同样类型的CPU核心，完全相同的运行频率；最后，尽可能保持相同的产品序列编号，因为两个生产批次的CPU作为双<a href="http://baike.baidu.com/view/50152.htm">处理器</a>运行的时候，有可能会发生一颗CPU负担过高，而另一颗负担很少的情况，无法发挥最大性能，更糟糕的是可能导致死机。   </p>
<p>
  <a name="6_8" id="6_8"></a><a name="sub14045_6_8" id="sub14045_6_8"></a>NUMA技术  </p>
<p>
    NUMA即非一致访问分布共享存储技术，它是由若干通过高速<a href="http://baike.baidu.com/view/2150902.htm">专用网络</a>连接起来的独立<a href="http://baike.baidu.com/view/47398.htm">节点</a>构成的系统，各个节点可以是单个的CPU或是SMP系统。在NUMA中，Cache 的一致性有多种解决方案，一般采用硬件技术实现对cache的一致性维护，通常需要操作系统针对NUMA访存不一致的特性（本地内存和远端内存访存延迟和带宽的不同）进行特殊优化以提高效率，或采用特殊软件编程方法提高效率。NUMA系统的例子。这里有3个SMP模块用高速专用网络联起来，组成一个<a href="http://baike.baidu.com/view/47398.htm">节点</a>，每个节点可以有12个CPU。像Sequent的系统最多可以达到64个CPU甚至256个CPU。显然，这是在SMP的基础上，再用NUMA的技术加以扩展，是这两种技术的结合。   </p>
<p>
  <a name="6_9" id="6_9"></a><a name="sub14045_6_9" id="sub14045_6_9"></a>乱序执行技术  </p>
<p>
    乱序执行（out-of-orderexecution），是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应<a href="http://baike.baidu.com/view/134362.htm">电路</a>单元处理的技术。这样将根据个<a href="http://baike.baidu.com/view/134362.htm">电路</a>单元的状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路单元执行，在这期间不按规定<a href="http://baike.baidu.com/view/2120589.htm">顺序执行</a>指令，然后由重新排列单元将各执行单元结果按指令顺序重新排列。采用<a href="http://baike.baidu.com/view/326795.htm">乱序执行技术</a>的目的是为了使CPU内部<a href="http://baike.baidu.com/view/134362.htm">电路</a>满负荷运转并相应提高了CPU的运行程序的速度。   </p>
<p>
  <a name="6_10" id="6_10"></a><a name="sub14045_6_10" id="sub14045_6_10"></a>分枝技术  </p>
<p>
    （branch）指令进行运算时需要等待结果，一般无条件分枝只需要按指令<a href="http://baike.baidu.com/view/2120589.htm">顺序执行</a>，而条件分枝必须根据处理后的结果，再决定是否按原先顺序进行。   </p>
<p>
  <a name="6_11" id="6_11"></a><a name="sub14045_6_11" id="sub14045_6_11"></a>CPU内部的内存控制器  </p>
<p>
    许多应用程序拥有更为复杂的读取模式（几乎是随机地，特别是当cache hit不可预测的时候），并且没有有效地利用带宽。典型的这类应用程序就是业务处理软件，即使拥有如乱序执行（out of order execution）这样的CPU特性，也会受内存延迟的限制。这样CPU必须得等到运算所需数据被除数装载完成才能执行指令（无论这些数据来自CPU cache还是主内存系统）。当前低段系统的内存延迟大约是120－150ns，而CPU速度则达到了3GHz以上，一次单独的内存请求可能会浪费200－300次CPU循环。即使在<a href="http://baike.baidu.com/view/2354813.htm">缓存命中率</a>（cache hit  rate）达到99%的情况下，CPU也可能会花50%的时间来等待内存请求的结束－比如因为内存延迟的缘故。   </p>
<p>
    在<a href="http://baike.baidu.com/view/50152.htm">处理器</a>内部<a href="http://baike.baidu.com/view/2777579.htm">整合内存控制器</a>，使得<a href="http://baike.baidu.com/view/3986.htm">北桥芯片</a>将变得不那么重要，改变了处理器访问<a href="http://baike.baidu.com/view/313837.htm">主存</a>的方式，有助于提高带宽、降低内存延时和提升处理器性制造工艺：Intel的I5可以达到32纳米，在将来的<a href="http://baike.baidu.com/view/32461.htm">CPU制造工艺</a>可以达到22纳米。</p>


<p align="left"><strong>选购CPU时需要注意的参数</strong><strong> </strong></p>
<p align="left">cpu的主要参数：主频外频倍频、一级缓存二级缓存、多媒体指令集 </p>
<p>
  1、主频外频倍频 </p>
<p>
  这三个频率，这三个频率是有联系的。 </p>
<p>
  主频=外频*倍频 </p>
<p>
  说实在点主频就相当于是高速公路和普通马路的区别当然是越高越好 </p>
<p>
  外频率相当是马路的宽度当然是越宽越好倍频我觉得就是个乘积关系没什么其他的意思 </p>
<p>
  还有主要的一点就是外频是数据交换的通道和内存交换数据紧密相联 </p>
<p>
  所以在主频相同的情况下提高外频要比提高倍频的提升的速度效果要高 </p>
<p>
  相当于是现在有100人要通过一条路，马路宽的通过时间要比路窄的通过时间要短 </p>
<p>
  2、一级缓存二级缓存 </p>
<p>
  顾名思义就是暂时存放数据的地方当然是越大越好一般以KB为单位，现在还出现了8MB以上的缓存 </p>
<p>
  3、多媒体指令集就是一些指令的集合这些指令所支持的功能肯定不一样 </p>
<p>
  所以不同的CPU里面的指令是不一样的。</p>

<p align="left">&nbsp;</p>

<p>主<a href="http://baike.baidu.com/view/87697.htm">存储器</a>Mainmemory简称主存。是<a href="http://baike.baidu.com/view/1024731.htm">计算机硬件</a>的一个重要部件，其作用是存放<a href="http://baike.baidu.com/view/178461.htm">指令</a>和数据，并能由<a href="http://baike.baidu.com/view/14045.htm">中央处理器</a>（CPU）直接<a href="http://baike.baidu.com/view/3049530.htm">随机存取</a>。现代<a href="http://baike.baidu.com/view/3314.htm">计算机</a>是为了提高性能，又能兼顾合理的造价，往往采用<a href="http://baike.baidu.com/view/4464278.htm">多级存储体系</a>。即由存储容量小，存取速度高的<a href="http://baike.baidu.com/view/496990.htm">高速缓冲存储器</a>，存储容量和存取速度适中的主存储器是必不可少的。主<a href="http://baike.baidu.com/view/87682.htm">存储</a>器是按地址存放信息的，存取速度一般与地址无关。32位（比特）的地址最大能表达4GB的<a href="http://baike.baidu.com/view/5977785.htm">存储器地址</a>。这对多数应用已经足够，但对于某些特大运算量的应用和特大型数据库已显得不够，从面对64位结构提出需求。 </p>
<p>
  主存储器一般采用半导体存储器，与辅助存储器相比有容量小、读写速度快、价格高等特点。 </p>
<p>
  从70年代起，主<a href="http://baike.baidu.com/view/87682.htm">存储</a>器已逐步采用<a href="http://baike.baidu.com/view/412393.htm">大规模集成电路</a>构成。用得最普遍的也是最经济的动态<a href="http://baike.baidu.com/view/151093.htm">随机存储器</a>芯片（DRAM）。1995年集成度为64Mb（可<a href="http://baike.baidu.com/view/87682.htm">存储</a>400万个汉字）的DRAM芯片已经开始商业性生产，16Mb </p>
<p>
  DRAM芯片已成为市场主流产品。DRAM芯片的存取速度适中，一般为50~70ns。有一些改进型的DRAM，如EDO DRAM（即扩充<a href="http://baike.baidu.com/view/324739.htm">数据输出</a>的DRAM），其性能可较普通DRAM提高10%以上，又如SDRAM（即同步DRAM），其性能又可较EDO DRAM提高10%左右。1998年SDRAM的后继产品为SDRAMⅡ（或称DDR，即双倍数据速率）的品种已上市。在追求速度和可靠性的场合，通常采用价格较贵的<a href="http://baike.baidu.com/view/2835171.htm">静态随机存储器</a>芯片（SRAM），其存取速度可以达到了1~15ns。无论主存采用DRAM还是SRAM芯片构成，在断电时<a href="http://baike.baidu.com/view/87682.htm">存储</a>的信息都会“丢失”，因此<a href="http://baike.baidu.com/view/3314.htm">计算机</a>设计者应考虑发生这种情况时，设法维持若干毫秒的供电以保存主存中的重要信息，以便供电恢复时计算机能恢复正常运行。鉴于上述情况，在某些应用中主存中<a href="http://baike.baidu.com/view/87682.htm">存储</a>重要而相对固定的程序和数据的部分采用“非易失性”<a href="http://baike.baidu.com/view/87682.htm">存储</a>器芯片（如EPROM，快闪<a href="http://baike.baidu.com/view/6546463.htm">存储芯片</a>等）构成；对于完全固定的程序，数据区域甚至采用<a href="http://baike.baidu.com/view/132973.htm">只读存储器</a>（ROM）芯片构成；主存的这些部分就不怕暂时供电中断，还可以防止病毒侵入。 </p>
<p>
  主<a href="http://baike.baidu.com/view/4403591.htm">存储设备</a>：Primary Storage Device，直接与维护新数据或有效数据的<a href="http://baike.baidu.com/view/930.htm">客户端</a>或服务器相连的在线<a href="http://baike.baidu.com/view/6519333.htm">磁盘存储</a>装置。（参见“<a href="http://baike.baidu.com/view/2305373.htm">二级存储设备</a>”）。 </p>
<p>
  主<a href="http://baike.baidu.com/view/87682.htm">存储</a>器，指的就是<a href="http://baike.baidu.com/view/1143.htm">主板</a>上的存储部件，是CPU直接与之沟通，并用其存储数据的部件，存放当前正在使用的（即执行中）的数据和程序，它的物理实质就是一组或 </p>
<p>
  多组具备数据输入输出和数据存储功能的<a href="http://baike.baidu.com/view/1355.htm">集成电路</a>，内存只用于暂时存放程序和数据，一旦关闭<a href="http://baike.baidu.com/view/13542.htm">电源</a>或发生断电，其中的程序和数据就会丢失。 主<a href="http://baike.baidu.com/view/87682.htm">存储</a>器从70年代起，已逐步采用<a href="http://baike.baidu.com/view/412393.htm">大规模集成电路</a>构成。用得最普遍的也是最经济的动态随机存储器芯片（<a href="http://baike.baidu.com/view/3856.htm">DRAM</a>）。1995年集成度为64Mb（可存储400万个汉字）的DRAM芯片已经开始商业性生产，16MbDRAM芯片已成为市场主流产品。DRAM芯片的存取速度适中，一般为50~70ns。有一些改进型的DRAM，如EDODRAM（即扩充数据输出的DRAM），其性能可较普通DRAM提高10%以上，又如<a href="http://baike.baidu.com/view/18583.htm">SDRAM</a>（即同步DRAM），其性能又可较EDODRAM提高10%左右。1998年SDRAM的后继产品为SDRAMⅡ（或称DDR，即双倍数据速率）的品种已上市。 </p>
<p>
  在追求速度和可靠性的场合，通常采用价格较贵的静态随机存储器芯片（SRAM），其存取速度可以达到了1~15ns。无论主存采用DRAM还是SRAM芯片构成，在断电时存储的信息都会“丢失”，因此<a href="http://baike.baidu.com/view/3314.htm">计算机</a>设计者应考虑发生这种情况时，设法维持若干毫秒的供电以保存主存中的重要信息，以便供电恢复时计算机能恢复正常运行。鉴于上述情况，在某些应用中主存中存储重要而相对固定的程序和数据的部分采用“非易失性”存储器芯片（如EPROM，快闪存储芯片等）构成；对于完全固定的程序，数据区域甚至采用只读存储器（ROM）芯片构成；主存的这些部分就不怕暂时供电中断，还可以防止病毒侵入。</p>
</div>
</p>
<p>
</body>
</html>
