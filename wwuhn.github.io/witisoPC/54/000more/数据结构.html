<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 <script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>数据结构</title>

 <style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.4em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 100px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 70px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
 img{
 border:0;
 }#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
padding-left:3px;
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}
.floatr{
float:right;
padding-right:5px;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
 \s*<br />\s*
 
 
</p>

<p>
</style>
</head>

<body>

<div class="container">
<p>在计算机科学中，数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象（数据元素）以及它们之间的关系和运算等的学科，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。</p>

<p>合理的数据结构能够提高算法的执行效率，还可以提高数据的存储效率；</p>

<p>数据结构是一切算法的基础，也是程序设计的基础。正是由于对数据结构的深入理解，才导致多种多样的程序设计语言的诞生。</p>
<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
<p>数据结构是算法的基础。其重要的操作是存取的问题。</p>
<p>数据结构一是指相互之间存在某种特定关系的数据的集合；二是指数据之间的相互关系，也就是数据之间的逻辑结构。因此，当我们说定义数据结构时，除了定义数据之间的相互关系，还包括根据这些关系组织在一起的数据。在建立数据模型的阶段，我们说的数据结构更偏重于定义数据之间的相互关系；设计具体的算法步骤时，考虑的是如何对构建在这些数据关系之上的实际数据进行加工和处理。</p>
<p>数据之间的逻辑结构包括线性结构和关联结构（集合、映射）、树形结构和图形结构，对于简单的问题，应用这些基于数据结构就可以解决问题——但对于复杂的算法，往往需要将这些基本的数据结构组合起来形成更复杂的逻辑结构。</p>
<h4>了解数据结构的7个要点（寻找内存地址或变量名称的规律性） </h4>
<p>  1 了解内存和变量的关系； </p>
<p>  2 了解作为数据结构基础的数组； </p>
<p>  3 了解数组的应用：作为典型算法的数据结构； </p>
<p>  4 了解并掌握典型数据结构的类型和概念； </p>
<p>  5 了解栈和队列的实现方法； </p>
<p>  6 了解结构体的组成； </p>
<p>  7 了解链表和二叉树的实现方法； </p>
<p>掌握数据结构需要注意两个方面：</p>
<p>1 复杂数据结构的构造和实现原理；</p>
<p>2 数据结构的特性和对外接口；</p>
<h4>数据结构的组成部分</h4>
<p>数据结构具体指同一类数据元素中，各元素之间的相互关系，包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</p>

<p>一、数据的逻辑结构：数据元素之间的逻辑关系，与数据在计算机中是如何存储无关的。数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。其中的逻辑关系是指数据元素之间的前后件关系，而与他们在计算机中的存储位置无关。逻辑结构包括：</p>
<p>数据逻辑结构的分类</p>
<p>线性表中的数据元素之间并没有关系，只是通过不同的组织和管理方式将每个数据元素维护在一个线性表中，而表、图等复杂数据结构的每个数据元素之间也可能存在关系，如树的节点之间存在的父子关系，图的节点之间之间存在邻接关系。之所以称之为“复杂数据结构”，是因为相应的插入、删除操作不仅对数据元素进行操作，还要同时维护数据元素之间的关系。</p>
<p>1 线性结构：是表中各个结点具有线性关系。</p>
<p>线性表是数据结构中最简单的基本数据结构，线性表的使用和维护都很简单。这一特点使其成为很多算法的基础。数组、链表、栈和队列是四种最常见的线性表，其外部行为和内部接口都各有特色。</p>
<p>1.1 有且仅有一个开始结点和一个终端结点;</p>

<p>1.2 所有结点最多只有一个直接前趋结点和一个直接后继结点;</p>

<p>如栈、队列和串</p>

<p>2 非线性结构，也线性结构刚好相对，如数组、广义表、图结构；</p>
<p>具体可以分为：</p>
<p>1.集合</p>

<p>2.线性结构</p>

<p>3.树形结构</p>

<p>4.图形结构</p>

<p>二、数据的物理结构：也就是数据元素及其逻辑关系在计算机存储器中的表示形式。数据的存储结构依赖于计算机语言，是逻辑结构用计算机语言的实现。</p>
<p>数据结构的几种存储方式</p>
<p>1 每个结点按顺序依次存储在一片连续的存储单元中；</p>

<p>2 每个结存存储在分散的空间而使用引用将这些结点链接起来；</p>
<p>具体可以分为：</p>

<p>1 顺序Sequential Storage Structure，数组，在一块连续的存储区域一个接一个地存储数据；</p>
<p>2 链接Linked,不要求逻辑上相邻的结点在物理位置上相邻，结点间的逻辑关系由附加的字段表示，一个结点的引用字段往往指向下一个结点的存放位置；</p>
<p>3 索引Index,是采用附加的索引表的方式来存储结点信息，索引表由若干索引项（关键字、地址）组成；</p>
<p>4 散列Hash,根据结点的关键字直接算出该结点的存储点；其思想是如果在结构中存在关键字和T相等的记录，那么就必定在F(T)的存储中以找到该刻录</p>

<p>三、数据结构的运算：也就是能够对数据施加的操作。数据的运算其基础在于数据的逻辑结构上，每种逻辑结构都可以归纳一个运算的操作。在数据结构范畴内，最常用的运算包括检索、插入、删除、更新、排序等。</p>


<p><strong>逻辑、储存、运算三者的关系</strong></p>

<p>同一个逻辑结构可以有不同的存储结构</p>

<p>线性表是一种简单的逻辑结构，可以考虑三种方式的存储</p>

<p>1 线性表采用顺序方式存储，这种数据结构就是顺序表；</p>

<p>2 线性表采用链式方式存储，这种数据结构就是链表；</p>

<p>3 线性表采用散列方式存储，这种数据结构就是散列表；</p>


<p>一个相同的数据逻辑结构和存储结构，而采用不同的运算集合及运算性质，将导致全新的数据结构。例如线性表，如果将线性表的插入运算限制在表的一段，而删除操作限制在表的另一端，那么这种数据结构就是队列；如果将线性表的插入和删除操作都限制在表的同一段，那么这种数据结构就是栈。</p>

<p>数据结构中的这三个方面是一个有机的整体，缺一不可。数据的逻辑结构、数据的存储结构和数据的运算任何一个发生变化都将导致一个全新的数据结构出现。</p>
<p>同一种逻辑结构也可以有不同的数据运算集合</p>

<h4>数据结构的内容</h4>
<p>1 逻辑结构：数据元素之间的逻辑关系；</p>
<p>2 存储结构：是逻辑结构在存储器中的表现形式；</p>
<p>3 数据运算：每种逻辑结构都可以归纳一个运算的集合，包括检索、插入、删除、更新、排序；</p>
<p>4 同一个逻辑结构可以有不同的存储结构；</p>
<p>5 同一种逻辑结构可以有不同的数据运算集合；</p>
<p>6 一个相同的逻辑结构和存储结构，而采用不同的去处集合及运算性质，将导致全新的数据结果。如线性表，如果将线性表的插入运算限制在表的一端，而删除操作限定在表的另一端，那么这种数据结构就是队列；如果将线性表的插入和删除操作都在表的同一段，那么这种数据结构就叫栈。</p>



<h4>数据结构类型</h4>
<table id="tbrowser">

<tr>
<td>类别</td>
<td>基本运算</td>
<td>逻辑结构</td>
<td>存储结构</td>
<td>优缺点</td>
</tr>


<tr>
<td>Linear List </td>
<td>初始化→计算表长→获取结点→查找结果→插入结点→删除结果；</td>
<td>一个开始和终点结点，其余的内部结点有且只有一个直接前趋结点和一个直接后趋结点；</td>
<td>顺序存储</td>
<td></td>
</tr>


<tr>
<td>Linked List </td>
<td>对链表的访问只能从表头逐个寻找；</td>
<td>逻辑上相邻的结点在内存中并不一定相邻； </td>
<td>链式存储</td>
<td>浪费存储空间；</td>
</tr>

</table>






<h4>线性表的两种存储方式</h4>
<p>线性表Linear List：从逻辑上来看，线性表就是由n个数据元素组成的有限序列。</p>

<p>在计算机中线性表可以采用两种方法来保存，一种是顺序存储结构，另一种是链式存储结构。对于顺序存储结构的线性表称为顺序表，而链式存储的线性表称为链表。</p>

<p>顺序表结构的存储方式有如下一些缺点：</p>

<p>1 在插入或删除结点的时候，往往需要移动大量的数据；</p>

<p>2 如果表比较大，有时比较难分配足够的连续存储空间，往往导致内存分配失败，而无法存储。</p>

<p>为了克服以上顺序表结构的缺点，我们可以采用链表结构。链表结构是一种动态存储分配的结构形式，可以根据需要动态申请所需的内存单元。</p>

<p>典型的链表结构的每个结点都应该包括如下两个部分：</p>

<p>1 数据部分，保存的是该结点的实际数据；</p>

<p>2 地址部分，保存的是下一个结点的地址；</p>

<p>链表结构就是由许多这种结点构成的。在进行逻表操作时，首先需要定义一个“头引用”变量（一般以head表示），该引用变量指向链表结构的第一个结点，第一个结点的地址部分又指向第二个结点…，直到最后一个结点。最后一个结点不再指向其他结点，称为“表尾”，一般在表尾的地址部分放一个空地址“null“”，链表到此结束。</p>

<p>由于这里采用引用来指示下一个数据的地址。因此在链表结构中，逻辑上相信的结点在内存中并不一定相邻，逻辑相邻关系通过地址部分的引用变量来实现。</p>

<p>链表结构的缺点就是浪费存储空间，对于每个节点数据都需要额外保存一个引用变量。</p>

<p>对于链表的访问只能从表头逐个比较一直到找到需要的结点为止，而不能像顺序表那样进行随机访问。</p>

<p>链式存储是最常用的存储方式之一，它不仅可用来表示线性表，而且可用来表示各种非线性数据结构。</p>


<h3>常用结构 </h3>
<h4>数组 (Array)</h4>

<p>在程序设计中，为了处理方便，把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组。在C语言中，  数组属于构造数据类型。一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。因此按数组元素的类型不同，数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。</p>
<p>数组是数据结构的基础，因为在实际应用的程序中经常需要处理大量的数据，所以通过使用数组，可以一次性定义多个变量，可以提高编写程序的效率，可以高效地编写出能够实现排序等算法的程序。</p>
<p>说数组是数据结构的基础，是因为数组反映了内存的物理结构，在内存存储数据的空间是连续分布的。而在程序中，往往要从内存整体中分配出一块连续的空间供使用。如果用程序中的语句表示这种分配使用方式的话，就用到了数组。（《计算机是怎样跑起来的》（矢泽久雄））</p>
<p>数组是一种直接利用内存物理结构（计算机特性）的最基本的数据结构。只需要使用for语句，就可以连续地处理数组中所存储的数据，实现各种各样的算法。</p>
<p>数组是一种相对比较简单的数据组织关系，所有数据元素存储在一片连续的区域内，对数组的访问方式一般是通过下标直接访问数组元素，除此之外，对数组的基本操作还有插入、删除和查找，数组元素直接访问几乎没有开销，但是插入和删除操作需要移动数组元素，开销比较大。因此在插入和删除操作比较频繁的场合下，不适合使用数组。在数组中查找一个元素的时间复杂度是O(n)，如果数组元素是有序存储的，则使用二分查找可能将时间复杂度降为O(lgn)。</p>
<h4>栈 (Stack)</h4>

<p>是只能在某一端插入和删除的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</p>
<p>Stack:在计算机程序设计中，特别是汇编程序中，栈通常用于中断或子程序调用过程，此时，首先将重要的寄存器或变量压入栈，然后进入中断例程或子程序，处理完后，通过栈操作恢复寄存器和变量的值；基本操作：入栈Push和出栈pop;</p>
<p>栈是一种特殊的纯属表，其特殊性在于只能在表的一端插入和删除数组元素；插入和删除动作分别被称为“入栈”和“出栈”。严格来说，栈不是一种数据存储方式，而是一种逻辑管理方式，它遵循“后进先出”（Last In First Out）的原则管理和维护表中的数据。栈的数据存储方式可以是数组，也可以使用链表，分别被称为“顺序栈”和“链式栈”，但是无论采用何种存储方式，其行为都是一样的，即只能通过“出栈”和“入栈”的方式在数据表的一端操作数据。</p>
<p>栈是一种非常有用的数据结构，利用栈的一些特性，可以将算法的递归实现转换成非递归袖，在使用穷尽搜索方法时，也会使用栈保存当前的状态。有时候，广度优先搜索和深度优先搜索的差异仅仅是使用栈还是使用队列；</p>
<h4>队列 (Queue)</h4>

<p>一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列是按照“先进先出”或“后进后出”的原则组织数据的。队列中没有元素时，称为空队列。</p>
<p>队列也是一种特殊的线性表，普通队列只能在表的一端插入数据，在另一端删除数据，不能在队列的其他位置插入和删除数据。插入和删除动作分别被称为“入队”和“出队”，能执行“入队”的一端称为“后端”（rear），能执行“出队”的一端称为“前端”（front）,与栈一样，队列也不是一种数据存储方式，而是一种逻辑管理方式，它遵循“先进先出”（First In First Out）的原则管理和维护表中的数据，队列的数据存储方式可以采用数组，也可以使用链表。</p>
<h4>链表 (Linked List)</h4>

<p>是一种物理存储单元上非连续、非顺序的存储结构，它既可以表示线性结构，也可以用于表示非线性结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>在线性表长度不能确定的场合，一般会采用链表的形式。链表结构的每一个节点都由两个域组成，一个是存放实际数据元素的数据域，另一个就是构成链式结构的指针域。对于单式链表而言，指针域只有一个后向指针，对于双向链表，指针域由一个后向指针和一个前向指针组成。链表的插入和删除只需要修改指针域的指针指向即可完成。比数组的插入和删除操作效率高，但是访问数据元素的效率比较低，需要从链表头部向后（或向前）搜索，查找操作的时间复杂度是O(n)。链表长度可动态变化这一点，比数组具有更大的优势。</p>
<p>除了查找和访问效率没有数组高之外，链表的每个节点都要额外存储一个指针域，因此，需要一定的存储开销，对于一些插入和删除操作比较少，查找、遍历操作比较多的场合，应该优先选择使用可变数组代替链表。</p>
<h4>树 (Tree)</h4>

<p>是包含n（n&gt;0）个结点的有穷集合K，且在K中定义了一个关系N，N满足以下条件：</p>

<p>（1）有且仅有一个结点 K0，他对于关系N来说没有前驱，称K0为树的根结点。简称为根（root）。</p>

<p>（2）除K0外，K中的每个结点，对于关系N来说有且仅有一个前驱。</p>

<p>（3）K中各结点，对关系N来说可以有m个后继（m&gt;=0）。</p>



<p>树结构Tree</p>

<p>有些问题无法抽象为线性数据结构，如一个国家的行政机构、一个家庭的家谱等。这些问题有个共同点，那就是可以表示成一个层次关系。这种层次关系可以抽象为树结构。</p>

<p>树结构是一种描述非线性层次关系的数据结构。树是n个数据结点的集合，在该集合中包含一个根结点，根结点之下分布着一些互不交叉的子集合，这些子集合也就是根结点的子树。</p>

<p>1 在一个树结点中，有且仅有一个结点没有直接前驱，这个结点就是树的根结点；</p>

<p>2 除根结点外，其余每个结点有且仅有一个直接前驱；</p>

<p>3 每个结点可以有任意多个直接前驱；</p>

<p>树中的每一个结点都处于一定的层次上；</p>

<p>二叉树：是树结构的一种特殊形式，其是n个结点的集合，每个结点最多只能有两个子结点。二叉树的子树仍然是二叉树。二叉树的一个结点上对应的两个子树分别称为左子树和右子树，由于子树有左右之分，因此二叉树是有序对。</p>

<p>按照数据的存储方式，树结构可以分为顺序存储结构和链式存储结构两种</p>

<p>1 二叉树的顺序存储，顺序存储方式一般较适合完全二叉树的情况，对于非完全二叉树，一般建议采用链式存储方式。（因为非完全二叉树缺少的部分，需填上空的数据结点。）</p>

<p>2 二叉树的链式存储，二叉树的链式存储结构包含结点元素以及分别指向左子树和右子树的引用；</p>
<p>树是一种表达数据之间层次关系的数据结构，树中的每个节点有0个或多个子结点，但是只有一个父节点，父节点为空的节点就是根节点。一棵树只有一个根节点，树适合用来表达有层次关系的数据，比如一个公司的分支机构，计算机上的目录和文件结构等。如果树的子节点之间没有大小关系，则这样的树称为无序树，也称为自由树；如果对的子节点之间有大小关系，则 这样的树称为有序树。树通常也是图的一种形式，是一种没有环路的图。</p>



<h4>图 (Graph)</h4>

<p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>
<p>图Graph结构也是一种非线性数据结构，图结构在实际生活中具有丰富的例子。如，通信网络、交通网络、人际关系网络等都可以归结为图结构。图结构的组织形式要比树结构更为复杂，因此，图结构对存储和遍历等操作具有更高的要求。</p>

<p>树结构的各数据元素之间具有层次关系，每一层的元素可以和多个下层元素关联，但是只能和一个上层元素关联。如果把这个规则进一步扩展，也就是说，每个数据元素之间可以任意关联，这就构成了一个图结构。正是这种任意关联性，导致了图结构中数据关系的复杂性。研究图结构的一个专门理论工具便是图论。</p>

<p>一个典型的图结构包括两个部分：</p>

<p>1 顶点Vertex：图中的数据元素；</p>

<p>2 边Edge:图中连接这些顶点的线；</p>

<p>所有的顶点构成一个顶点集合，所有的边构成边集合，一个完整的图结构就是由顶点集合和边集合组成。 </p>
<p>图是一种特殊的数据组织方式，它不仅可以存储数据元素（对象），还可以存储数据元素之间和复杂关系。从直观上来看，图由一些顶点和连接这些顶点的边组成，顶点描述数据元素，边描述元素之间的关系。图的存储常采用邻接矩阵（二维数组方式）和邻接表（链表或或变长数组）方式。</p>
<p>图的遍历是一个非常重要的操作，一般可采用深度优先搜索和广度优先搜索两种策略。最佳路线选择往往会用到图的数据结构。</p>
<h4>堆 (Heap)</h4>

<p>在计算机科学中，堆是一种特殊的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。</p>
<p>堆也是一种完全树，除了树的特点以外，堆的父节点和子节点还存在一些特殊关系。最大堆的每个节点的值都大于其子树上所有节点的值。最小堆的每个节点的值都小于子树上所有节点的值。堆的插入和删除操作除了维持堆的完全树特征之外，还要维护节点之间的特殊关系。</p>
<table id="tbrowser">
  <col width="33" />
  <col width="47" />
  <col width="69" />
  <col width="84" />
  <col width="26" />
  <col width="163" />
  <col width="116" />
  <col width="402" />
  <tr height="21">
    <td height="21" colspan="8">堆栈</td>
    </tr>
  <tr height="19">
    <td height="19" width="80">　</td>
    <td>　</td>
    <td width="69">缓存</td>
    <td width="84">输入输出</td>
    <td width="26">　</td>
    <td width="163">内存区域</td>
    <td width="116">内存分配</td>
    <td width="402">保存数据类型</td>
  </tr>
  <tr height="19">
    <td height="19" width="80">堆</td>
    <td>heap</td>
    <td>二级缓存</td>
    <td>由顶部取出</td>
    <td>　</td>
    <td>一块非连续的内存区域</td>
    <td>程序员自己申请</td>
    <td>对象的数据保存在堆中，其引用的地址做为变量保存在栈中；</td>
  </tr>
  <tr height="19">
    <td height="19" width="80">栈</td>
    <td>stack</td>
    <td>一级缓存</td>
    <td>后进先出</td>
    <td>2M</td>
    <td>一块连续的内存区域</td>
    <td>系统自动化分配</td>
    <td>基本型数据局部变量保存在栈中；</td>
  </tr>
</table>


<h4>集合（set）</h4>
<p>集合是具有某种特征的事物的整体。构成集合的事物或对象称为集合的元素或成员。集合的操作：1是对集合元素的操作，包括插入和删除元素，判断一个元素是否属于集合等；另一部分是集合之间的关系运算。</p>

<h4>哈希表（hash）与映射（map）</h4>
<p>哈希表和映射都是通过一个哈希函数对关键字进行某种运算，得到对应的数据元素在表中的存储位置，然后访问其值，与普通的有序表查找相比，额外的哈希处理会造成数据访问的开销。其查找速度更快。</p>
<p>现实生活中很多采用“key-value”方式组织和存储数据的情况，学生成绩管理系统会通过一个唯一分配的学号建立与具体学生信息映射关系，可以通过学号查询和管理学生信息，这个学号就是key。</p>
<h4>散列表 (Hash)</h4>

<p>若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数(Hash function)，按这个思想建立的表为散列表。</p>

<table id="tbrowser">
  <col width="194" />
  <col width="87" span="3" />
  <tr height="19">
    <td height="19" width="194"></td>
    <td width="87">set</td>
    <td width="87">list</td>
    <td width="87">map</td>
  </tr>
  <tr height="19">
    <td height="19">Array读快改慢</td>
    <td width="87"></td>
    <td>↗</td>
    <td></td>
  </tr>
  <tr height="19">
    <td height="19">Linked改快读慢；</td>
    <td></td>
    <td>↗</td>
    <td></td>
  </tr>
  <tr height="19">
    <td height="19">Hash两者之间；</td>
    <td>↗</td>
    <td></td>
    <td>↗</td>
  </tr>
  <tr height="19">
    <td height="19" width="194">sorted</td>
    <td>↗</td>
    <td></td>
    <td></td>
  </tr>
  <tr height="19">
    <td height="19">tree</td>
    <td>↗</td>
    <td></td>
    <td>↗</td>
  </tr>
  <tr height="19">
    <td height="19">Set是数学集合的抽象模型；</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr height="19">
    <td height="19" colspan="4">List是一个有序的集合（有时被称为序列），可以包含重复；</td>
  </tr>
  <tr height="19">
    <td height="19" colspan="4">Map是数学函数的抽象模型，是一种包含链值对象元素的集合；</td>
  </tr>
</table>




<h4>数据结构与数据类型</h4>

<p>数据结构不同于数据类型，也不同于数据对象，它不仅要描述数据类型的数据对象，而且要描述数据对象各元素之间的相互关系。 </p>
<p>数据类型是一个值的集合和定义在这个值集上的一组操作的总称。数据类型可分为两类：原子类型、结构类型。一方面，在程序设计语言中，每一个数据都属于某种数据类型。类型明显或隐含地规定了数据的取值范围、存储方式以及允许进行的运算。可以认为，数据类型是在程序设计中已经实现了的数据结构。另一方面，在程序设计过程中，当需要引入某种新的数据结构时，总是借助编程语言所提供的数据类型来描述数据的存储结构。 </p>
<p>数据类型就是一个值的集合以及在这些值上定义的一系列操作的总称。如，对于C语言的整数类型，其有一定的取值范围，对于整数类型还定义了加法、减法、乘法、除法和取模运算等操作。</p>

<p>按照数据类型的值是否可以分解，数据类型可以分为基本数据类型和聚合数据类型。</p>

<p>把一个语言所处理的对象按其属性不同，分为不同的子集，对不同的子集规定不同的运算操作。</p>
<p>1 类型确定的值的范围。</p>
<p>2 类型确定了值的操作类型；</p>
<p>3 类型确定了值的存储空间大小；</p>
<p>4 类型确定了值的存储方式；</p>
<p>确定数据类型有助于程序设计的简明性和数据的可靠性；有助于数据的存储管理；有利于提高程序的运行效率；</p>
<table id="tbrowser">
  <col width="194" />
  <col width="87" span="7" />
  <tr height="38">
    <td height="38" width="194">集合接口/类</td>
    <td width="87">元素<br />
      有顺序性</td>
    <td width="87">元素有<br />
      排序性</td>
    <td width="87">元素<br />
      不可重复</td>
    <td width="87">FIFO/<br />
      LIFO</td>
    <td width="87">有键值</td>
    <td width="87">键值<br />
      不可重复</td>
    <td width="87">键值<br />
      有排序性</td>
  </tr>
  <tr height="19">
    <td height="19" width="194">Set/HashSet</td>
    <td>　</td>
    <td>　</td>
    <td>√</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
  </tr>
  <tr height="19">
    <td height="19" width="194">SortedSet/TreeSet</td>
    <td>　</td>
    <td>√</td>
    <td>√</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
  </tr>
  <tr height="19">
    <td height="19" width="194">List/ArrayList</td>
    <td>√</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
  </tr>
  <tr height="38">
    <td height="38" width="194">Queue/LinkedList</td>
    <td width="87">LinkedList<br />
      有顺序性</td>
    <td>　</td>
    <td>　</td>
    <td>FIFO</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
  </tr>
  <tr height="19">
    <td height="19" width="194">Stack</td>
    <td>√</td>
    <td>　</td>
    <td>　</td>
    <td>LIFO</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
  </tr>
  <tr height="19">
    <td height="19" width="194">Map/HashMap</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>√</td>
    <td>√</td>
    <td>　</td>
  </tr>
  <tr height="19">
    <td height="19" width="194">SortedMap/TreeMap</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>　</td>
    <td>√</td>
    <td>√</td>
    <td>√</td>
  </tr>
</table>
<p>C语言的结构体类似于Java的类；</p>
<p>&nbsp;</p>
<p>列表处理的是成组的信息，字典处理的是成对的信息，字典也是通过一个信息找到另一个信息。字典不是将信息组织成序列，而是成对存储，查询一个键（key）,然后就能得到它的值；</p>
<table id="tbrowser">
  <col width="63" span="2" />
  <col width="249" />
  <col width="117" />
  <col width="146" />
  <col width="217" />
  <tr height="29">
    <td height="29" width="63">名称</td>
    <td width="63">序列还是关连</td>
    <td width="249">说明</td>
    <td width="117">数据结构模型</td>
    <td width="146">优点</td>
    <td width="217">缺点</td>
  </tr>
  <tr height="106">
    <td height="106" width="63">vector</td>
    <td width="63">序列容器(典型)</td>
    <td width="249">C++标准严格要求次容器的实现内存必须是连续的，唯一可以和标准C兼容的stl容器，任意元素的读取、修改具有常数时间复杂度，在序列尾部进行插入、删除是常数时间复杂度，但在序列的头部插入、删除的时间复杂度是O(n)，可以在任何位置插入新元素，有随机访问功能，插入删除操作需要考虑。</td>
    <td width="117">Vector的数据模型就是数组。</td>
    <td width="146">内存和C完全兼容、高效随机访问、节省空间</td>
    <td width="217">内部插入删除元素代价巨大、动态大小查过自身容量需要申请大量内存做大量拷贝。</td>
  </tr>
  <tr height="61">
    <td height="61" width="63">deque</td>
    <td width="63">序列容器</td>
    <td width="249">内存也是连续的，和vector相似，区别在于在序列的头部插入和删除操作也是常数时间复杂度,可以在任何位置插入新元素，有随机访问功能。</td>
    <td width="117">Deque的数据模型是数组和链表的折衷：</td>
    <td width="146">高效随机访问、内部插入删除元素效率方便、两端push    pop</td>
    <td width="217">内存占用比较高</td>
  </tr>
  <tr height="46">
    <td height="46" width="63">list&nbsp;&nbsp;</td>
    <td width="63">序列容器</td>
    <td width="249">内存是不连续的，任意元素的访问、修改时间复杂度是O(n)，插入、删除操作是常数时间复杂度,可以在任何位置插入新元素。</td>
    <td width="117">List的数据结构模型是链表</td>
    <td width="146">任意位置插入删除元素常量时间复杂度、两个容器融合是常量时间复杂度</td>
    <td width="217">不支持随机访问、比vector占用更多的存储空间</td>
  </tr>
  <tr height="43">
    <td height="43" width="63">set&nbsp;&nbsp;</td>
    <td width="63">关联容器</td>
    <td width="249">元素不允许有重复，数据被组织成一棵红黑树，查找的速度非常快，时间复杂度是O(logN)</td>
    <td width="117">的数据结构模型是二叉树(红黑树)</td>
    <td width="146">元素会按照键值排序、查找是对数时间复杂度、通过键值查元素</td>
    <td width="217">　</td>
  </tr>
  <tr height="43">
    <td height="43" width="63">multiset</td>
    <td width="63">关联容器</td>
    <td width="249">和set一样，区别是允许有重复的元素，具备时间复杂度O(logN)查找功能。</td>
    <td width="117">的数据结构模型是二叉树(红黑树)</td>
    <td width="146">元素会按照键值排序、查找是对数时间复杂度、通过键值查元素</td>
    <td width="217">　</td>
  </tr>
  <tr height="58">
    <td height="58" width="63">map&nbsp;&nbsp;</td>
    <td width="63">关联容器</td>
    <td width="249">按照{键，值}方式组成集合，按照键组织成一棵红黑树，查找的时间复杂度O(logN)，其中键不允许重复。如学生学号与姓名；</td>
    <td width="117">的数据结构模型是二叉树(红黑树)</td>
    <td width="146">元素会按照键值排序、查找是对数时间复杂度、通过键值查元素、map提供了下标访问</td>
    <td width="217">　</td>
  </tr>
  <tr height="58">
    <td height="58" width="63">multimap</td>
    <td width="63">关联容器</td>
    <td width="249">和map一样，区别是键可以重复</td>
    <td width="117">的数据结构模型是二叉树(红黑树)</td>
    <td width="146">元素会按照键值排序、查找是对数时间复杂度、通过键值查元素、map提供了下标访问</td>
    <td width="217">　</td>
  </tr>
  <tr height="50">
    <td height="50" width="63">vector</td>
    <td width="63">　</td>
    <td colspan="4" width="729">提供了连续内存地址的数据结构，可以通过下标运算符&quot;[]&quot;直接、有效地访问问题的任何元素。与数组不同，vector的内存用尽时，将自动分配更大的连续内存区，将原先的元素复制到新的内存区，并释放旧的内存区。向量可以用来实现队列、堆栈、列表和其他更复杂的数据结构。Vector的迭代器支持随机访问数据，vector的迭代器通常为vector元素的指针。向量的定义在头文件&lt;vector&gt;中。</td>
  </tr>
  <tr height="32">
    <td height="32" width="63">list&nbsp;&nbsp;</td>
    <td width="63"></td>
    <td colspan="4" width="729">list是由双向链表(doubly linked    list)组成的，所有有关链表的操作都适合列表操作。列表类有两个指针域，可以向前也可以向后访问，但不能随机访问，即支持的迭代器类型为双向迭代器。&lt;lis&gt;</td>
  </tr>
</table>
<p>&nbsp;</p>
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>
