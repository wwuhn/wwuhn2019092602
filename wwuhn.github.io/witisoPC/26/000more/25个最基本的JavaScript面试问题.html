<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>25个最基本的JavaScript面试问题</h4>

<p></p>

<p>1.使用 typeof bar === "object" 来确定 bar 是否是对象的潜在陷阱是什么？如何避免这个陷阱？</p>

<p>尽管 typeof bar === "object" 是检查 bar 是否对象的可靠方法，令人惊讶的是在JavaScript中 null 也被认为是对象！</p>

<p>因此，令大多数开发人员惊讶的是，下面的代码将输出 true (而不是false) 到控制台：</p>

<p>var bar = null;</p>

<p>console.log(typeof bar === "object"); // logs true!</p>

<p>只要清楚这一点，同时检查 bar 是否为 null，就可以很容易地避免问题：</p>

<p>console.log((bar !== null) && (typeof bar === "object")); // logs false</p>

<p>要答全问题，还有其他两件事情值得注意：</p>

<p>首先，上述解决方案将返回 false，当 bar 是一个函数的时候。在大多数情况下，这是期望行为，但当你也想对函数返回 true 的话，你可以修改上面的解决方案为：</p>

<p>console.log((bar !== null) && ((typeof bar === "object") || (typeof bar === "function")));</p>

<p>第二，上述解决方案将返回 true，当 bar 是一个数组（例如，当 var bar = [];）的时候。在大多数情况下，这是期望行为，因为数组是真正的对象，但当你也想对数组返回 false 时，你可以修改上面的解决方案为：</p>

<p>console.log((bar !== null) && (typeof bar === "object") && (toString.call(bar) !== "[object Array]"));</p>

<p>或者，如果你使用jQuery的话：</p>

<p>console.log((bar !== null) && (typeof bar === "object") && (! $.isArray(bar)));</p>

<p>2.下面的代码将输出什么到控制台，为什么？</p>

<p>(function(){</p>

<p>var a = b = 3;</p>

<p>})();</p>

<p>console.log("a defined? " + (typeof a !== 'undefined'));</p>

<p>console.log("b defined? " + (typeof b !== 'undefined'));</p>

<p>由于 a 和 b 都定义在函数的封闭范围内，并且都始于 var关键字，大多数JavaScript开发人员期望 typeof a 和 typeof b 在上面的例子中都是undefined。</p>

<p>然而，事实并非如此。这里的问题是，大多数开发人员将语句 var a = b = 3; 错误地理解为是以下声明的简写：</p>

<p>var b = 3;</p>

<p>var a = b;</p>

<p>但事实上，var a = b = 3; 实际是以下声明的简写：</p>

<p>b = 3;</p>

<p>var a = b;</p>

<p>因此（如果你不使用严格模式的话），该代码段的输出是：</p>

<p>a defined? false</p>

<p>b defined? true</p>

<p>但是， b 如何才能被定义在封闭函数的范围之外呢？是的，既然语句 var a = b = 3; 是语句 b = 3; 和 var a = b;的简写， b 最终成为了一个全局变量（因为它没有前缀 var 关键字），因此仍然在范围内甚至封闭函数之外。</p>

<p>需要注意的是，在严格模式下（即使用 use strict），语句var a = b = 3; 将生成ReferenceError: b is not defined的运行时错误，从而避免任何否则可能会导致的headfakes /bug。 （还是你为什么应该理所当然地在代码中使用 use strict 的最好例子！）</p>

<p>3.下面的代码将输出什么到控制台，为什么？</p>

<p>var myObject = {</p>

<p>foo: "bar",</p>

<p>func: function() {</p>

<p>var self = this;</p>

<p>console.log("outer func: this.foo = " + this.foo);</p>

<p>console.log("outer func: self.foo = " + self.foo);</p>

<p>(function() {</p>

<p>console.log("inner func: this.foo = " + this.foo);</p>

<p>console.log("inner func: self.foo = " + self.foo);</p>

<p>}());</p>

<p>}</p>

<p>};</p>

<p>myObject.func();</p>

<p>上面的代码将输出以下内容到控制台：</p>

<p>outer func: this.foo = bar</p>

<p>outer func: self.foo = bar</p>

<p>inner func: this.foo = undefined</p>

<p>inner func: self.foo = bar</p>

<p>在外部函数中， this 和self 两者都指向了 myObject，因此两者都可以正确地引用和访问 foo。</p>

<p>在内部函数中， this 不再指向 myObject。其结果是，this.foo 没有在内部函数中被定义，相反，指向到本地的变量self 保持在范围内，并且可以访问。 （在ECMA 5之前，在内部函数中的this 将指向全局的 window 对象；反之，因为作为ECMA 5，内部函数中的功能this 是未定义的。）</p>

<p>4.封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？</p>

<p>这是一个越来越普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）采用。这种技术创建了一个围绕文件全部内容的闭包，也许是最重要的是，创建了一个私有的命名空间，从而有助于避免不同JavaScript模块和库之间潜在的名称冲突。</p>

<p>这种技术的另一个特点是，允许一个易于引用的（假设更短的）别名用于全局变量。这通常用于，例如，jQuery插件中。jQuery允许你使用jQuery.noConflict()，来禁用 $ 引用到jQuery命名空间。在完成这项工作之后，你的代码仍然可以使用$ 利用这种闭包技术，如下所示：</p>

<p>(function($) { /* jQuery plugin code referencing $ */ } )(jQuery);</p>

<p>5.在JavaScript源文件的开头包含 use strict 有什么意义和好处？</p>

<p>对于这个问题，既简要又最重要的答案是，use strict 是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常。通常而言，这是一个很好的做法。</p>

<p>严格模式的一些主要优点包括：</p>

<p>使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。</p>

<p>防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。</p>

<p>消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 this 值会抛出错误。</p>

<p>不允许重复的属性名称或参数值。当检测到对象（例如，var object = {foo: "bar", foo: "baz"};）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1){}）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。</p>

<p>使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。</p>

<p>在 delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。</p>

<p>6.考虑以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同？</p>

<p>function foo1()</p>

<p>{</p>

<p>return {</p>

<p>bar: "hello"</p>

<p>};</p>

<p>}</p>

<p>function foo2()</p>

<p>{</p>

<p>return</p>

<p>{</p>

<p>bar: "hello"</p>

<p>};</p>

<p>}</p>

<p>出人意料的是，这两个函数返回的内容并不相同。更确切地说是：</p>

<p>console.log("foo1 returns:");</p>

<p>console.log(foo1());</p>

<p>console.log("foo2 returns:");</p>

<p>console.log(foo2());</p>

<p>将产生：</p>

<p>foo1 returns:</p>

<p>Object {bar: "hello"}</p>

<p>foo2 returns:</p>

<p>undefined</p>

<p>这不仅是令人惊讶，而且特别让人困惑的是， foo2()返回undefined却没有任何错误抛出。</p>

<p>原因与这样一个事实有关，即分号在JavaScript中是一个可选项（尽管省略它们通常是非常糟糕的形式）。其结果就是，当碰到 foo2()中包含 return语句的代码行（代码行上没有其他任何代码），分号会立即自动插入到返回语句之后。</p>

<p>也不会抛出错误，因为代码的其余部分是完全有效的，即使它没有得到调用或做任何事情（相当于它就是是一个未使用的代码块，定义了等同于字符串 "hello"的属性 bar）。</p>

<p>这种行为也支持放置左括号于JavaScript代码行的末尾，而不是新代码行开头的约定。正如这里所示，这不仅仅只是JavaScript中的一个风格偏好。</p>

<p>7. NaN 是什么？它的类型是什么？你如何可靠地测试一个值是否等于 NaN ？</p>

<p>NaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如， "abc" / 4），要么是因为运算的结果非数字（例如，除数为零）。</p>

<p>虽然这看上去很简单，但 NaN 有一些令人惊讶的特点，如果你不知道它们的话，可能会导致令人头痛的bug。</p>

<p>首先，虽然 NaN 意味着“不是数字”，但是它的类型，不管你信不信，是 Number：</p>

<p>console.log(typeof NaN === "number"); // logs "true"</p>

<p>此外， NaN 和任何东西比较——甚至是它自己本身！——结果是false：</p>

<p>console.log(NaN === NaN); // logs "false"</p>

<p>一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数 isNaN()，但即使使用 isNaN() 依然并非是一个完美的解决方案。</p>

<p>一个更好的解决办法是使用 value !== value，如果值等于NaN，只会产生true。另外，ES6提供了一个新的 Number.isNaN() 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。</p>

<p>8.下列代码将输出什么？并解释原因。</p>

<p>console.log(0.1 + 0.2);</p>

<p>console.log(0.1 + 0.2 == 0.3);</p>

<p>一个稍微有点编程基础的回答是：“你不能确定。可能会输出“0.3”和“true”，也可能不会。JavaScript中的数字和浮点精度的处理相同，因此，可能不会总是产生预期的结果。“</p>

<p>以上所提供的例子就是一个演示了这个问题的典型例子。但出人意料的是，它会输出：</p>

<p>0.30000000000000004</p>

<p>false</p>

<p>9.讨论写函数 isInteger(x) 的可能方法，用于确定x是否是整数。</p>

<p>这可能听起来是小菜一碟，但事实上，这很琐碎，因为ECMAScript 6引入了一个新的正以此为目的 Number.isInteger() 函数。然而，之前的ECMAScript 6，会更复杂一点，因为没有提供类似的 Number.isInteger() 方法。</p>

<p>问题是，在ECMAScript规格说明中，整数只概念上存在：即，数字值总是存储为浮点值。</p>

<p>考虑到这一点，最简单又最干净的ECMAScript6之前的解决方法（同时也非常稳健地返回 false ，即使一个非数字的值，如字符串或 null ，被传递给函数）如下：</p>

<p>function isInteger(x) { return (x^0) === x; }</p>

<p>下面的解决方法也是可行的，虽然不如上面那个方法优雅：</p>

<p>function isInteger(x) { return Math.round(x) === x; }</p>

<p>请注意 Math.ceil() 和 Math.floor() 在上面的实现中等同于 Math.round()。</p>

<p>或：</p>

<p>function isInteger(x) { return (typeof x === 'number') && (x % 1 === 0);</p>

<p>相当普遍的一个不正确的解决方案是：</p>

<p>function isInteger(x) { return parseInt(x, 10) === x; }</p>

<p>虽然这个以 parseInt函数为基础的方法在 x 取许多值时都能工作良好，但一旦 x 取值相当大的时候，就会无法正常工作。问题在于 parseInt() 在解析数字之前强制其第一个参数到字符串。因此，一旦数目变得足够大，它的字符串就会表达为指数形式（例如， 1e+21）。因此，parseInt() 函数就会去解析 1e+21，但当到达 e字符串的时候，就会停止解析，因此只会返回值 1。注意：</p>

<p>&gt; String(1000000000000000000000)</p>

<p>'1e+21'</p>

<p>&gt; parseInt(1000000000000000000000, 10)</p>

<p>1</p>

<p>&gt; parseInt(1000000000000000000000, 10) === 1000000000000000000000</p>

<p>false</p>

<p>10.下列代码行1-4如何排序，使之能够在执行代码时输出到控制台？ 为什么？</p>

<p>(function() {</p>

<p>console.log(1);</p>

<p>setTimeout(function(){console.log(2)}, 1000);</p>

<p>setTimeout(function(){console.log(3)}, 0);</p>

<p>console.log(4);</p>

<p>})();</p>

<p>序号如下：</p>

<p>1</p>

<p>4</p>

<p>3</p>

<p>2</p>

<p>让我们先来解释比较明显而易见的那部分：</p>

<p>1 和 4之所以放在前面，是因为它们是通过简单调用 console.log() 而没有任何延迟输出的</p>

<p>2 之所以放在 3的后面，是因为 2 是延迟了1000毫秒（即，1秒）之后输出的，而 3 是延迟了0毫秒之后输出的。</p>

<p>好的。但是，既然 3 是0毫秒延迟之后输出的，那么是否意味着它是立即输出的呢？如果是的话，那么它是不是应该在 4 之前输出，既然 4 是在第二行输出的？</p>

<p>要回答这个问题，你需要正确理解JavaScript的事件和时间设置。</p>

<p>浏览器有一个事件循环，会检查事件队列和处理未完成的事件。例如，如果时间发生在后台（例如，脚本的 onload 事件）时，浏览器正忙（例如，处理一个 onclick），那么事件会添加到队列中。当onclick处理程序完成后，检查队列，然后处理该事件（例如，执行 onload 脚本）。</p>

<p>同样的， setTimeout() 也会把其引用的函数的执行放到事件队列中，如果浏览器正忙的话。</p>

<p>当setTimeout()的第二个参数为0的时候，它的意思是“尽快”执行指定的函数。具体而言，函数的执行会放置在事件队列的下一个计时器开始。但是请注意，这不是立即执行：函数不会被执行除非下一个计时器开始。这就是为什么在上述的例子中，调用 console.log(4) 发生在调用 console.log(3) 之前（因为调用 console.log(3) 是通过setTimeout被调用的，因此会稍微延迟）。</p>

<p>11.写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。</p>

<p>下面这个函数在 str 是回文结构的时候返回true，否则，返回false。</p>

<p>function isPalindrome(str) {</p>

<p>str = str.replace(/W/g, '').toLowerCase();</p>

<p>return (str == str.split('').reverse().join(''));</p>

<p>}</p>

<p>例如：</p>

<p>console.log(isPalindrome("level")); // logs 'true'</p>

<p>console.log(isPalindrome("levels")); // logs 'false'</p>

<p>console.log(isPalindrome("A car, a man, a maraca")); // logs 'true'</p>

<p>12.写一个 sum方法，在使用下面任一语法调用时，都可以正常工作。</p>

<p>console.log(sum(2,3)); // Outputs 5</p>

<p>console.log(sum(2)(3)); // Outputs 5</p>

<p>（至少）有两种方法可以做到：</p>

<p>方法1</p>

<p>function sum(x) {</p>

<p>if (arguments.length == 2) {</p>

<p>return arguments[0] + arguments[1];</p>

<p>} else {</p>

<p>return function(y) { return x + y; };</p>

<p>}</p>

<p>}</p>

<p>在JavaScript中，函数可以提供到 arguments 对象的访问，arguments 对象提供传递到函数的实际参数的访问。这使我们能够使用 length 属性来确定在运行时传递给函数的参数数量。</p>

<p>如果传递两个参数，那么只需加在一起，并返回。</p>

<p>否则，我们假设它被以 sum(2)(3)这样的形式调用，所以我们返回一个匿名函数，这个匿名函数合并了传递到 sum()的参数和传递给匿名函数的参数。</p>

<p>方法2</p>

<p>function sum(x, y) {</p>

<p>if (y !== undefined) {</p>

<p>return x + y;</p>

<p>} else {</p>

<p>return function(y) { return x + y; };</p>

<p>}</p>

<p>}</p>

<p>当调用一个函数的时候，JavaScript不要求参数的数目匹配函数定义中的参数数量。如果传递的参数数量大于函数定义中参数数量，那么多余参数将简单地被忽略。另一方面，如果传递的参数数量小于函数定义中的参数数量，那么缺少的参数在函数中被引用时将会给一个 undefined值。所以，在上面的例子中，简单地检查第2个参数是否未定义，就可以相应地确定函数被调用以及进行的方式。</p>

<p>13.请看下面的代码片段：</p>

<p>for (var i = 0; i &lt; 5; i++) {</p>

<p>var btn = document.createElement('button');</p>

<p>btn.appendChild(document.createTextNode('Button ' + i));</p>

<p>btn.addEventListener('click', function(){ console.log(i); });</p>

<p>document.body.appendChild(btn);</p>

<p>}</p>

<p>（a）当用户点击“Button 4”的时候会输出什么到控制台，为什么？（b）提供一个或多个备用的可按预期工作的实现方案。</p>

<p>（a）无论用户点击什么按钮，数字5将总会输出到控制台。这是因为，当 onclick 方法被调用（对于任何按钮）的时候， for 循环已经结束，变量 i 已经获得了5的值。（面试者如果能够谈一谈有关如何执行上下文，可变对象，激活对象和内部“范围”属性贡有助于闭包行为，则可以加分）。</p>

<p>（b）要让代码工作的关键是，通过传递到一个新创建的函数对象，在每次传递通过 for 循环时，捕捉到 i 值。下面是三种可能实现的方法：</p>

<p>for (var i = 0; i &lt; 5; i++) {</p>

<p>var btn = document.createElement('button');</p>

<p>btn.appendChild(document.createTextNode('Button ' + i));</p>

<p>btn.addEventListener('click', (function(i) {</p>

<p>return function() { console.log(i); };</p>

<p>})(i));</p>

<p>document.body.appendChild(btn);</p>

<p>}</p>

<p>或者，你可以封装全部调用到在新匿名函数中的 btn.addEventListener ：</p>

<p>for (var i = 0; i &lt; 5; i++) {</p>

<p>var btn = document.createElement('button');</p>

<p>btn.appendChild(document.createTextNode('Button ' + i));</p>

<p>(function (i) {</p>

<p>btn.addEventListener('click', function() { console.log(i); });</p>

<p>})(i);</p>

<p>document.body.appendChild(btn);</p>

<p>}</p>

<p>也可以调用数组对象的本地 forEach 方法来替代 for 循环：</p>

<p>['a', 'b', 'c', 'd', 'e'].forEach(function (value, i) {</p>

<p>var btn = document.createElement('button');</p>

<p>btn.appendChild(document.createTextNode('Button ' + i));</p>

<p>btn.addEventListener('click', function() { console.log(i); });</p>

<p>document.body.appendChild(btn);</p>

<p>});</p>

<p>14.下面的代码将输出什么到控制台，为什么？</p>

<p>var arr1 = "john".split('');</p>

<p>var arr2 = arr1.reverse();</p>

<p>var arr3 = "jones".split('');</p>

<p>arr2.push(arr3);</p>

<p>console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));</p>

<p>console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1));</p>

<p>输出结果是：</p>

<p>"array 1: length=5 last=j,o,n,e,s"</p>

<p>"array 2: length=5 last=j,o,n,e,s"</p>

<p>arr1 和 arr2 在上述代码执行之后，两者相同了，原因是：</p>

<p>调用数组对象的 reverse() 方法并不只返回反顺序的阵列，它也反转了数组本身的顺序（即，在这种情况下，指的是 arr1）。</p>

<p>reverse() 方法返回一个到数组本身的引用（在这种情况下即，arr1）。其结果为，arr2 仅仅是一个到 arr1的引用（而不是副本）。因此，当对 arr2做了任何事情（即当我们调用 arr2.push(arr3);）时，arr1 也会受到影响，因为 arr1 和 arr2 引用的是同一个对象。</p>

<p>这里有几个侧面点有时候会让你在回答这个问题时，阴沟里翻船：</p>

<p>传递数组到另一个数组的 push() 方法会让整个数组作为单个元素映射到数组的末端。其结果是，语句 arr2.push(arr3); 在其整体中添加 arr3 作为一个单一的元素到 arr2 的末端（也就是说，它并没有连接两个数组，连接数组是 concat() 方法的目的）。</p>

<p>和Python一样，JavaScript标榜数组方法调用中的负数下标，例如 slice() 可作为引用数组末尾元素的方法：例如，-1下标表示数组中的最后一个元素，等等。</p>

<p>15.下面的代码将输出什么到控制台，为什么？</p>

<p>console.log(1 + "2" + "2");</p>

<p>console.log(1 + +"2" + "2");</p>

<p>console.log(1 + -"1" + "2");</p>

<p>console.log(+"1" + "1" + "2");</p>

<p>console.log( "A" - "B" + "2");</p>

<p>console.log( "A" - "B" + 2);</p>

<p>上面的代码将输出以下内容到控制台：</p>

<p>"122"</p>

<p>"32"</p>

<p>"02"</p>

<p>"112"</p>

<p>"NaN2"</p>

<p>NaN</p>

<p>原因是…</p>

<p>这里的根本问题是，JavaScript（ECMAScript）是一种弱类型语言，它可对值进行自动类型转换，以适应正在执行的操作。让我们通过上面的例子来说明这是如何做到的。</p>

<p>例1：1 + "2" + "2" 输出："122" 说明： 1 + "2" 是执行的第一个操作。由于其中一个运算对象（"2"）是字符串，JavaScript会假设它需要执行字符串连接，因此，会将 1 的类型转换为 "1"， 1 + "2"结果就是 "12"。然后， "12" + "2" 就是 "122"。</p>

<p>例2： 1 + +"2" + "2" 输出： "32" 说明：根据运算的顺序，要执行的第一个运算是 +"2"（第一个 "2" 前面的额外 + 被视为一元运算符）。因此，JavaScript将 "2" 的类型转换为数字，然后应用一元 + 号（即，将其视为一个正数）。其结果是，接下来的运算就是 1 + 2 ，这当然是 3。然后我们需要在一个数字和一个字符串之间进行运算（即， 3 和 "2"），同样的，JavaScript会将数值类型转换为字符串，并执行字符串的连接，产生 "32"。</p>

<p>例3： 1 + -"1" + "2" 输出： "02" 说明：这里的解释和前一个例子相同，除了此处的一元运算符是 - 而不是 +。先是 "1" 变为 1，然后当应用 - 时又变为了 -1 ，然后将其与 1相加，结果为 0，再将其转换为字符串，连接最后的 "2" 运算对象，得到 "02"。</p>

<p>例4： +"1" + "1" + "2" 输出： "112" 说明：虽然第一个运算对象 "1"因为前缀的一元 + 运算符类型转换为数值，但又立即转换回字符串，当连接到第二个运算对象 "1" 的时候，然后又和最后的运算对象"2" 连接，产生了字符串 "112"。</p>

<p>例5： "A" - "B" + "2" 输出： "NaN2" 说明：由于运算符 - 不能被应用于字符串，并且 "A" 和 "B" 都不能转换成数值，因此，"A" - "B"的结果是 NaN，然后再和字符串 "2" 连接，得到 "NaN2" 。</p>

<p>例6： "A" - "B" + 2 输出： NaN 说明：参见前一个例子， "A" - "B" 结果为 NaN。但是，应用任何运算符到NaN与其他任何的数字运算对象，结果仍然是 NaN。</p>

<p>16.下面的递归代码在数组列表偏大的情况下会导致堆栈溢出。在保留递归模式的基础上，你怎么解决这个问题？</p>

<p>var list = readHugeList();</p>

<p>var nextListItem = function() {</p>

<p>var item = list.pop();</p>

<p>if (item) {</p>

<p>// process the list item...</p>

<p>nextListItem();</p>

<p>}</p>

<p>};</p>

<p>潜在的堆栈溢出可以通过修改nextListItem 函数避免：</p>

<p>var list = readHugeList();</p>

<p>var nextListItem = function() {</p>

<p>var item = list.pop();</p>

<p>if (item) {</p>

<p>// process the list item...</p>

<p>setTimeout( nextListItem, 0);</p>

<p>}</p>

<p>};</p>

<p>堆栈溢出之所以会被消除，是因为事件循环操纵了递归，而不是调用堆栈。当 nextListItem 运行时，如果 item不为空，timeout函数（nextListItem）就会被推到事件队列，该函数退出，因此就清空调用堆栈。当事件队列运行其timeout事件，且进行到下一个 item 时，定时器被设置为再次调用 nextListItem。因此，该方法从头到尾都没有直接的递归调用，所以无论迭代次数的多少，调用堆栈保持清空的状态。</p>

<p>17.JavaScript中的“闭包”是什么？请举一个例子。</p>

<p>闭包是一个可以访问外部（封闭）函数作用域链中的变量的内部函数。闭包可以访问三种范围中的变量：这三个范围具体为：（1）自己范围内的变量，（2）封闭函数范围内的变量，以及（3）全局变量。</p>

<p>下面是一个简单的例子：</p>

<p>var globalVar = "xyz";</p>

<p>(function outerFunc(outerArg) {</p>

<p>var outerVar = 'a';</p>

<p>(function innerFunc(innerArg) {</p>

<p>var innerVar = 'b';</p>

<p>console.log(</p>

<p>"outerArg = " + outerArg + " " +</p>

<p>"innerArg = " + innerArg + " " +</p>

<p>"outerVar = " + outerVar + " " +</p>

<p>"innerVar = " + innerVar + " " +</p>

<p>"globalVar = " + globalVar);</p>

<p>})(456);</p>

<p>})(123);</p>

<p>在上面的例子中，来自于 innerFunc， outerFunc和全局命名空间的变量都在 innerFunc的范围内。因此，上面的代码将输出如下：</p>

<p>outerArg = 123</p>

<p>innerArg = 456</p>

<p>outerVar = a</p>

<p>innerVar = b</p>

<p>globalVar = xyz</p>

<p>18.下面的代码将输出什么：</p>

<p>for (var i = 0; i &lt; 5; i++) {</p>

<p>setTimeout(function() { console.log(i); }, i * 1000 );</p>

<p>}</p>

<p>解释你的答案。闭包在这里能起什么作用？</p>

<p>上面的代码不会按预期显示值0，1，2，3，和4，而是会显示5，5，5，5，和5。</p>

<p>原因是，在循环中执行的每个函数将整个循环完成之后被执行，因此，将会引用存储在 i中的最后一个值，那就是5。</p>

<p>闭包可以通过为每次迭代创建一个唯一的范围，存储范围内变量的每个唯一的值，来防止这个问题，如下：</p>

<p>for (var i = 0; i &lt; 5; i++) {</p>

<p>(function(x) {</p>

<p>setTimeout(function() { console.log(x); }, x * 1000 );</p>

<p>})(i);</p>

<p>}</p>

<p>这就会按预期输出0，1，2，3，和4到控制台。</p>

<p>19.以下代码行将输出什么到控制台？</p>

<p>console.log("0 || 1 = "+(0 || 1));</p>

<p>console.log("1 || 2 = "+(1 || 2));</p>

<p>console.log("0 && 1 = "+(0 && 1));</p>

<p>console.log("1 && 2 = "+(1 && 2));</p>

<p>并解释。</p>

<p>该代码将输出：</p>

<p>0 || 1 = 1</p>

<p>1 || 2 = 1</p>

<p>0 && 1 = 0</p>

<p>1 && 2 = 2</p>

<p>在JavaScript中， || 和 &&都是逻辑运算符，用于在从左至右计算时，返回第一个可完全确定的“逻辑值”。</p>

<p>或（ || ）运算符。在形如 X||Y的表达式中，首先计算X 并将其解释执行为一个布尔值。如果这个布尔值true，那么返回true（1），不再计算 Y，因为“或”的条件已经满足。如果这个布尔值为false，那么我们仍然不能知道 X||Y是真是假，直到我们计算 Y，并且也把它解释执行为一个布尔值。</p>

<p>因此， 0 || 1 的计算结果为true（1），同理计算1 || 2。</p>

<p>与（ &&）运算符。在形如 X&&Y的表达式中，首先计算 X并将其解释执行为一个布尔值。如果这个布尔值为 false，那么返回 false（0），不再计算 Y，因为“与”的条件已经失败。如果这个布尔值为true，但是，我们仍然不知道 X&&Y 是真是假，直到我们去计算 Y，并且也把它解释执行为一个布尔值。</p>

<p>不过，关于 &&运算符有趣的地方在于，当一个表达式计算为“true”的时候，那么就返回表达式本身。这很好，虽然它在逻辑表达式方面计算为“真”，但如果你希望的话也可用于返回该值。这就解释了为什么，有些令人奇怪的是， 1 && 2返回 2（而不是你以为的可能返回 true 或 1）。</p>

<p>20.执行下面的代码时将输出什么？请解释。</p>

<p>console.log(false == '0')</p>

<p>console.log(false === '0')</p>

<p>代码将输出：</p>

<p>true</p>

<p>false</p>

<p>在JavaScript中，有两种等式运算符。三个等于运算符 === 的作用类似传统的等于运算符：如果两侧的表达式有着相同的类型和相同的值，那么计算结果为true。而双等于运算符，会只强制比较它们的值。因此，总体上而言，使用 ===而不是 ==的做法更好。 !==vs !=亦是同理。</p>

<p>21.以下代码将输出什么？并解释你的答案。</p>

<p>var a={},</p>

<p>b={key:'b'},</p>

<p>c={key:'c'};</p>

<p>a[b]=123;</p>

<p>a[c]=456;</p>

<p>console.log(a[b]);</p>

<p>这段代码将输出 456（而不是 123）。</p>

<p>原因为：当设置对象属性时，JavaScript会暗中字符串化参数值。在这种情况下，由于 b 和 c都是对象，因此它们都将被转换为"[object Object]"。结果就是， a[b]和a[c]均相当于a["[object Object]"] ，并可以互换使用。因此，设置或引用 a[c]和设置或引用 a[b]完全相同。</p>

<p>22.以下代码行将输出什么到控制台？</p>

<p>console.log((function f(n){return ((n &gt; 1) ? n * f(n-1) : n)})(10));</p>

<p>并解释你的答案。</p>

<p>代码将输出10！的值（即10！或3628800）。</p>

<p>原因是：</p>

<p>命名函数 f()递归地调用本身，当调用 f(1)的时候，只简单地返回1。下面就是它的调用过程：</p>

<p>f(1): returns n, which is 1</p>

<p>f(2): returns 2 * f(1), which is 2</p>

<p>f(3): returns 3 * f(2), which is 6</p>

<p>f(4): returns 4 * f(3), which is 24</p>

<p>f(5): returns 5 * f(4), which is 120</p>

<p>f(6): returns 6 * f(5), which is 720</p>

<p>f(7): returns 7 * f(6), which is 5040</p>

<p>f(8): returns 8 * f(7), which is 40320</p>

<p>f(9): returns 9 * f(8), which is 362880</p>

<p>f(10): returns 10 * f(9), which is 3628800</p>

<p>23.请看下面的代码段。控制台将输出什么，为什么？</p>

<p>(function(x) {</p>

<p>return (function(y) {</p>

<p>console.log(x);</p>

<p>})(2)</p>

<p>})(1);</p>

<p>控制台将输出 1，即使从来没有在函数内部设置过x的值。原因是：</p>

<p>正如我们在JavaScript招聘指南中解释过的那样，闭包是一个函数，连同在闭包创建的时候，其范围内的所有变量或函数一起。在JavaScript中，闭包是作为一个“内部函数”实施的：即，另一个函数主体内定义的函数。闭包的一个重要特征是，内部函数仍然有权访问外部函数的变量。</p>

<p>因此，在本例中，由于 x未在函数内部中定义，因此在外部函数范围中搜索定义的变量 x，且被发现具有1的值。</p>

<p>24.下面的代码将输出什么到控制台，为什么：</p>

<p>var hero = {</p>

<p>_name: 'John Doe',</p>

<p>getSecretIdentity: function (){</p>

<p>return this._name;</p>

<p>}</p>

<p>};</p>

<p>var stoleSecretIdentity = hero.getSecretIdentity;</p>

<p>console.log(stoleSecretIdentity());</p>

<p>console.log(hero.getSecretIdentity());</p>

<p>代码有什么问题，以及应该如何修复。</p>

<p>代码将输出：</p>

<p>undefined</p>

<p>John Doe</p>

<p>第一个 console.log之所以输出 undefined，是因为我们正在从 hero对象提取方法，所以调用了全局上下文中（即窗口对象）的 stoleSecretIdentity()，而在此全局上下文中， _name属性不存在。</p>

<p>其中一种修复stoleSecretIdentity() 函数的方法如下：</p>

<p>var stoleSecretIdentity = hero.getSecretIdentity.bind(hero);</p>

<p>25.创建一个给定页面上的一个DOM元素，就会去访问元素本身及其所有子元素（不只是它的直接子元素）的函数。对于每个被访问的元素，函数应该传递元素到提供的回调函数。</p>

<p>此函数的参数为：</p>

<p>DOM元素</p>

<p>回调函数（将DOM元素作为其参数）</p>

<p>访问树（DOM）的所有元素是经典的深度优先搜索算法应用。下面是一个示范的解决方案：</p>

<p>function Traverse(p_element,p_callback) {</p>

<p>p_callback(p_element);</p>

<p>var list = p_element.children;</p>

<p>for (var i = 0; i &lt; list.length; i++) {</p>

<p>Traverse(list[i],p_callback); // recursive call</p>

<p>}</p>

<p>}</p>



<p style='float:right;'>本页共398段，15957个字符，29757 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
