<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>﻿Python快速入门</h4>

<p>Python 是一种高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 由 Guido van Rossum 于 1989 年底在荷兰国家数学和计算机科学研究所发明，第一个公开发行版发行于 1991 年。</p>

<h4>特点</h4>
<p>易于学习：Python 有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</p>

<p>易于阅读：Python 代码定义的更清晰。</p>

<p>易于维护：Python 的成功在于它的源代码是相当容易维护的。</p>

<p>一个广泛的标准库：Python 的最大的优势之一是丰富的库，跨平台的，在 UNIX，Windows 和 macOS 兼容很好。</p>

<p>互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</p>

<p>可移植：基于其开放源代码的特性，Python 已经被移植（也就是使其工作）到许多平台。</p>

<p>可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用 C 或 C++ 完成那部分程序，然后从你的 Python 程序中调用。</p>

<p>数据库：Python 提供所有主要的商业数据库的接口。</p>

<p>GUI 编程：Python 支持 GUI 可以创建和移植到许多系统调用。</p>

<p>可嵌入：你可以将 Python 嵌入到 C/C++ 程序，让你的程序的用户获得”脚本化”的能力。</p>

<p>面向对象：Python 是强面向对象的语言，程序中任何内容统称为对象，包括数字、字符串、函数等。</p>

<h4>基础语法</h4>
<p>运行 Python</p>

<p>交互式解释器</p>

<p>在命令行窗口执行 python 后，进入 Python 的交互式解释器。 exit() 或 Ctrl + D 组合键退出交互式解释器。</p>

<p>命令行脚本</p>

<p>在命令行窗口执行 python script-file.py ，以执行 Python 脚本文件。</p>

<p>指定解释器</p>

<p>如果在 Python 脚本文件首行输入 #!/usr/bin/env python ，那么可以在命令行窗口中执行 /path/to/script-file.py 以执行该脚本文件。</p>

<p>注：该方法不支持 Windows 环境。</p>

<h4>编码</h4>
<p>默认情况下，3.x 源码文件都是 UTF-8 编码，字符串都是 Unicode 字符。也可以手动指定文件编码：</p>

<p># -*- coding: utf-8 -*-</p>

<p>或者</p>

<p># encoding: utf-8</p>

<p>注意: 该行标注必须位于文件第一行</p>

<h4>标识符</h4>
<p>注：从 3.x 开始，非 ASCII 标识符也是允许的，但不建议。</p>

<p>保留字</p>

<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p>

<p>>>> import keyword</p>

<p>>>> keyword.kwlist</p>

<p>['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</p>

<h4>注释</h4>
<p>单行注释采用 # ，多行注释采用 ''' 或 """ 。</p>

<p># 这是单行注释</p>

<p>'''</p>

<p>这是多行注释</p>

<p>这是多行注释</p>

<p>'''</p>

<p>"""</p>

<p>这也是多行注释</p>

<p>这也是多行注释</p>

<p>"""</p>

<h4>行与缩进</h4>
<p>Python 最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。缩进不一致，会导致运行错误。</p>

<h4>多行语句</h4>
<p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠来实现多行语句。</p>

<p>total = item_one +</p>

<p>item_two +</p>

<p>item_three</p>

<p>在 [] , {} , 或 () 中的多行语句，不需要使用反斜杠 。</p>

<h4>空行</h4>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>

<p>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>

<p>记住：空行也是程序代码的一部分。</p>

<h4>等待用户输入</h4>
<p>input 函数可以实现等待并接收命令行中的用户输入。</p>

<p>content = input(" 请输入点东西并按 Enter 键 ")</p>

<p>print(content)</p>

<h4>同一行写多条语句</h4>
<p>Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割。</p>

<p>import sys; x = 'hello world'; sys.stdout.write(x + ' ')</p>

<h4>多个语句构成代码组</h4>
<p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>

<p>像 if 、 while 、 def 和 class 这样的复合语句，首行以关键字开始，以冒号 : 结束，该行之后的一行或多行代码构成代码组。</p>

<p>我们将首行及后面的代码组称为一个子句(clause)。</p>

<h4>print 输出</h4>
<p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end="" 或别的非换行符字符串：</p>

<p>print('123') # 默认换行</p>

<p>print('123', end = "") # 不换行</p>

<h4>import 与 from…import</h4>
<p>在 Python 用 import 或者 from...import 来导入相应的模块。</p>

<p>将整个模块导入，格式为： import module_name</p>

<p>从某个模块中导入某个函数,格式为： from module_name import func1</p>

<p>从某个模块中导入多个函数,格式为： from module_name import func1, func2, func3</p>

<p>将某个模块中的全部函数导入，格式为： from module_name import *</p>

<h4>运算符</h4>
<p>算术运算符</p>

<p>+加-减*乘/除%取模**幂//取整除</p>

<p>比较运算符</p>

<p>==等于!=不等于>大于
  <小于>=大于等于<=小于等于</p>

<p>赋值运算符</p>

<p>运算符描述=简单的赋值运算符+=加法赋值运算符-=减法赋值运算符*=乘法赋值运算符/=除法赋值运算符%=取模赋值运算符**=幂赋值运算符//=取整除赋值运算符</p>

<p>位运算符</p>

<p>运算符描述&按位与运算符：参与运算的两个值,如果两个相应位都为1，则该位的结果为1，否则为0|按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1^按位异或运算符：当两对应的二进位相异时，结果为1~按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。~x 类似于 -x-1<<左移动运算符：运算数的各二进位全部左移若干位，由”<<“右边的数指定移动的位数，高位丢弃，低位补0>>右移动运算符：把”>>“左边的运算数的各二进位全部右移若干位，”>>“右边的数指定移动的位数</p>

<p>逻辑运算符</p>

<p>运算符逻辑表达式描述andx and y布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值orx or y布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值notnot x布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True</p>

<p>成员运算符</p>

<p>运算符描述in如果在指定的序列中找到值返回 True，否则返回 Falsenot in如果在指定的序列中没有找到值返回 True，否则返回 False</p>

<p>身份运算符</p>

<p>运算符描述实例isis 是判断两个标识符是不是引用自一个对象x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 Falseis notis not 是判断两个标识符是不是引用自不同对象x is not y ，类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False</p>

<h4>运算符优先级</h4>
<p>运算符描述(expressions...) , [expressions...] , {key: value...} , {expressions...}表示绑定或元组、表示列表、表示字典、表示集合x[index] , x[index:index] , x(arguments...) , x.attribute下标、切片、调用、属性引用**指数 (最高优先级)~ + -按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)* / % //乘，除，取模和取整除+ -加法减法>> <<右移，左移运算符&位 ‘AND’^ ``<= < > >=比较运算符<> == !=等于运算符= %= /= //= -= += *= **=赋值运算符is is not身份运算符in not in成员运算符and or not逻辑运算符if - else条件表达式lambdaLambda 表达式</p>

<p>具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。</p>

<h4>变量</h4>
<p>变量在使用前必须先”定义”（即赋予变量一个值），否则会报错：</p>

<p>>>> name</p>

<p>Traceback (most recent call last):</p>

<p>File "<stdin>", line 1, in <module></p>

<p>NameError: name 'name' is not defined</p>

<h4>数据类型</h4>
<p>布尔(bool)</p>

<p>只有 True 和 False 两个值，表示真或假。</p>

<p>数字(Number)</p>

<p>整型(int)</p>

<p>整数值，可正数亦可复数，无小数。 3.x 整型是没有限制大小的，可以当作 Long 类型使用，所以 3.x 没有 2.x 的 Long 类型。</p>

<p>浮点型(float)</p>

<p>浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 10^2 = 250）</p>

<p>复数(complex)</p>

<p>复数由实数部分和虚数部分构成，可以用 a + bj ，或者 complex(a,b) 表示，复数的实部 a 和虚部 b 都是浮点型。</p>

<h4>数字运算</h4>
<p>不同类型的数字混合运算时会将整数转换为浮点数</p>

<p>在不同的机器上浮点运算的结果可能会不一样</p>

<p>在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 // 。</p>

<p>// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系</p>

<p>在交互模式中，最后被输出的表达式结果被赋值给变量 _ ， _ 是个只读变量</p>

<h4>数学函数</h4>
<p>注：以下函数的使用，需先导入 math 包。</p>

<p>函数描述abs(x)返回数字的整型绝对值，如 abs(-10) 返回 10ceil(x)返回数字的上入整数，如 math.ceil(4.1) 返回 5cmp(x, y)如果 x < y 返回 -1，如果 x == y 返回 0，如果 x > y 返回 1。 Python 3 已废弃 。使用使用 (x>y)-(x<y) 替换。exp(x)返回 e 的 x 次幂(ex)，如 math.exp(1) 返回2.718281828459045fabs(x)返回数字的浮点数绝对值，如 math.fabs(-10) 返回10.0floor(x)返回数字的下舍整数，如 math.floor(4.9) 返回 4log(x)如 math.log(math.e) 返回 1.0， math.log(100,10) 返回 2.0log10(x)返回以 10 为基数的 x 的对数，如 math.log10(100) 返回 2.0max(x1, x2,…)返回给定参数的最大值，参数可以为序列min(x1, x2,…)返回给定参数的最小值，参数可以为序列modf(x)返回 x 的整数部分与小数部分，两部分的数值符号与 x 相同，整数部分以浮点型表示pow(x, y)幂等函数， x**y 运算后的值round(x [,n])返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数sqrt(x)返回数字 x 的平方根</p>

<h4>随机数函数</h4>
<p>注：以下函数的使用，需先导入 random 包。</p>

<p>函数描述choice(seq)从序列的元素中随机挑选一个元素，比如 random.choice(range(10)) ，从0到9中随机挑选一个整数randrange ([start,] stop [,step])从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1random()随机生成下一个实数，它在 [0,1) 范围内seed([x])改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seedshuffle(lst)将序列的所有元素随机排序uniform(x, y)随机生成下一个实数，它在 [x,y] 范围内</p>

<h4>三角函数</h4>
<p>注：以下函数的使用，需先导入 math 包。</p>

<p>函数描述acos(x)返回 x 的反余弦弧度值asin(x)返回 x 的反正弦弧度值atan(x)返回 x 的反正切弧度值atan2(y, x)返回给定的 X 及 Y 坐标值的反正切值cos(x)返回 x 的弧度的余弦值hypot(x, y)返回欧几里德范数 sqrt(x*x + y*y)sin(x)返回的 x 弧度的正弦值tan(x)返回 x 弧度的正切值degrees(x)将弧度转换为角度，如 degrees(math.pi/2) 返回 90.0radians(x)将角度转换为弧度</p>

<h4>数学常量</h4>
<p>常量描述pi数学常量 pi（圆周率，一般以π来表示）e数学常量 e，e 即自然常数（自然常数）</p>

<h4>字符串(String)</h4>
<p>单引号和双引号使用完全相同</p>

<p>使用三引号( ''' 或 """ )可以指定一个多行字符串</p>

<p>转义符(反斜杠 )可以用来转义，使用 r 可以让反斜杠不发生转义，如 r"this is a line with " ，则会显示，并不是换行</p>

<p>按字面意义级联字符串，如 "this " "is " "string" 会被自动转换为 this is string</p>

<p>字符串可以用 + 运算符连接在一起，用 * 运算符重复</p>

<p>字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始</p>

<p>字符串不能改变</p>

<p>没有单独的字符类型，一个字符就是长度为 1 的字符串</p>

<p>字符串的截取的语法格式如下： 变量[头下标:尾下标]</p>

<p>转义字符</p>

<p>转义字符描述在行尾时，续行符\反斜杠符号‘单引号“双引号a响铃退格(Backspace)e转义空换行纵向制表符横向制表符回车换页oyy八进制数，yy代表字符，例如：o12代表换行\xyy十六进制数，yy代表字符，例如：\x0a代表换行other其它的字符以普通格式输出</p>

<p>字符串运算符</p>

<p>操作符描述实例+字符串连接'Hello' + 'Python' 输出结果：’HelloPython’*重复输出字符串'Hello' * 2 输出结果：’HelloHello’[]通过索引获取字符串中字符'Hello'[1] 输出结果 e[ : ]截取字符串中的一部分'Hello'[1:4] 输出结果 ellin成员运算符，如果字符串中包含给定的字符返回 True'H' in 'Hello' 输出结果 Truenot in成员运算符，如果字符串中不包含给定的字符返回 True'M' not in 'Hello' 输出结果 Truer/R原始字符串，所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法print(r' ') 或 print(R' ')%格式化字符串</p>

<p>字符串格式化</p>

<p>在 Python 中，字符串格式化不是 sprintf 函数，而是用 % 符号。例如：</p>

<p>print("我叫%s，今年 %d 岁！" % ('小明', 10))</p>

<p>// 输出:</p>

<p>我叫小明，今年 10 岁！</p>

<p>格式化符号:</p>

<p>符号描述%c格式化字符及其 ASCII 码%s格式化字符串%d格式化整数%u格式化无符号整型%o格式化无符号八进制数%x格式化无符号十六进制数%X格式化无符号十六进制数（大写）%f格式化浮点数字，可指定小数点后的精度%e用科学计数法格式化浮点数%E作用同 %e，用科学计数法格式化浮点数%g%f 和 %e 的简写%G%f 和 %E 的简写%p用十六进制数格式化变量的地址</p>

<p>辅助指令:</p>

<p>指令描述*定义宽度或者小数点精度-用做左对齐+在正数前面显示加号在正数前面显示空格#在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)0显示的数字前面填充’0’而不是默认的空格%’%%‘输出一个单一的’%’(var)映射变量(字典参数)m.n.m 是显示的最小总宽度，n 是小数点后的位数(如果可用的话)</p>

<p>Python 2.6 开始，新增了一种格式化字符串的函数 str.format() ，它增强了字符串格式化的功能。</p>

<p>多行字符串</p>

<p>用三引号( ''' 或 """ )包裹字符串内容</p>

<p>多行字符串内容支持转义符，用法与单双引号一样</p>

<p>三引号包裹的内容，有变量接收或操作即字符串，否则就是多行注释</p>

<p>实例：</p>

<p>string = '''</p>

<p>print(	math.fabs(-10))</p>

<p>print( random.choice(li))</p>

<p>'''</p>

<p>print(string)</p>

<p>输出：</p>

<p>print( math.fabs(-10))</p>

<p>print(</p>

<p>random.choice(li))</p>

<p>Unicode</p>

<p>在 2.x 中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 Unicode 字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u 。</p>

<p>在 3.x 中，所有的字符串都是 Unicode 字符串。</p>

<h4>字符串函数</h4>
<p>str.capitalize()首字母大写，其余字符小写</p>
<p>str.center(width[, fillchar])返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格</p>
<p>str.count(sub, start= 0,end=len(string))统计子字符串在字符串中出现的次数</p>
<p>str.encode(encoding=‘UTF-8’,errors=‘strict’)以指定的编码格式编码字符串，返回 bytes 对象</p>
<p>bytes.decode(encoding=“utf-8”, errors=“strict”)以指定的编码格式解码 bytes 对象，返回字符串</p>
<p>str.endswith(suffix[, start[, end]])判断字符串是否以指定后缀结尾</p>
<p>str.expandtabs(tabsize=8)把字符串中的 tab 符号( )转为空格</p>
<p>str.find(str, beg=0, end=len(string))如果包含子字符串返回开始的索引值，否则返回-1</p>
<p>str.index(str, beg=0, end=len(string))如果包含子字符串返回开始的索引值，否则抛出异常</p>
<p>str.isalnum()检测字符串是否只由字母和数字组成</p>
<p>str.isalpha()检测字符串是否只由字母组成</p>
<p>str.isdigit()检测字符串是否只由数字组成</p>
<p>str.islower()如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 </p>
<p>Falsestr.isupper()检测字符串中所有的字母是否都为大写</p>
<p>str.isspace()如果字符串中只包含空格，则返回 True，否则返回 </p>
<p>Falsestr.istitle()检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写</p>
<p>str.join(sequence)将序列的元素以指定的字符连接生成一个新的字符串</p>
<p>len(s)返回对象（字符串、列表、元组等）长度或项目个数</p>
<p>str.ljust(width[, fillchar])返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串</p>
<p>str.lower()转换字符串中所有大写字符为小写</p>
<p>str.upper()转换字符串中所有小写字符为大写</p>
<p>str.strip([chars])移除字符串头尾指定的字符（默认为空格）或字符序列</p>
<p>str.maketrans(intab, outtab)用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。两个字符串的长度必须相同，为一一对应的关系。</p>
<p>str.translate(table)根据参数table给出的表转换字符串的字符</p>
<p>max(str)返回字符串中最大的字符</p>
<p>min(str)返回字符串中最小的字符</p>
<p>str.replace(old, new[, max])把字符串中的old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次</p>
<p>str.split(str=“”, num=string.count(str))通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串</p>
<p>str.splitlines([keepends])按照行(’ ’, ‘ ’, ’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符str.startswith(str, beg=0,end=len(string))检查字符串是否是以指定子字符串开头</p>
<p>str.swapcase()对字符串的大小写字母进行互换</p>
<p>str.title()返回”标题化”的字符串，即所有单词都是以大写开始，其余字母均为小写str.zfill(width)返回指定长度的字符串，原字符串右对齐，前面填充0</p>
<p>str.isdecimal()检查字符串是否只包含十进制字符，只适用于 Unicode 对象</p>
<h4>列表(List)</h4>
<p>[]</p>

<h4>创建列表</h4>
<p>hello = [1, 2, 3]</p>

<p>li = [1, "2", [3, 'a'], (1, 3], hello]</p>

<h4>访问元素</h4>
<p>li = [1, "2", [3, 'a'], [1, 3)]</p>

<p>print(li[3]) # (1, 3)</p>

<p>print(li[-2]) # [3, 'a']</p>

<h4>切片访问</h4>
<p>格式: list_name[begin:end:step] begin 表示起始位置(默认为0)，end 表示结束位置(默认为最后一个元素)，step 表示步长(默认为1)</p>

<p>hello = (1, 2, 3)</p>

<p>li = [1, "2", [3, 'a'], (1, 3), hello]</p>

<p>print(li) # [1, '2', [3, 'a'], (1, 3), (1, 2, 3)]</p>

<p>print(li[1:2]) # ['2']</p>

<p>print(li[:2]) # [1, '2']</p>

<p>print(li[:]) # [1, '2', [3, 'a'], (1, 3), (1, 2, 3)]</p>

<p>print(li[2:]) # [[3, 'a'], (1, 3), (1, 2, 3)]</p>

<p>print(li[1:-1:2]) # ['2', (1, 3)]</p>

<h4>访问内嵌 list 的元素：</h4>
<p>li = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ['a', 'b', 'c']]</p>

<p>print(li[1:-1:2][1:3]) # (3, 5)</p>

<p>print(li[-1][1:3]) # ['b', 'c']</p>

<p>print(li[-1][1]) # b</p>

<h4>修改列表</h4>
<p>通过使用方括号，可以非常灵活的对列表的元素进行修改、替换、删除等操作。</p>

<p>li = [0, 1, 2, 3, 4, 5]</p>

<p>li[len(li) - 2] = 22 # 修改 [0, 1, 2, 22, 4, 5]</p>

<p>li[3] = 33 # 修改 [0, 1, 2, 33, 4, 5]</p>

<p>li[1:-1] = [9, 9] # 替换 [0, 9, 9, 5]</p>

<p>li[1:-1] = [] # 删除 [0, 5]</p>

<h4>删除元素</h4>
<p>可以用 del 语句来删除列表的指定范围的元素。</p>

<p>li = [0, 1, 2, 3, 4, 5]</p>

<p>del li[3] # [0, 1, 2, 4, 5]</p>

<p>del li[2:-1] # [0, 1, 5]</p>

<h4>列表操作符</h4>
<p>+</p>

<p>*</p>

<p>in</p>

<p>for ... in ...</p>

<p>[1, 2, 3] + [3, 4, 5] # [1, 2, 3, 3, 4, 5]</p>

<p>[1, 2, 3] * 2 # [1, 2, 3, 1, 2, 3]</p>

<p>3 in [1, 2, 3] # True</p>

<p>for x in [1, 2, 3]: print(x) # 1 2 3</p>

<h4>列表函数</h4>
<p>len(list)</p>

<p>max(list)</p>

<p>min(list)</p>

<p>list(seq)</p>

<p>li = [0, 1, 5]</p>

<p>max(li) # 5</p>

<p>len(li) # 3</p>

<p>注: 对列表使用 max/min 函数，2.x 中对元素值类型无要求，3.x 则要求元素值类型必须一致。</p>

<h4>列表方法</h4>
<p>list.append(obj)</p>

<p>在列表末尾添加新的对象</p>

<p>list.count(obj)</p>

<p>返回元素在列表中出现的次数</p>

<p>list.extend(seq)</p>

<p>在列表末尾一次性追加另一个序列中的多个值</p>

<p>list.index(obj)</p>

<p>返回查找对象的索引位置，如果没有找到对象则抛出异常</p>

<p>list.insert(index, obj)</p>

<p>将指定对象插入列表的指定位置</p>

<p>list.pop([index=-1]])</p>

<p>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</p>

<p>list.remove(obj)</p>

<p>移除列表中某个值的第一个匹配项</p>

<p>list.reverse()</p>

<p>反向排序列表的元素</p>

<p>list.sort(cmp=None, key=None, reverse=False)</p>

<p>对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数</p>

<p>list.clear()</p>

<p>清空列表还可以使用 del list[:] 、 li = [] 等方式实现</p>

<p>list.copy()</p>

<p>复制列表默认使用等号赋值给另一个变量，实际上是引用列表变量。如果要实现</p>

<h4>列表推导式</h4>
<p>列表推导式提供了<strong>从序列创建列表</strong>的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p>

<p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p>

<p>将列表中每个数值乘三，获得一个新的列表：</p>

<p>vec = [2, 4, 6]</p>

<p>[(x, x**2) for x in vec]</p>

<p># [(2, 4), (4, 16), (6, 36)]</p>

<p>对序列里每一个元素逐个调用某方法：</p>

<p>freshfruit = [' banana', ' loganberry ', 'passion fruit ']</p>

<p>[weapon.strip() for weapon in freshfruit]</p>

<p># ['banana', 'loganberry', 'passion fruit']</p>

<p>用 if 子句作为过滤器：</p>

<p>vec = [2, 4, 6]</p>

<p>[3*x for x in vec if x > 3]</p>

<p># [12, 18]</p>

<p>vec1 = [2, 4, 6]</p>

<p>vec2 = [4, 3, -9]</p>

<p>[x*y for x in vec1 for y in vec2]</p>

<p># [8, 6, -18, 16, 12, -36, 24, 18, -54]</p>

<p>[vec1[i]*vec2[i] for i in range(len(vec1))]</p>

<p># [8, 12, -54]</p>

<h4>列表嵌套解析：</h4>
<p>matrix = [</p>

<p>[1, 2, 3],</p>

<p>[4, 5, 6],</p>

<p>[7, 8, 9],</p>

<p>]</p>

<p>new_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]</p>

<p>print(new_matrix)</p>

<p># [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</p>

<h4>元组(tuple)</h4>
<p>元组与列表类似，不同之处在于元组的元素不能修改</p>

<p>元组使用小括号，列表使用方括号</p>

<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可</p>

<p>没有 append()，insert() 这样进行修改的方法，其他方法都与列表一样</p>

<p>字典中的键必须是唯一的同时不可变的，值则没有限制</p>

<p>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</p>

<p>访问元组</p>

<p>访问元组的方式与列表是一致的。 元组的元素可以直接赋值给多个变量，但变量数必须与元素数量一致。</p>

<p>a, b, c = (1, 2, 3)</p>

<p>print(a, b, c)</p>

<p>组合元组</p>

<p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合</p>

<p>tup1 = (12, 34.56);</p>

<p>tup2 = ('abc', 'xyz')</p>

<p>tup3 = tup1 + tup2;</p>

<p>print (tup3)</p>

<p># (12, 34.56, 'abc', 'xyz')</p>

<p>删除元组</p>

<p>元组中的元素值是不允许删除的，但我们可以使用 del 语句来删除整个元组</p>

<p>元组函数</p>

<p>len(tuple)</p>

<p>max(tuple)</p>

<p>min(tuple)</p>

<p>tuple(tuple)</p>

<h4>元组推导式</h4>
<p>t = 1, 2, 3</p>

<p>print(t)</p>

<p># (1, 2, 3)</p>

<p>u = t, (3, 4, 5)</p>

<p>print(u)</p>

<p># ((1, 2, 3), (3, 4, 5))</p>

<h4>字典(dict)</h4>
<p>字典是另一种可变容器模型，可存储任意类型对象</p>

<p>字典的每个键值(key=>value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中</p>

<p>键必须是唯一的，但值则不必</p>

<p>值可以是任意数据类型</p>

<p>键必须是不可变的，例如：数字、字符串、元组可以，但列表就不行</p>

<p>如果用字典里没有的键访问数据，会报错</p>

<p>字典的元素没有顺序，不能通过下标引用元素，通过键来引用</p>

<p>字典内部存放的顺序和 key 放入的顺序是没有关系的</p>

<p>格式如下:</p>

<p>d = {key1 : value1, key2 : value2 }</p>

<p>访问字典</p>

<p>dis = {'a': 1, 'b': [1, 2, 3]}</p>

<p>print(dis['b'][2])</p>

<p>修改字典</p>

<p>dis = {'a': 1, 'b': [1, 2, 3], 9: {'name': 'hello'}}</p>

<p>dis[9]['name'] = 999</p>

<p>print(dis)</p>

<p># {'a': 1, 9: {'name': 999}, 'b': [1, 2, 3]}</p>

<p>删除字典</p>

<p>用 del 语句删除字典或字典的元素。</p>

<p>dis = {'a': 1, 'b': [1, 2, 3], 9: {'name': 'hello'}}</p>

<p>del dis[9]['name']</p>

<p>print(dis)</p>

<p>del dis # 删除字典</p>

<p># {'a': 1, 9: {}, 'b': [1, 2, 3]}</p>

<p>字典函数</p>

<p>len(dict)</p>

<p>str(dict)</p>

<p>type(variable)</p>

<p>key in dict</p>

<p>字典方法</p>

<p>dict.clear()</p>

<p>删除字典内所有元素</p>

<p>dict.copy()</p>

<p>返回一个字典的浅复制</p>

<p>dict.fromkeys(seq[, value])</p>

<p>创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值</p>

<p>dict.get(key, default=None)</p>

<p>返回指定键的值，如果值不在字典中返回默认值</p>

<p>dict.items()</p>

<p>以列表形式返回可遍历的(键, 值)元组数组</p>

<p>dict.keys()</p>

<p>以列表返回一个字典所有的键</p>

<p>dict.values()</p>

<p>以列表返回字典中的所有值</p>

<p>dict.setdefault(key, default=None)</p>

<p>如果 key 在字典中，返回对应的值。如果不在字典中，则插入 key 及设置的默认值 default，并返回 default ，default 默认值为 None。</p>

<p>dict.update(dict2)</p>

<p>把字典参数 dict2 的键/值对更新到字典 dict1 里</p>

<p>dic1 = {'a': 'a'}</p>

<p>dic2 = {9: 9, 'a': 'b'}</p>

<p>dic1.update(dic2)</p>

<p>print(dic1)</p>

<p># {'a': 'b', 9: 9}</p>

<p>dict.pop(key[,default])</p>

<p>删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出，否则返回 default 值。</p>

<p>dict.popitem()</p>

<p>随机返回并删除字典中的一对键和值(一般删除末尾对)</p>

<h4>字典推导式</h4>
<p>构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p>

<p>>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])</p>

<p>{'sape': 4139, 'jack': 4098, 'guido': 4127}</p>

<p>此外，字典推导可以用来创建任意键和值的表达式词典：</p>

<p>>>> {x: x**2 for x in (2, 4, 6)}</p>

<p>{2: 4, 4: 16, 6: 36}</p>

<p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p>

<p>>>> dict(sape=4139, guido=4127, jack=4098)</p>

<p>{'sape': 4139, 'jack': 4098, 'guido': 4127}</p>

<h4>集合(set)</h4>
<p>集合是一个无序不重复元素的序列</p>

<p>创建集合</p>

<p>可以使用大括号 {} 或者 set() 函数创建集合</p>

<p>创建一个空集合必须用 set() 而不是 {} ，因为 {} 是用来创建一个空字典</p>

<p>set(value) 方式创建集合，value 可以是字符串、列表、元组、字典等序列类型</p>

<p>创建、添加、修改等操作，集合会自动去重</p>

<p>{1, 2, 1, 3} # {} {1, 2, 3}</p>

<p>set('12345') # 字符串 {'3', '5', '4', '2', '1'}</p>

<p>set([1, 'a', 23.4]) # 列表 {1, 'a', 23.4}</p>

<p>set((1, 'a', 23.4)) # 元组 {1, 'a', 23.4}</p>

<p>set({1:1, 'b': 9}) # 字典 {1, 'b'}</p>

<p>添加元素</p>

<p>将元素 val 添加到集合 set 中，如果元素已存在，则不进行任何操作：</p>

<p>set.add(val)</p>

<p>也可以用 update 方法批量添加元素，参数可以是列表，元组，字典等：</p>

<p>set.update(list1, list2,...)</p>

<p>移除元素</p>

<p>如果存在元素 val 则移除，不存在就报错：</p>

<p>set.remove(val)</p>

<p>如果存在元素 val 则移除，不存在也不会报错：</p>

<p>set.discard(val)</p>

<p>随机移除一个元素：</p>

<p>set.pop()</p>

<p>元素个数</p>

<p>与其他序列一样，可以用 len(set) 获取集合的元素个数。</p>

<p>清空集合</p>

<p>set.clear()</p>

<p>set = set()</p>

<p>判断元素是否存在</p>

<p>val in set</p>

<h4>其他方法</h4>
<p>set.copy()</p>

<p>复制集合</p>

<p>set.difference(set2)</p>

<p>求差集，在 set 中却不在 set2 中</p>

<p>set.intersection(set2)</p>

<p>求交集，同时存在于 set 和 set2 中</p>

<p>set.union(set2)</p>

<p>求并集，所有 set 和 set2 的元素</p>

<p>set.symmetric_difference(set2)</p>

<p>求对称差集，不同时出现在两个集合中的元素</p>

<p>set.isdisjoint(set2)</p>

<p>如果两个集合没有相同的元素，返回 True</p>

<p>set.issubset(set2)</p>

<p>如果 set 是 set2 的一个子集，返回 True</p>

<p>set.issuperset(set2)</p>

<p>如果 set 是 set2 的一个超集，返回 True</p>

<p>集合计算</p>

<p>a = set('abracadabra')</p>

<p>b = set('alacazam')</p>

<p>print(a) # a 中唯一的字母</p>

<p># {'a', 'r', 'b', 'c', 'd'}</p>

<p>print(a - b) # 在 a 中的字母，但不在 b 中</p>

<p># {'r', 'd', 'b'}</p>

<p>print(a | b) # 在 a 或 b 中的字母</p>

<p># {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}</p>

<p>print(a & b) # 在 a 和 b 中都有的字母</p>

<p># {'a', 'c'}</p>

<p>print(a ^ b) # 在 a 或 b 中的字母，但不同时在 a 和 b 中</p>

<p># {'r', 'd', 'b', 'm', 'z', 'l'}</p>

<h4>集合推导式</h4>
<p>a = {x for x in 'abracadabra' if x not in 'abc'}</p>

<p>print(a)</p>

<p># {'d', 'r'}</p>

<h4>流程控制</h4>
<h4>if 控制</h4>

<p></p>
<pre>
if 表达式1:
    语句

</pre>

<p></p>
<pre>
if 表达式2:
	语句
elif 表达式3:
	语句
else:
	语句
</pre>

<p>elif 表达式4:</p>

<p>语句</p>

<p>else:</p>

<p>语句</p>

<p>1、每个条件后面要使用冒号 : ，表示接下来是满足条件后要执行的语句块。 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 3、在 Python 中没有 switch - case 语句。</p>

<p>三元运算符：</p>

<p><表达式1> if <条件> else <表达式2></p>

<p>编写条件语句时，应该尽量避免使用嵌套语句。嵌套语句不便于阅读，而且可能会忽略一些可能性。</p>

<h4>for 遍历</h4>
<p></p>
<pre>
for <循环变量> in <循环对象>：
    <语句1>
else:
    <语句2>
</pre>

<p>else 语句中的语句2只有循环正常退出（遍历完所有遍历对象中的值）时执行。</p>

<p>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</p>

<p>knights = {'gallahad': 'the pure', 'robin': 'the brave'}</p>

<p>for k, v in knights.items():</p>

<p>print(k, v)</p>

<p>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</p>

<p>for i, v in enumerate(['tic', 'tac', 'toe']):</p>

<p>print(i, v)</p>

<p>同时遍历两个或更多的序列，可以使用 zip() 组合：</p>

<p>questions = ['name', 'quest', 'favorite color']</p>

<p>answers = ['lancelot', 'the holy grail', 'blue']</p>

<p>for q, a in zip(questions, answers):</p>

<p>print('What is your {0}? It is {1}.'.format(q, a))</p>

<p>要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：</p>

<p>for i in reversed(range(1, 10, 2)):</p>

<p>print(i)</p>

<p>要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：</p>

<p>basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']</p>

<p>for f in sorted(set(basket)):</p>

<p>print(f)</p>

<h4>while 循环</h4>
<p></p>
<pre>
while<条件>：
    <语句1>
else：
    <语句2>
</pre>

<p>break、continue、pass</p>

<p>break 语句用在 while 和 for 循环中，需要在经过若干次循环的时机后才可以判断何时退出循环，break 语句用来终止循环语句，即循环条件没有 False 条件或者序列还没被完全递归完，也会停止执行循环语句。 continue 语句用在 while 和 for 循环中，continue 语句用来告诉 Python 跳过当前循环的剩余语句，然后继续进行下一轮循环。 continue 语句跳出本次循环，而 break 跳出整个循环。</p>

<p>pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。</p>

<h4>迭代器</h4>
<p>迭代器是一个可以记住遍历的位置的对象。</p>

<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>

<p>迭代器有两个基本的方法： iter() 和 next() 。</p>

<p>字符串，列表或元组对象都可用于创建迭代器。</p>

<p>迭代器可以被 for 循环进行遍历：</p>

<p>li = [1, 2, 3]</p>

<p>it = iter(li)</p>

<p>for val in it:</p>

<p> &nbsp;&nbsp;&nbsp;&nbsp;print(val)</p>

<p>迭代器也可以用 next() 函数访问下一个元素值：</p>

<p></p>
<pre>
import sys
li = [1,2,3,4]
it = iter(li)
while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
</pre>

<h4>生成器</h4>
<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>

<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>

<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>

<p>调用一个生成器函数，返回的是一个迭代器对象。</p>

<p></p>
<pre>
import sys
def fibonacci(n): # 生成器函数 - 斐波那契
	a, b, counter = 0, 1, 0
	while True:
		if (counter > n):
			return
		yield a
		a, b = b, a + b
		counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
while True:
try:
	print(next(f))
except StopIteration:
	sys.exit()
</pre>

<h4>函数</h4>
<p>自定义函数</p>

<p>函数（Functions）是指可重复使用的程序片段。它们允许你为某个代码块赋予名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用（Calling）函数。</p>

<p>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 () 。</p>

<p>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</p>

<p>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</p>

<p>函数内容以冒号起始，并且缩进。</p>

<p>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None。</p>

<p>return 可以返回多个值，此时返回的数据未元组类型。</p>

<p>定义参数时，带默认值的参数必须在无默认值参数的后面。</p>

<p>def 函数名（参数列表）:</p>

<p>&nbsp;&nbsp;函数体</p>

<p>参数传递</p>

<p>在 Python 中，类型属于对象，变量是没有类型的：</p>

<p>a = [1,2,3]</p>

<p>a = "Runoob"</p>

<p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而<strong>变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</strong></p>

<h4>可更改与不可更改对象</h4>
<p>在 Python 中，字符串，数字和元组是不可更改的对象，而列表、字典等则是可以修改的对象。</p>

<p>不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</p>

<p>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p>

<h4>Python 函数的参数传递：</h4>
<p>不可变类型：类似 c++ 的值传递，如整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</p>

<p>可变类型：类似 c++ 的引用传递，如列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</p>

<p><strong>Python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</strong></p>

<h4>参数</h4>
<p>必需参数</p>

<p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>

<p>关键字参数</p>

<p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>

<p></p>
<pre>
def print_info(name, age):
	"打印任何传入的字符串"
	print("名字: ", name)
	print("年龄: ", age)
	return
print_info(age=50, name="john")
</pre>

<p>默认参数</p>

<p>调用函数时，如果没有传递参数，则会使用默认参数。</p>
<p></p>
<pre>
def print_info(name, age=35):
	print ("名字: ", name)
	print ("年龄: ", age)
	return
print_info(age=50, name="john")
print("------------------------")
print_info(name="john")
</pre>

<p>不定长参数</p>

<p>参数前加*</p>

<p></p>
<pre>
def print_info(arg1, *vartuple):
	print("输出: ")
	print(arg1)
	for var in vartuple:
	print (var)
	return
print_info(10)
print_info(70, 60, 50)
</pre>

<p>加了两个星号 ** 的参数会以字典的形式导入。变量名为键，变量值为字典元素值。</p>

<p></p>
<pre>
def print_info(arg1, **vardict):
	print("输出: ")
	print(arg1)
	print(vardict)
print_info(1, a=2, b=3)
</pre>

<h4>匿名函数</h4>
<p>Python 使用 lambda 来创建匿名函数。</p>

<p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p>

<p>lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</p>

<p># 语法格式</p>

<p>lambda [arg1 [,arg2,.....argn]]:expression</p>

<h4>变量作用域</h4>
<p>L （Local） 局部作用域</p>

<p>E （Enclosing） 闭包函数外的函数中</p>

<p>G （Global） 全局作用域</p>

<p>B （Built-in） 内建作用域</p>

<p>以 L –> E –> G –> B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p>

<p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。</p>

<p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>

<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p>

<p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。</p>

<p></p>
<pre>
num = 1
def fun1():
	global num # 需要使用 global 关键字声明
	print(num)
	num = 123
	print(num)
fun1()
</pre>

<p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字。</p>

<pre>
def outer():
	num = 10
	def inner():
		nonlocal num # nonlocal关键字声明
		num = 100
		print(num)
inner()
print(num)
outer()
</pre>

<p><h4>模块</h4></p>

<p>编写模块有很多种方法，其中最简单的一种便是创建一个包含函数与变量、以 .py 为后缀的文件。</p>

<p>另一种方法是使用撰写 Python 解释器本身的本地语言来编写模块。举例来说，你可以使用 C 语言来撰写 Python 模块，并且在编译后，你可以通过标准 Python 解释器在你的 Python 代码中使用它们。</p>

<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是 .py 。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 Python 标准库的方法。</p>

<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>

<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块，需要把命令放在脚本的顶端。</p>

<p>一个模块只会被导入一次，这样可以防止导入模块被一遍又一遍地执行。</p>

<p>搜索路径被存储在 sys 模块中的 path 变量。当前目录指的是程序启动的目录。</p>

<p><h4>导入模块</h4></p>

<p>导入模块：</p>

<p>import module1[, module2[,... moduleN]</p>

<p>从模块中导入一个指定的部分到当前命名空间中：</p>

<p>from modname import name1[, name2[, ... nameN]]</p>

<p>把一个模块的所有内容全都导入到当前的命名空间：</p>

<p>from modname import *</p>

<p>__name__ 属性</p>

<p>每个模块都有一个 __name__ 属性，当其值是 '__main__' 时，表明该模块自身在运行，否则是被引入。</p>

<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 __name__ 属性来使该程序块仅在该模块自身运行时执行。</p>


<pre>
if __name__ == '__main__':
    print('程序自身在运行')
else:
    print('我来自另一模块')
</pre>

<p><h4>dir 函数</h4></p>

<p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。</p>

<p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称。</p>

<p>在 Python 中万物皆对象， int 、 str 、 float 、 list 、 tuple 等内置数据类型其实也是类，也可以用 dir(int) 查看 int 包含的所有方法。也可以使用 help(int) 查看 int 类的帮助信息。</p>

<p><h4>包</h4></p>

<p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>

<p>比如一个模块的名称是 A.B，那么他表示一个包 A中的子模块 B 。</p>

<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>

<p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p>

<p><strong>目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包</strong>，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p>

<p>最简单的情况，放一个空的 __init__.py 文件就可以了。当然这个文件中也可以包含一些初始化代码或者为 __all__ 变量赋值。</p>

<p><h4>第三方模块</h4></p>

<p>easy_install 和 pip 都是用来下载安装 Python 一个公共资源库 PyPI 的相关资源包的，pip 是 easy_install 的改进版，提供更好的提示信息，删除 package 等功能。老版本的 python 中只有 easy_install，没有pip。</p>

<p>easy_install 打包和发布 Python 包，pip 是包管理。</p>

<p><h4>easy_install 的用法：</h4></p>

<p>安装一个包</p>

<p>easy_install 包名</p>

<p>easy_install "包名 == 包的版本号"</p>

<p>升级一个包</p>

<p>easy_install -U "包名 >= 包的版本号"</p>

<p><h4>pip 的用法：</h4></p>

<p>安装一个包（在CMD Shell中）</p>

<p>pip install 包名</p>

<p>pip install 包名 == 包的版本号</p>

<p>升级一个包 （如果不提供version号，升级到最新版本）</p>

<p>pip install --upgrade 包名 >= 包的版本号</p>

<p>删除一个包</p>

<p>pip uninstall 包名</p>

<p>已安装包列表</p>

<p>pip list</p>

<p><h4>面向对象</h4></p>

<p>类与对象是面向对象编程的两个主要方面。一个类 （Class）能够创建一种新的类型（Type），其中对象 （Object）就是类的实例 （Instance）。可以这样来类比：你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例（对象）。</p>

<p>类(Class) ：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>

<p>方法 ：类中定义的函数。</p>

<p>类变量 ：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>

<p>数据成员 ：类变量或者实例变量用于处理类及其实例对象的相关的数据。</p>

<p>方法重写 ：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>

<p>实例变量 ：定义在方法中的变量，只作用于当前实例的类。</p>

<p>继承 ：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</p>

<p>实例化 ：创建一个类的实例，类的具体对象。</p>

<p>对象 ：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>

<p>Python 中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>

<p>对象可以包含任意数量和类型的数据。</p>

<p><h4>self</h4></p>

<p>self 表示的是当前实例，代表当前对象的地址。类由 self.__class__ 表示。</p>

<p>self 不是关键字，其他名称也可以替代，但 self 是个通用的标准名称。</p>

<p><h4>类</h4></p>

<p>类由 class 关键字来创建。 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性（类属性）。</p>

<p><h4>对象方法</h4></p>

<p>方法由 def 关键字定义，与函数不同的是，方法必须包含参数 self , 且为第一个参数， self 代表的是本类的实例。</p>

<p><h4>类方法</h4></p>

<p>装饰器 @classmethod 可以将方法标识为类方法。类方法的第一个参数必须为 cls ，而不再是self 。</p>

<p><h4>静态方法</h4></p>

<p>装饰器 @staticmethod 可以将方法标识为静态方法。静态方法的第一个参数不再指定，也就不需要 self 或 cls 。</p>

<p><h4>__init__ 方法</h4></p>

<p>__init__ 方法即构造方法，会在类的对象被实例化时先运行，可以将初始化的操作放置到该方法中。</p>

<p>如果重写了 __init__ ，实例化子类就不会调用父类已经定义的 __init__ 。</p>

<p><h4>变量</h4></p>

<p>类变量 （Class Variable）是共享的（Shared）——它们可以被属于该类的所有实例访问。该类变量只拥有一个副本，当任何一个对象对类变量作出改变时，发生的变动将在其它所有实例中都会得到体现。</p>

<p>对象变量 （Object variable）由类的每一个独立的对象或实例所拥有。在这种情况下，每个对象都拥有属于它自己的字段的副本，也就是说，它们不会被共享，也不会以任何方式与其它不同实例中的相同名称的字段产生关联。</p>

<p>在 Python 中，变量名类似 __xxx__ 的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是 private 变量，所以，不能用 __name__ 、 __score__ 这样的变量名。</p>

<p><h4>访问控制</h4></p>

<p>私有属性</p>

<p>__private_attr ：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。</p>

<p>私有方法</p>

<p>__private_method ：两个下划线开头，声明该方法为私有方法，只能在类的内部调用，不能在类地外部调用。</p>

<p>我们还认为约定，一个下划线开头的属性或方法为受保护的。比如， _protected_attr 、 _protected_method 。</p>

<p><h4>继承</h4></p>

<p>类可以继承，并且支持继承多个父类。在定义类时，类名后的括号中指定要继承的父类，多个父类之间用逗号分隔。</p>

<p>子类的实例可以完全访问所继承所有父类的非私有属性和方法。</p>

<p>若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>

<p><strong>方法重写</strong></p>

<p>子类的方法可以重写父类的方法。重写的方法参数不强制要求保持一致，不过合理的设计都应该保持一致。</p>

<p>super() 函数可以调用父类的一个方法，以多继承问题。</p>

<p>类的专有方法：</p>

<pre>
__init__
__del__
__repr__
__setitem__
__getitem__
__len__
__cmp__
__call__
__add__
__sub__
__mul__
__div__
__mod__
__pow__
</pre>

<p>类的专有方法也支持重载。</p>

<p><h4><a href="classExample.py">类的综合实例</a></h4></p>


<p><h4>错误和异常</h4></p>

<p>语法错误</p>

<p>SyntaxError 类表示语法错误，当解释器发现代码无法通过语法检查时会触发的错误。语法错误是无法用 try...except... 捕获的。</p>

<p>>>> print:</p>

<p>File "<stdin>", line 1</p>

<p>print:</p>

<p>^</p>

<p>SyntaxError: invalid syntax</p>

<p><h4>异常</h4></p>

<p>即便程序的语法是正确的，在运行它的时候，也有可能发生错误。运行时发生的错误被称为异常。 错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p>

<p>>>> 1 + '0'</p>

<p>Traceback (most recent call last):</p>

<p>File "<stdin>", line 1, in <module></p>

<p>TypeError: unsupported operand type(s) for +: 'int' and 'str'</p>

<p><h4>异常处理</h4></p>

<p>Python 提供了 try ... except ... 的语法结构来捕获和处理异常。</p>

<p>try 语句执行流程大致如下：</p>

<p>st=>start: try 子句</p>

<p>cond_has_error=>condition: 是否有异常</p>

<p>cond_has_else=>condition: 是否有 else 子句</p>

<p>cond_has_finally=>condition: 是否有 finally 子句</p>

<p>io=>inputoutput: verification</p>

<p>op_except=>operation: except 子句处理异常</p>

<p>op_else=>operation: 执行 else 子句</p>

<p>op_finally=>operation: 执行 finally 子句</p>

<p>e=>end: 结束</p>

<p>st->cond_has_error</p>

<p>cond_has_error(yes, right)->op_except->cond_has_else</p>

<p>cond_has_error(no)->cond_has_else</p>

<p>cond_has_else(yes, right)->op_else->cond_has_finally</p>

<p>cond_has_else(no)->cond_has_finally</p>

<p>cond_has_finally(yes, right)->op_finally->e</p>

<p>cond_has_finally(no)->e</p>

<p>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）</p>

<p>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</p>

<p>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。最后执行 try 语句之后的代码。</p>

<p>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</p>

<p>一个 try 语句可能包含多个 except 子句，分别来处理不同的特定的异常。</p>

<p>最多只有一个 except 子句会被执行。</p>

<p>处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p>

<p>一个 except 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。</p>

<p>最后一个 except 子句可以忽略异常的名称，它将被当作通配符使用。可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p>

<p>try except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。这个子句将在 try 子句没有发生任何异常的时候执行。</p>

<p>异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。</p>

<p>不管 try 子句里面有没有发生异常，finally 子句都会执行。</p>

<p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。</p>

<p><h4>抛出异常</h4></p>

<p>使用 raise 语句抛出一个指定的异常。</p>

<p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</p>

<p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p>

<p><h4>自定义异常</h4></p>

<p>可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。</p>

<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。</p>

<p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p>

<p><h4><a href="except.py">异常的综合实例</a></h4></p>


<p><h4>文件操作</h4></p>

<p>打开文件</p>

<p>open() 函数用于打开/创建一个文件，并返回一个 file 对象：</p>

<p>open(filename, mode)</p>

<p>filename：包含了你要访问的文件名称的字符串值</p>

<p>mode：决定了打开文件的模式：只读，写入，追加等</p>

<p>文件打开模式：</p>


模式描述:<br />

r以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br />
rb以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。<br />
r+打开一个文件用于读写。文件指针将会放在文件的开头。<br />
rb+以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。<br />
w打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br />
wb以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br />
w+打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br />
wb+以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br />
a打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br />
ab以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br />
a+打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br />
ab+以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</p>

<p><h4>文件对象方法</h4></p>

<p>fileObject.close()</p>

<p>close() 方法用于关闭一个已打开的文件。关闭后的文件不能再进行读写操作，否则会触发 ValueError 错误。 close() 方法允许调用多次。</p>

<p>当 file 对象，被引用到操作另外一个文件时，Python 会自动关闭之前的 file 对象。 使用 close() 方法关闭文件是一个好的习惯。</p>

<p>fileObject.flush()</p>

<p>flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。</p>

<p>一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。</p>

<p>fileObject.fileno()</p>

<p>fileno() 方法返回一个整型的文件描述符(file descriptor FD 整型)，可用于底层操作系统的 I/O 操作。</p>

<p>fileObject.isatty()</p>

<p>isatty() 方法检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。</p>

<p>next(iterator[,default])</p>

<p>Python 3 中的 File 对象不支持 next() 方法。 Python 3 的内置函数 next() 通过迭代器调用__next__() 方法返回下一项。在循环中， next() 函数会在每次循环中调用，该方法返回文件的下一行，如果到达结尾(EOF)，则触发 StopIteration。</p>

<p>fileObject.read()</p>

<p>read() 方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。</p>

<p>fileObject.readline()</p>

<p>readline() 方法用于从文件读取整行，包括 “ ” 字符。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 “ ” 字符。</p>

<p>fileObject.readlines()</p>

<p>readlines() 方法用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的 for... in ... 结构进行处理。如果碰到结束符 EOF，则返回空字符串。</p>

<p><h4>fileObject.seek(offset[, whence])</h4></p>

<p>seek() 方法用于移动文件读取指针到指定位置。</p>

<p>whence 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾。whence 值为默认为0，即文件开头。例如：</p>

<p>seek(x, 0) ：从起始位置即文件首行首字符开始移动 x 个字符</p>

<p>seek(x, 1) ：表示从当前位置往后移动 x 个字符</p>

<p>seek(-x, 2) ：表示从文件的结尾往前移动 x 个字符</p>

<p>fileObject.tell(offset[, whence])</p>

<p>tell() 方法返回文件的当前位置，即文件指针当前位置。</p>

<p>fileObject.truncate([size])</p>

<p>truncate() 方法用于从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后 V 后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。</p>

<p>fileObject.write([str])</p>

<p>write() 方法用于向文件中写入指定字符串。</p>

<p>在文件关闭前或缓冲区刷新前，字符串内容存储在缓冲区中，这时你在文件中是看不到写入的内容的。</p>

<p>如果文件打开模式带 b，那写入文件内容时，str (参数)要用 encode 方法转为 bytes 形式，否则报错： TypeError: a bytes-like object is required, not 'str' 。</p>

<p>fileObject.writelines([str])</p>

<p>writelines() 方法用于向文件中写入一序列的字符串。这一序列字符串可以是由迭代对象产生的，如一个字符串列表。换行需要指定换行符 。</p>

<p><h4><a href="fileExample.py">文件操作综合实例</a></h4></p>


<p><h4>序列化</h4></p>

<p>在 Python 中 pickle 模块实现对数据的序列化和反序列化。pickle 支持任何数据类型，包括内置数据类型、函数、类、对象等。</p>

<p>方法</p>

<p>dump</p>

<p>将数据对象序列化后写入文件</p>

<p>pickle.dump(obj, file, protocol=None, fix_imports=True)</p>

<p>必填参数 obj 表示将要封装的对象。 必填参数 file 表示 obj 要写入的文件对象，file 必须以二进制可写模式打开，即 wb 。 可选参数 protocol 表示告知 pickle 使用的协议，支持的协议有 0,1,2,3，默认的协议是添加在 Python 3 中的协议3。</p>

<p>load</p>

<p>从文件中读取内容并反序列化</p>

<p>pickle.load(file, fix_imports=True, encoding='ASCII', errors='strict')</p>

<p>必填参数 file 必须以二进制可读模式打开，即 rb ，其他都为可选参数。</p>

<p>dumps</p>

<p>以字节对象形式返回封装的对象，不需要写入文件中</p>

<p>pickle.dumps(obj, protocol=None, fix_imports=True)</p>

<p>loads</p>

<p>从字节对象中读取被封装的对象，并返回</p>

<p>pickle.loads(bytes_object, fix_imports=True, encoding='ASCII', errors='strict')</p>

<p><h4><a href="pickleExample.py">序列化操作的实例</a></h4></p>
<p></p>
<pre>
import pickle
data = [1, 2, 3]

# 序列化数据并以字节对象返回
dumps_obj = pickle.dumps(data)
print('pickle.dumps():', dumps_obj)

# 从字节对象中反序列化数据
loads_data = pickle.loads(dumps_obj)
print('pickle.loads():', loads_data)
filename = 'data.log'

# 序列化数据到文件中
with open(filename, 'wb') as file:
....pickle.dump(data, file)
....
# 从文件中加载并反序列化
with open(filename, 'rb') as file:
....load_data = pickle.load(file)
....print('pickle.load():', load_data)
'''
输出：
pickle.dumps(): b'\x80\x03]q\x00(K\x01K\x02K\x03e.'
pickle.loads(): [1, 2, 3]
pickle.load(): [1, 2, 3]
'''
</pre>

<p><h4>命名规范</h4></p>

<p>Python 之父 Guido 推荐的规范</p>

<p>看了这篇Python博文后，我才知道那些说快速入门的教程都是笑话！</p>



<p style='float:right;'>本页共1089段，34805个字符，65797 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
