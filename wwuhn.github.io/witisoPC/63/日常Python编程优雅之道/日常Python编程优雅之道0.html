<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>

<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}

#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}


#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>

</head>

<body>

<div id="container">



<h4>﻿日常Python编程优雅之道</h4>

<p>编译自： https://opensource.com/article/18/4/elegant-solutions-everyday-python-problems</p>

<p>作者： Nina Zakharenko</p>

<p>译者： MjSeven</p>

<p>3 个可以使你的 Python 代码更优雅、可读、直观和易于维护的工具。</p>

<p>Python 提供了一组独特的工具和语言特性来使你的代码更加优雅、可读和直观。为正确的问题选择合适的工具，你的代码将更易于维护。在本文中，我们将研究其中的三个工具：魔术方法、迭代器和生成器，以及方法魔术。</p>

<p>魔术方法</p>

<p>魔术方法可以看作是 Python 的管道。它们被称为“底层”方法，用于某些内置的方法、符号和操作。你可能熟悉的常见魔术方法是 __init__()，当我们想要初始化一个类的新实例时，它会被调用。</p>

<p>你可能已经看过其他常见的魔术方法，如 __str__ 和 __repr__。Python 中有一整套魔术方法，通过实现其中的一些方法，我们可以修改一个对象的行为，甚至使其行为类似于内置数据类型，例如数字、列表或字典。</p>

<p>让我们创建一个 Money 类来示例：</p>

<p>class Money:</p>

<p>currency_rates = {</p>

<p>'$': 1,</p>

<p>'€': 0.88,</p>

<p>}</p>

<p>def __init__(self, symbol, amount):</p>

<p>self.symbol = symbol</p>

<p>self.amount = amount</p>

<p>def __repr__(self):</p>

<p>return '%s%.2f' % (self.symbol, self.amount)</p>

<p>def convert(self, other):</p>

<p>""" Convert other amount to our currency """</p>

<p>new_amount = (</p>

<p>other.amount / self.currency_rates[other.symbol]</p>

<p>* self.currency_rates[self.symbol])</p>

<p>return Money(self.symbol, new_amount)</p>

<p>该类定义为给定的货币符号和汇率定义了一个货币汇率，指定了一个初始化器（也称为构造函数），并实现 __repr__，因此当我们打印这个类时，我们会看到一个友好的表示，例如 $2.00 ，这是一个带有货币符号和金额的 Money('$', 2.00) 实例。最重要的是，它定义了一种方法，允许你使用不同的汇率在不同的货币之间进行转换。</p>

<p>打开 Python shell，假设我们已经定义了使用两种不同货币的食品的成本，如下所示：</p>

<p>>>> soda_cost = Money('$', 5.25)</p>

<p>>>> soda_cost</p>

<p>$5.25</p>

<p>>>> pizza_cost = Money('€', 7.99)</p>

<p>>>> pizza_cost</p>

<p>€7.99</p>

<p>我们可以使用魔术方法使得这个类的实例之间可以相互交互。假设我们希望能够将这个类的两个实例一起加在一起，即使它们是不同的货币。为了实现这一点，我们可以在 Money 类上实现 __add__ 这个魔术方法：</p>

<p>class Money:</p>

<p># ... previously defined methods ...</p>

<p>def __add__(self, other):</p>

<p>""" Add 2 Money instances using '+' """</p>

<p>new_amount = self.amount + self.convert(other).amount</p>

<p>return Money(self.symbol, new_amount)</p>

<p>现在我们可以以非常直观的方式使用这个类：</p>

<p>>>> soda_cost = Money('$', 5.25)</p>

<p>>>> pizza_cost = Money('€', 7.99)</p>

<p>>>> soda_cost + pizza_cost</p>

<p>$14.33</p>

<p>>>> pizza_cost + soda_cost</p>

<p>€12.61</p>

<p>当我们将两个实例加在一起时，我们得到以第一个定义的货币符号所表示的结果。所有的转换都是在底层无缝完成的。如果我们想的话，我们也可以为减法实现 __sub__，为乘法实现 __mul__ 等等。阅读模拟数字类型或 魔术方法指南来获得更多信息。</p>

<p>我们学习到 __add__ 映射到内置运算符 +。其他魔术方法可以映射到像 <sup>[]</sup> 这样的符号。例如，在字典中通过索引或键来获得一项，其实是使用了 __getitem__ 方法：</p>

<p>>>> d = {'one': 1, 'two': 2}</p>

<p>>>> d['two']</p>

<p>2</p>

<p>>>> d.__getitem__('two')</p>

<p>2</p>

<p>一些魔术方法甚至映射到内置函数，例如 __len__() 映射到 len()。</p>

<p>class Alphabet:</p>

<p>letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</p>

<p>def __len__(self):</p>

<p>return len(self.letters)</p>

<p>>>> my_alphabet = Alphabet()</p>

<p>>>> len(my_alphabet)</p>

<p>26</p>

<p>自定义迭代器</p>

<p>对于新的和经验丰富的 Python 开发者来说，自定义迭代器是一个非常强大的但令人迷惑的主题。</p>

<p>许多内置类型，例如列表、集合和字典，已经实现了允许它们在底层迭代的协议。这使我们可以轻松地遍历它们。</p>

<p>>>> for food in ['Pizza', 'Fries']:</p>

<p>print(food + '. Yum!')</p>

<p>Pizza. Yum!</p>

<p>Fries. Yum!</p>

<p>我们如何迭代我们自己的自定义类？首先，让我们来澄清一些术语。</p>

<p>要成为一个可迭代对象，一个类需要实现 __iter__()</p>

<p>__iter__() 方法需要返回一个迭代器</p>

<p>要成为一个迭代器，一个类需要实现 __next__()（或在 Python 2 中是 next()），当没有更多的项要迭代时，必须抛出一个 StopIteration 异常。</p>

<p>呼！这听起来很复杂，但是一旦你记住了这些基本概念，你就可以在任何时候进行迭代。</p>

<p>我们什么时候想使用自定义迭代器？让我们想象一个场景，我们有一个 Server 实例在不同的端口上运行不同的服务，如 http 和 ssh。其中一些服务处于 active 状态，而其他服务则处于 inactive 状态。</p>

<p>class Server:</p>

<p>services = [</p>

<p>{'active': False, 'protocol': 'ftp', 'port': 21},</p>

<p>{'active': True, 'protocol': 'ssh', 'port': 22},</p>

<p>{'active': True, 'protocol': 'http', 'port': 80},</p>

<p>]</p>

<p>当我们遍历 Server 实例时，我们只想遍历那些处于 active 的服务。让我们创建一个 IterableServer 类：</p>

<p>class IterableServer:</p>

<p>def __init__(self):</p>

<p>self.current_pos = 0</p>

<p>def __next__(self):</p>

<p>pass # TODO: 实现并记得抛出 StopIteration</p>

<p>首先，我们将当前位置初始化为 0。然后，我们定义一个 __next__() 方法来返回下一项。我们还将确保在没有更多项返回时抛出 StopIteration。到目前为止都很好！现在，让我们实现这个 __next__() 方法。</p>

<p>class IterableServer:</p>

<p>def __init__(self):</p>

<p>self.current_pos = 0. # 我们初始化当前位置为 0</p>

<p>def __iter__(self): # 我们可以在这里返回 self，因为实现了 __next__</p>

<p>return self</p>

<p>def __next__(self):</p>

<p>while self.current_pos < len(self.services):</p>

<p>service = self.services[self.current_pos]</p>

<p>self.current_pos += 1</p>

<p>if service['active']:</p>

<p>return service['protocol'], service['port']</p>

<p>raise StopIteration</p>

<p>next = __next__ # 可选的 Python2 兼容性</p>

<p>我们对列表中的服务进行遍历，而当前的位置小于服务的个数，但只有在服务处于活动状态时才返回。一旦我们遍历完服务，就会抛出一个 StopIteration 异常。</p>

<p>因为我们实现了 __next__() 方法，当它耗尽时，它会抛出 StopIteration。我们可以从 __iter__() 返回 self，因为 IterableServer 类遵循 iterable 协议。</p>

<p>现在我们可以遍历一个 IterableServer 实例，这将允许我们查看每个处于活动的服务，如下所示：</p>

<p>>>> for protocol, port in IterableServer():</p>

<p>print('service %s is running on port %d' % (protocol, port))</p>

<p>service ssh is running on port 22</p>

<p>service http is running on port 21</p>

<p>太棒了，但我们可以做得更好！在这样类似的实例中，我们的迭代器不需要维护大量的状态，我们可以简化代码并使用 generator（生成器） 来代替。</p>

<p>class Server:</p>

<p>services = [</p>

<p>{'active': False, 'protocol': 'ftp', 'port': 21},</p>

<p>{'active': True, 'protocol': 'ssh', 'port': 22},</p>

<p>{'active': True, 'protocol': 'http', 'port': 21},</p>

<p>]</p>

<p>def __iter__(self):</p>

<p>for service in self.services:</p>

<p>if service['active']:</p>

<p>yield service['protocol'], service['port']</p>

<p>yield 关键字到底是什么？在定义生成器函数时使用 yield。这有点像 return，虽然 return 在返回值后退出函数，但 yield 会暂停执行直到下次调用它。这允许你的生成器的功能在它恢复之前保持状态。查看 yield 的文档以了解更多信息。使用生成器，我们不必通过记住我们的位置来手动维护状态。生成器只知道两件事：它现在需要做什么以及计算下一个项目需要做什么。一旦我们到达执行点，即 yield 不再被调用，我们就知道停止迭代。</p>

<p>这是因为一些内置的 Python 魔法。在 Python 关于 __iter__() 的文档中我们可以看到，如果 __iter__() 是作为一个生成器实现的，它将自动返回一个迭代器对象，该对象提供 __iter__() 和 __next__() 方法。阅读这篇很棒的文章，深入了解迭代器，可迭代对象和生成器 。</p>

<p>方法魔法</p>

<p>由于其独特的方面，Python 提供了一些有趣的方法魔法作为语言的一部分。</p>

<p>其中一个例子是别名功能。因为函数只是对象，所以我们可以将它们赋值给多个变量。例如：</p>

<p>>>> def foo():</p>

<p>return 'foo'</p>

<p>>>> foo()</p>

<p>'foo'</p>

<p>>>> bar = foo</p>

<p>>>> bar()</p>

<p>'foo'</p>

<p>我们稍后会看到它的作用。</p>

<p>Python 提供了一个方便的内置函数称为 getattr() ，它接受 object, name, default 参数并在 object 上返回属性 name。这种编程方式允许我们访问实例变量和方法。例如：</p>

<p>>>> class Dog:</p>

<p>sound = 'Bark'</p>

<p>def speak(self):</p>

<p>print(self.sound + '!', self.sound + '!')</p>

<p>>>> fido = Dog()</p>

<p>>>> fido.sound</p>

<p>'Bark'</p>

<p>>>> getattr(fido, 'sound')</p>

<p>'Bark'</p>

<p>>>> fido.speak</p>

<p><bound method Dog.speak of <__main__.Dog object at 0x102db8828>></p>

<p>>>> getattr(fido, 'speak')</p>

<p><bound method Dog.speak of <__main__.Dog object at 0x102db8828>></p>

<p>>>> fido.speak()</p>

<p>Bark! Bark!</p>

<p>>>> speak_method = getattr(fido, 'speak')</p>

<p>>>> speak_method()</p>

<p>Bark! Bark!</p>

<p>这是一个很酷的技巧，但是我们如何在实际中使用 getattr 呢？让我们看一个例子，我们编写一个小型命令行工具来动态处理命令。</p>

<p>class Operations:</p>

<p>def say_hi(self, name):</p>

<p>print('Hello,', name)</p>

<p>def say_bye(self, name):</p>

<p>print ('Goodbye,', name)</p>

<p>def default(self, arg):</p>

<p>print ('This operation is not supported.')</p>

<p>if __name__ == '__main__':</p>

<p>operations = Operations()</p>

<p># 假设我们做了错误处理</p>

<p>command, argument = input('> ').split()</p>

<p>func_to_call = getattr(operations, command, operations.default)</p>

<p>func_to_call(argument)</p>

<p>脚本的输出是：</p>

<p>$ python getattr.py</p>

<p>> say_hi Nina</p>

<p>Hello, Nina</p>

<p>> blah blah</p>

<p>This operation is not supported.</p>

<p>接下来，我们来看看 partial。例如，functool.partial(func, *args, **kwargs) 允许你返回一个新的 partial 对象，它的行为类似 func，参数是 args 和 kwargs。如果传入更多的 args，它们会被附加到 args。如果传入更多的 kwargs，它们会扩展并覆盖 kwargs。让我们通过一个简短的例子来看看：</p>

<p>>>> from functools import partial</p>

<p>>>> basetwo = partial(int, base=2)</p>

<p>>>> basetwo</p>

<p><functools.partial object at 0x1085a09f0></p>

<p>>>> basetwo('10010')</p>

<p>18</p>

<p># 这等同于</p>

<p>>>> int('10010', base=2)</p>

<p>让我们看看在我喜欢的一个名为 agithub 的库中的一些示例代码中，这个方法魔术是如何结合在一起的，这是一个（名字起得很 low 的） REST API 客户端，它具有透明的语法，允许你以最小的配置快速构建任何 REST API 原型（不仅仅是 GitHub）。我发现这个项目很有趣，因为它非常强大，但只有大约 400 行 Python 代码。你可以在大约 30 行配置代码中添加对任何 REST API 的支持。agithub 知道协议所需的一切（REST、HTTP、TCP），但它不考虑上游 API。让我们深入到它的实现中。</p>

<p>以下是我们如何为 GitHub API 和任何其他相关连接属性定义端点 URL 的简化版本。在这里查看完整代码 。</p>

<p>class GitHub(API):</p>

<p>def __init__(self, token=None, *args, **kwargs):</p>

<p>props = ConnectionProperties(api_url = kwargs.pop('api_url', 'api.github.com'))</p>

<p>self.setClient(Client(*args, **kwargs))</p>

<p>self.setConnectionProperties(props)</p>

<p>然后，一旦配置了访问令牌，就可以开始使用 GitHub API 。</p>

<p>>>> gh = GitHub('token')</p>

<p>>>> status, data = gh.user.repos.get(visibility='public', sort='created')</p>

<p>>>> # ^ 映射到 GET /user/repos</p>

<p>>>> data</p>

<p>... ['tweeter', 'snipey', '...']</p>

<p>请注意，你要确保 URL 拼写正确，因为我们没有验证 URL。如果 URL 不存在或出现了其他任何错误，将返回 API 抛出的错误。那么，这一切是如何运作的呢？让我们找出答案。首先，我们将查看一个 API 类的简化示例：</p>

<p>class API:</p>

<p># ... other methods ...</p>

<p>def __getattr__(self, key):</p>

<p>return IncompleteRequest(self.client).__getattr__(key)</p>

<p>__getitem__ = __getattr__</p>

<p>在 API 类上的每次调用都会调用 IncompleteRequest 类作为指定的 key。</p>

<p>class IncompleteRequest:</p>

<p># ... other methods ...</p>

<p>def __getattr__(self, key):</p>

<p>if key in self.client.http_methods:</p>

<p>htmlMethod = getattr(self.client, key)</p>

<p>return partial(htmlMethod, url=self.url)</p>

<p>else:</p>

<p>self.url += '/' + str(key)</p>

<p>return self</p>

<p>__getitem__ = __getattr__</p>

<p>class Client:</p>

<p>http_methods = ('get') # 还有 post, put, patch 等等。</p>

<p>def get(self, url, headers={}, **params):</p>

<p>return self.request('GET', url, None, headers)</p>

<p>如果最后一次调用不是 HTTP 方法（如 get、post 等），则返回带有附加路径的 IncompleteRequest。否则，它从 Client 类获取 HTTP 方法对应的正确函数，并返回 partial。</p>

<p>如果我们给出一个不存在的路径会发生什么？</p>

<p>>>> status, data = this.path.doesnt.exist.get()</p>

<p>>>> status</p>

<p>... 404</p>

<p>因为 __getattr__ 别名为 __getitem__：</p>

<p>>>> owner, repo = 'nnja', 'tweeter'</p>

<p>>>> status, data = gh.repos[owner][repo].pulls.get()</p>

<p>>>> # ^ Maps to GET /repos/nnja/tweeter/pulls</p>

<p>>>> data</p>

<p>.... # {....}</p>

<p>这真心是一些方法魔术！</p>

<p>了解更多</p>

<p>Python 提供了大量工具，使你的代码更优雅，更易于阅读和理解。挑战在于找到合适的工具来完成工作，但我希望本文为你的工具箱添加了一些新工具。而且，如果你想更进一步，你可以在我的博客 nnja.io 上阅读有关装饰器、上下文管理器、上下文生成器和命名元组的内容。随着你成为一名更好的 Python 开发人员，我鼓励你到那里阅读一些设计良好的项目的源代码。 Requests 和 Flask 是两个很好的起步的代码库。</p>

<p>via: https://opensource.com/article/18/4/elegant-solutions-everyday-python-problems</p>

<p>作者： Nina Zakharenko 选题： lujun9972 译者： MjSeven 校对： wxy</p>

<p>本文由 LCTT 原创编译， Linux中国荣誉推出</p>



本页共232段，8580个字符，14056 Byte(字节)﻿

</div>

<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 31){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}

</script>
</div>

</body>
</html>