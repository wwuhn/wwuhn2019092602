<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript">

function goTopEx(){
	var obj=document.getElementById("goTopBtn");
	function getScrollTop(){
			return document.documentElement.scrollTop;
		}
	function setScrollTop(value){
			document.documentElement.scrollTop=value;
		}    
	window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
	obj.onclick=function(){
		var goTop=setInterval(scrollMove,10);
		function scrollMove(){
				setScrollTop(getScrollTop()/111);
				if(getScrollTop()<1)clearInterval(goTop);
			}
	}
}


</script>
<script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>计算复杂性理论与智能的可实现性</title>

<style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.6em;
}
P{
margin:16px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;
}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 105px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 30px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 80px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 55px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 
img{
border:0;
}
.picsay{
color:#930;
font-size:90%;
line-height:110%;
margin-top:-12px;
padding:0;
}
\s*</p>

<p>\s*
 
 
</p>

<p>
</style>
</head>

<body>

<div class="container">
<h4><a href="http://www.tuicool.com/articles/EJvqii">计算复杂性理论与智能的可实现性</a></h4>
<p>【转折——眺望IT巅峰】</p>

<p>现代计算机在转了一圈之后，回到了其诞生最初的起点和本质：有限字长二进制数字的基本计算。并以此为基础，支撑所有的可计算类问题的解决，包括智能类问题。20世纪70年代以来尽管计算机的性能有了极大的提高，但是它的基本原理，不论是理论基础还是工程实现的结构基础，并没有本质的变化。变化的，是因为其性能的持续提高，其应用的深度与广度在日益扩展。</p>

<p>一个问题，只有能够用有限步骤的有限字长二进制数字的基本计算操作来解决，或者说解决到可以接受的程度，才可能由计算机来处理。这样的问题被称为“计算类问题”（Computable），而这样的操作过程被称为算法（Algorithm）。与可计算性相关的理论，自然就成了计算机科学的基础理论中的重要组成部分。而与人工智能相关的研究，由于缺少普遍意义上的基础性与通用性，仅仅被当成了计算机科学的一个分支，用以解决不同的智能应用类问题。</p>

<p>计算机只能处理计算类问题，但是这个世界上确实有许多问题不属于这个类别。计算机科学家构造出的所谓的“停机问题”就是一个不可计算的问题。在形式上可以严格地证明：我们无法通过一个设计好的计算过程（程序/算法），来确定任意一个程序（任意图灵机）在被执行后是否会经过有限的时间，在没有外来干预的情况下自动终止。这说明世界上确实存在不可以用计算来解决的问题。</p>

<p>许多高级智能活动，至少在今天看上去也是不可计算的，虽然我们无法严格地给出形式化的证明。对此有人确实抱有不同的信念，特别是在西方。西方从古希腊开始就有着用数字计算来解释整个世界的传统，这种信念与认为这个世界上发生的一切最终都是机械类过程有关联。这也是当年人工智能热潮一浪高过一浪的重要原因之一。这两种相反的看法，都无法用逻辑来证明，所以也就可能永远无法有最终的结论。</p>

<p>一个问题是否是可计算问题，通常是需要就事论事地来判断：就具体的问题，看看是否能够找到一个算法来解决它。所以，这个问题更多地要靠实验性手段来解决，而不存在一个一般性的逻辑判断方法。而这给计算机应用带来了一个本质性的困难：本应该在事先做出的可实现性（可行性）的判断，许多情况下只能用具体实现的结果来事后部分地验证。这样，对于一个问题，如果我们还没有找到可行的解决方法，并不等于意味着这一定是一个不可计算问题。同时，在我们寻找一个具体现实问题的解决方法的时候，我们可能也并不知道是否真的存在这样一个方法。因而，这种寻找就有可能成为一个毫无意义的努力。当年人工智能领域中的许多失败，都与这个困境有关。</p>

<p>之所以会出现这样的局面，本质上是因为我们期望和能够用计算机来解决的问题非常庞杂，彼此之间可能有巨大的差异。基本上不存在一些一般性方法可以用来分析所有的问题类型。虽然从艾伦•图灵开始，计算机科学家们一直试图用严格的形式化方法来建立计算机的理论基础，但是计算机科学中的许多很重要的普适性判断，比如A•丘奇-图灵论题，还是无法用逻辑证明，只可以用实验来验证。</p>

<p>我们也可以说，计算机科学尽管大量使用了形式化方法，但事实上它更像一个实验性科学，具有很强的工程特征。人工智能探索中的许多失败，从这个角度看也就可以理解了。</p>

<p>因而，在计算机领域，特别是在计算机应用过程中，经验直觉的判断，具有十分重要的作用和价值。</p>

<p>虽然计算类问题在概念上都是可以用计算机来解决的，但是并不是所有的计算类问题，都是现实可计算的。也就是说，有些问题虽然是计算类问题，但是却无法利用有限的存储资源和有限的计算能力在可以接受的时间内完成。这就是计算复杂性理论所研究的问题。</p>

<p>所谓计算复杂性（ComputationalComplexity）理论，其核心主要是研究随着问题规模的变大，不同的计算类问题所需要的计算量是如何增长的。这属于计算的时间复杂性判断。这种增长变化趋势，是用问题规模n的一个函数来表示。如果这个函数的增长趋势快于多项式函数，则认为这样的问题为不可实际计算问题，称为“难解型问题”（Intractable），否则就认为是现实可解的问题，见图1-9。</p>

<p>不同计算复杂度问题随其规模的增长计算量的变化趋势。实际上，上述对于时间复杂性问题的表述多少有点儿似是而非的味道。因为对于一个具体的难解型问题，如果其规模不很大，便可能在可以接受的时间内由计算机处理完；反过来，一个具体的问题其难度即使不超过多项式类问题，只要规模非常大，现实中可能也无法求解。而且，计算机的处理能力也在飞速发展，其现实能力的边界在不断地外推。因而，对于一个具体的问题来说，判断其是否现实可解，还是要具体分析才行。</p>

<p>因此，许多计算机应用人员并没有学习过这些计算复杂性的理论，而同样可以有效地工作，同样可以表现非常出色。我们都知道，事实上一些计算机天才根本就没有受过完整的大学基本教育。这也从一个方面反映出计算机科学的实验性特征。</p>

<p>我们还可以对计算的空间复杂性作分析，即分析计算需要的存储空间的增长趋势。不过这个问题的重要性在一般情况下不如时间复杂性那样高。</p>

<p>即使一个具体的问题的计算复杂性很高，但是我们通常可以通过人为的限制，把它降低到可以用有限资源计算的程度，并得到可以接受的结果。所以相对于计算复杂性来讲，一个问题的可计算性判别，在某些情况下对于实际应用意义更为重要。可是如前所述，由于计算机面对的问题的复杂性和多样性，在理论上找不到一个一般性的方法来帮助我们做这种判断。下面，我们从定性的角度做一些分析，来寻找一些智能类问题可计算性的判定线索，以期对我们在利用计算机来解决复杂问题时有所帮助。</p>

<p>尽管人工智能没有取得计算机科学的基础地位，但是人工智能类的问题，却是无论如何都不应该也无法回避的。因为计算机从它诞生起，就是作为辅助智能的工具而存在，并且随着其性能的持续提高，必将不断地被用于需要更多智慧能力的场合。</p>

<p>人们常常对成功津津乐道，感觉回味无穷；而对失败则兴趣索然，弃之如履。其实，失败给我们的启迪，尽管与成功不同，却同样的珍贵。虽然到今天学者们也无法给“智能”下一个明确的定义，尽管没有一个简单的方法来判断一个问题是否可计算，但是从过去的成功与失败中，我们还是能够得到很多启示，找到一些尽管不是无歧义的严格，但也具有有效指导意义的一些原则。当年人工智能实际上主要走了两条路线。一条是利用冯•诺依曼结构的通用计算机，靠软件来实现智能，如机器下棋等；另外一条路，就是试图构造全新的结构，以期实现智能。如在“联结主义”的信念下产生的人工神经网络等。实践证明，第二条路并没有带来实质性的突破。典型的就是人工神经网络。当时人们热衷于构造人工神经网络，主要不是因为通用计算机的计算能力不足，而是有其他理由。</p>

<p>尽管到今天我们都不确切地知道生理上的神经元内部到底在发生着什么样的过程，但是生理学家们当时发现了大脑的神经元彼此之间有着大量的连接。一些人就依此猜想：尽管单个人工设计的神经元只完成了一个很简单的运算，如果大量的人工设计的神经元彼此之间也都有大量的连接的话，可能就会有奇迹出现。这种企图通过外在形式上的模仿而创造奇迹的尝试，在人类的历史上不知道是否有成功的先例。至少人工神经网络没有成功。</p>

<p>再以BP算法适用的网络为例。其实，如果我们放弃浪漫的想象，就很容易看出这种人工神经网络不过是一种确定性的可计算的非线性函数映射而已，也可以说是一个算法问题。它完全可以在通用计算机上实现，本质上走回了前面说的第一条路。所以，这条路不可能产生什么第一条路无法实现的结果。尽管在人工神经网络泡沫时期曾经有过不少尝试，而事实上不论是当时还是今天，人工神经网络基本上都是在通用计算机上用软件实现的，并没有真的造一个网络出来大规模使用。人工神经网络的硬件实现，唯一可能与普通通用计算机不同的地方，就是在某些条件下其处理速度有可能会更高。所以，人工神经网络应该被看作是一类特定的算法而已。</p>

<p>再具体地看，实现人工智能，有两种不同的思路。其实这也是人类制造各种工具，包括辅助体能工具的两个基本途径。</p>

<p>一种就是遵循人类思维过程，然后加以复现。在这种途径中，人类和机器在解决问题的时候采用的是同样的方法。我们把这种思路称之为“机制模仿（”MechanismImitation）方法。比如机器下棋，它与人一样要把棋的规则记住，然后预测不同的应对步骤将会带来的各种可能的结果，根据预测来决定下一步如何走。</p>

<p>而另外一种思路，也是成功的人工智能应用大多数情况下采用的方式，就是用完全不同的机制（或者说我们不清楚它是否与人脑内部的机制相吻合），来完成某项人类的智能活动。比如图像识别。计算机采用的方式，通常被认为与人对图像的识别过程有本质区别。我们把这种思路称之为“机制替代”（MechanismReplacement）方法。</p>

<p>人工神经网络所走的路，与上两个都不同，是属于外在的“形式模仿”，已经被证明没有前途。所以不再做讨论。而且人类的历史也不断地证明，没有对过程（不论是人工的还是自然的）的本质、原理或机制的深入理解，靠外在形式上的模仿，是不会有真正的进步的。尽管形式模仿有的时候提供了一个进步的起点。</p>

<p>采用机制模仿的条件是：（1）需要解决的问题规模有限或有明确的边界。有明确的边界意味着问题的规模是受限的，或者可以通过人为的限制，有可能将问题的规模控制在一定的范围；（2）大脑解决问题的过程有严格的规则可循，能够提炼抽象为可操作的算法。</p>

<p>比如下棋，棋子与棋盘的规模有明确的边界，下棋的规则也是无歧义的，人们下棋必须遵守这些规则。下棋的盘算过程，可以被抽象为可操作的步骤，每一步可能的选择是有限的。尽管出招前对后果的推断，可以几乎永无穷尽的延展，但是因为事实上人脑对未来的推断也只能进行到有限的程度，所以只要我们做一些事先的限定，这就是一个规模有限的可计算过程，并且可以达到我们设定的期望结果。因此，深蓝可以战胜世界冠军就不足为奇了。</p>

<p>下面我们对上述条件来做一些更深入的分析，帮助我们确定人的思维过程，哪些可以被抽象出来成为可操作的算法，从而可以用计算机来实现。也就是寻找“机制模仿”的可行性判断的一些定性的、更具体的和有指导意义的边界或判定依据。</p>

<p>首先，这个过程必须是显意识过程，而不能是只可意会不可言传的无意识或潜意识过程。因为我们还没有办法通过外部物质手段去深入理解人的意识过程，我们对意识过程的理解主要是依靠意识自身去认识。其次，这个思维过程是受到明确的规则约束的，否则就难以被抽象为算法。下棋就是有明确规则的过程。</p>

<p>所谓无意识过程，是人自己无法窥视的意识过程，潜意识过程则是可以通过心理分析的手段窥视甚至通过努力可以部分显意识化的意识过程，而显意识过程则是指我们自己能够清楚地描述的意识过程。</p>

<p>人识别图像，是大脑神经的一个无意识过程；人更高级的意识过程如直觉感悟，是潜意识过程，虽然可以部分地显意识化，但是却不受明确的规则约束。所以这些过程就都不太可能被抽象出来用计算机实现。除开上面讲的无意识与潜意识过程之外，即使是受到明确的规则约束的</p>

<p>显意识过程，如果它面对的问题的规模没有明确的边界，或者不能有效可控，则这个问题就有可能变成一个不可计算问题，或者是计算复杂性（时间或空间）过大的问题，导致其无法被计算机有效实现。</p>

<p>自然语言的理解，就是属于这样的问题。虽然语言有基本明确的规则（词义与语法），但是需要被理解的语言，如果把环境因素也考虑进来，则近似于无限规模的，或者是不确定边界的。也就是说，理解语言需要采集和处理的数据量过大且具有不确定性，因而变得无法用有限的资源通过计算来实现。所以，一般自然语言的理解，比如通用的机器翻译，到今天为止还是没有找到能够产生一个可接受结果的解决办法。这个问题的出路，可能还是需要通过对问题规模本身的限制来局部地解决。包括对语言的产生和使用环境的有效限制。</p>

<p>当初，人工智能领域的工作者对解决自然语言的理解，乃至于对于一般智能过程的实现，抱有极为乐观的看法。其中一个重要的原因是忽略了或者没有理解，自然语言的理解、包括一般智能的实现所面对的，在本质上是近于无限规模，或边界不确定的问题。这类问题计算机在本质上无法有效地解决。一般意义的学习过程，也属于这一类型的问题。</p>

<p>因为“机制模仿”在于实现人脑的思维过程，所以解决问题的思路便来自于对思维过程的理解、分析和抽象。这需要综合多领域的知识和能力才能做到，包括心理学、以及所涉及问题所处领域的专业知识等。</p>

<p>而“机制替代”方法，则抛开了人脑的内部过程，仅仅在结果上实现同样或者类似的可接受的产出。它解决问题的思路，则来自于对问题本身的分析，而不是受人思维过程的启发。对问题本身的分析包括了问题的产生过程与环境，问题的应用过程与环境等。比如，人脑对手写文字的识别基本是与写字过程没有关系的，但是机器的联机识别，却会把写字的过程信息提取出来加以利用，以便提高识别的正确率。</p>

<p>机制替代法实现的功能，通常是抽象层次比较浅的智能活动。所以我们才能够通过对认识对象的分析找到解决办法。对抽象层次比较深的智能活动，我们只能从人类的思维过程去寻找解决问题的线索，也就是要依靠机制模拟的方法。</p>

<p>机制替代方法在广义上讲，是迄今为止人类制造工具最常用，也是最有效的方法。比如，人造的车辆，使用自然界没有的轱辘；人类的飞行，也是用自然界不存在的推动/牵引加机翼的方式实现的，见图1-10；我们利用太阳能的方式，也与生物完全不同。至今我们没有能够模拟叶绿素的内部过程来利用太阳能，而是主要依靠光伏作用。人工智能领域许多有实用价值的产出也都是这种类型，比如图像与语音的识别等。这里面是否隐含着什么更深的暗示？它是否意味着某些人类的高级智能活动，永远也无法被物化？</p>

<p>图1-10 人类曾试图像鸟一样靠扇动的翅膀飞行，最后却是用推动/牵引加机翼机制模拟需要很强的对自己与他人心理活动的感悟分析能力与抽象建模能力，机制替代则需要对客观对象相关物质或形式化存在性质的深入理解能力，以及创造性地提取对象性质并灵活应用的能力。在实际应用中，这两种方法并不是截然分开的。许多应用是它们的混合形式。</p>
<p></p>

</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>
