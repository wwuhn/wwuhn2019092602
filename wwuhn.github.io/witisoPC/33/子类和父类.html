<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 <script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>子类和父类</title>

 <style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.4em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 105px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 30px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 80px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 55px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 
 img{
 border:0;
 }
 
 \s*</p>

<p>\s*
 
 
</p>

<p>
</style>
</head>

<body>

<div class="container">
<p>子类和父类继承</p>

<p>subclass extends superclass:subclass拥有superclass的全部属性和方法，subclass是superclass的一员，具有清晰的层次关系；</p>

<p>subclass implements interface,subclass实现interface的功能，subclass与interface不需具有明确的层次关系；</p>

<p>&quot;is a&quot;:the relation between subclass and  superclass;</p>

<p>&quot;has a&quot;:the relation between classes and  interfaces;</p>

<p>What you can do in a subclass</p>

<p>A subclass  inherits all of the public and protected memebers of its parent,no matter what  package the subclass is in,If the subclass is in the came package as its  parent,it also inherits the package-private members of the parent.You can use  the inherited members as is,replace them,hide them,or supplement them with new  members:</p>

<p>1 the inherited fields can be used directly just like  any other fields;</p>

<p>2 You can declared a field in the subclass with the  same name as the one in the superclass,thus hiding it(not recommended);</p>

<p>3 You can declare new fields in the subclass that are  not in the superclass;</p>

<p>4 the inherited method can be used directly as they  are;</p>

<p>5 You can write a new instance method in the subclass  that has the same signature as the one in the superclass,thus overriding it.</p>

<p>6 You can write a new static method in the subclass  that has the same signature as the one in the superclass thus hiding it;</p>

<p>7 You can declare a new method that are not in the  superclass;</p>

<p>8 You can write a subclass constructor that invokes  the constructor of the superclass,either implicitly or by using the keyword  super;</p>

<p>之所以使用extends语句，是因为子类是对超类及其超类的属性和行为的扩展；</p>

<p>继承就是重复利用的意思，父类的所有成员都会被子类继承，子类可以加入新的成员；</p>

<p>父类定义的方法架构（非内容部分，又称作方法名称，method signature)如果是OK的，只不过内容并不适用在子类的环境，这时就需要修改原方法的内容，以适合子类的需要，如继承《三字经》，总体是好的，但与时俱进就有必要了。这种维持原方法的架构而只改变内容的技巧被称作改写(override),只发生在继承关系中；</p>

<p>方法改写的原则：</p>

<p>1 方法名称一致；</p>

<p>2 参数的类型与个数一致</p>

<p>3 返回值的数据类型一致；</p>

<p>4 final方法不能被改写；</p>

<p>this代名词，代表所在类现阶段执行的对象，可以使用this来调用；</p>

<p>super代表父类的的对象；</p>

<p>覆盖：父类和子类之间，把父类的方法继承过来并改写其方法体，让其适应新的需要；</p>

<p>重写：同一个类中，有相同的方法名，但参数列表不一样；</p>

<p>重载：基于继承；</p>

<p>1 方法被重写后，返回类型为基本数据类型时，重写方法的返回必须一样；</p>

<p>2 静态方法是不能被重写的；</p>

<p>3 父类的静态方法可以被子类的静态方法覆盖；</p>

<p>4 父类的静态方法不能被子类的静态方法覆盖；</p>

<p>5 父类的静态方法不能被子类的非静态方法覆盖；</p>

<p>6 重写的方法不能有被重写的方法更高的访问限制；</p>

<p>7 重写的方法不能有被重写的方法更多的异常；</p>

<p>通过类的继承，子类不但可以得到父类中的成员变量和方法，还可以拥有自己的成员变量和方法来扩充自己的功能，并且可以通过覆盖父类的方法改变自己的行为，使用继承最大的好处是可以实现代码的重复利用。</p>

<p>过多的继承也是不可取的，因为它可能会为子类的改变带来困难，在软件工程理论中，一个软件要做到高内聚、低耦合。所谓内聚指的是模块内元素之间彼此关联的程序，可以理解为软件中类内部之间的关联程序，所谓耦合指的是软件中几个不同的模块之间彼此相互关联的程序，可以理解为类与类之间相互依赖的程序。过多的继承带来的问题就是耦合性增加了。最明显的问题是对顶层父类的改变可能会使与其相关的子类出现不正确的操作。</p>

<p>super关键字适用于子类访问父类的隐藏成员；</p>

<p>在Java语言中，当创建一个对象后，Java虚拟机就是为其分配一个指向对象本身的指针，这个指针就是自己。This只能用在类的非静态方法或构造方法中；</p>

<p>子类和父类是否是在同一包中，所继承的成员是有区别的；</p>

<p>成员变量的隐藏：在子类中定义和父类同名的变量；</p>

<p>子类可以隐藏父类的成员变量和重写父类的方法，如果在子类中想用被子类的隐藏的方法，可以使用super,使用父的构造方法可以使用super();</p>

<p>super调用父类被覆盖的方法，构造方法不能被继承，可用super调用；</p>

<p>super适合于子类访问最接近父类的隐藏成员和构造方法；</p>

<p>this:是一个指向对象本身的指针；</p>

<p>1 用在类的非静态方法和构造方法中；</p>

<p>2 访问被局部变量屏蔽的成员变量（如果两类变量名字相同，成员变量会被屏蔽）；</p>

<p>3 引用当前对象：return this;</p>

<p>4 调用构造方法：this(参数列表);</p>

<p>如同基本数据类型可以转型，在有继承关系的父类与子灰之间也可以进行自动或强迫转型；</p>

<p>父类引用指向子类对象；</p>

<p>子类对象也是父类的对象</p>

<p>Collection c=new ArrayList();</p>

<p>1 单一继承性：子类只能有一个超类，而超类可以有多个子类；</p>

<p>2 子类继承超类的所有成员；</p>

<p>3 子类可以创建自己的成员；</p>

<p>4 子类不能继承超类的构造器，只能在构造器中通过super()调用超类的构造器；</p>

<p>5 子类的构造器首先要调用超类的构造器；</p>

<p>6 多态性之一：子类的成员隐藏和覆盖超类中相同的成员；</p>

<p>7 多态性之二：超类的对象可以对子类的实例引用；</p>

<p>8 由abstract和final修饰的类指示类的是否必须或不能被继承；</p>

<p>9 由private修饰的成员变量和方法，子类不能访问；（可以通过super关键字访问）</p>
<p>

</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>
