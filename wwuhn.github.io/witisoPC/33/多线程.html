<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 <script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>多线程</title>

 <style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.4em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 105px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 30px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 80px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 55px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 
 img{
 border:0;
 }
 
 \s*</p>

<p>\s*
 
 
</p>

<p>
</style>
</head>

<body>

<div class="container">
<p>多线程</p>

<p>程序能同时处理多个任务的功能叫多线程，也就是程序执行时多条执行路线同时进行，每条对应一个线程（一个任务）（一个由继承Thread类或实现Runnable接口的类的run()方法实现）（注意main()方法也是一个线程，叫主线程，如在main()方法中有开始一个xxx.start()线程，则分支执行路线是两条，一条是main(),一条是xxx;）</p>

<p>Java中至少有一个线程，即主线程main(),JVM如果发现还有其它线程存在，那么就会交替执行主线程和其他线程；</p>

<p>在一个程序的一个进程内同时运行不同的多个程序块；</p>

<p>每个进程都有一段专用的内存区域，而线程却共享内存单元；</p>

<p>如何激活线程？</p>

<p>1 线程必须扩展自thread类，使自己成为它的子类；</p>

<p>2 线程的处理必须编写在run()方法内；</p>

<p>线程的安全性</p>

<p>所谓线程的安全性是指同时有两条以上线程想要修改这个对象内的数值，先进入这个对象的线程才有权修改，第二条线程要一直等到第一条线程修改完毕并离开这个对象后才可以开始修改，要达到这种锁定效果，必须使用synchronized关键词；如果不使用它，可能会发生错误的数据覆盖情形。这种概念与文件共享的概念十分相同，只不过现在锁定的是内存中的对象数据；</p>

<p>进程：单个程序；</p>

<p>线程：单个程序的代码段；</p>

<p>程序是一段静态代码，是一组计算机指令的集合，它以文件的形式存储在计算机磁盘上，是应用程序执行的蓝本；</p>

<p>进程是程序在其自身地址空间中的一次动态执行过程，它是资源申请、调度和独立运行的单位；因此它使用了CPU资源，而程序不能申请CPU资源，不能调用系统的其他资源，也不能作为独立运行的单位，因此程序不占用系统的运行资源。一个程序可以有多个进程，如打开多个记事本，则每个记事本对应一个进程；</p>

<p>在一个进程的执行过程中，可以产生多个进程；</p>

<p>多线程的优势：</p>

<p>1 多线程编程简单，效率高，使用多线程可以在线程间直接共享数据和资源；</p>

<p>2 适合于开发服务程序，如web服务，聊天服务等；</p>

<p>3 适合于开发有多种交互接口的程序，如聊天程序的客户端，网络下载工具；</p>

<p>4 适合有GUI，又有计算量的程序，如word,Excel等；</p>

<p>即使只有一个线程，使用多线程也是有好处的，如可以在程序中启动、停止和暂停线程，如果不使用线程，将无法实现这样的控制；</p>

<p>多核电脑能同时并发几个进程（程序，也有多进程的程序）（单核电脑电脑通过分时共享也可并发），如一边听音乐一边浏览网页，一边上QQ等；有时候单个程序也希望能同时做好几件事情，如一个网络在线流媒体播放软件，除了解码声音与视频外，还得从网上下载缓冲，如果是基于P2P技术的话，  同时还有对外上传数据，这种能同时做好件事的软件程序，称为并发程序，多个进程都会在内存中占有一段独占的内存空间；</p>

<p>主线程:main();</p>

<p>线程入口:run(),start()方法启动；</p>

<p>线程是一种组织程序的方式，使其能够同时做多项工作，需要同时执行的每项任务都运行在自己的线程中，这通常是通过将每项任务作为一个类来实现的；</p>

<p>可作为线程运行的Java类常被称为“线程化类”；</p>

<p>即使你不写多线程的程序，Java程序本身也是多线程的，main()方法被调用时多线程机制就已经存在了，我们将程序所处的线程称为前台线程，在Java中，为前台线程提供服务的线程称为后台线程会伴随着运行起来，所以后台程序也称为“守护”线程或“精灵”线程，JVM的垃圾回收机制就是由后台线程完成的。不前台线程都死亡后，后台线程会自动死亡。</p>

<p>程序能同时处理多个任务的功能叫多线程，是独立运行的程序部分；</p>

<p>要让Java程序同时处理多项任务，必须将程序组织成线程，根据需要程序可以有任意多个线程，它们将同时运行，互不影响。</p>

<p>run()方法</p>

<p>线程的主要工作是在run()方法中完成的，该方法相当于Java应用程序中的main()块语句；</p>

<p>线程启动时将调用run()方法；</p>

<p>run()方法应完成线程要完成的任务；</p>

<p>1 调用构造函数Thread()创建线程化类的对象；</p>

<p>2 调用start()方法启动线程；</p>

<p>线程的状态和生命周期</p>

<p>新建状态：new Thread();</p>

<p>就绪状态：start();</p>

<p>运行状态：取决于调度运行机制的调度；</p>

<p>阻塞状态：sleep();</p>

<p>死亡状态：run()执行结束后；</p>

<p>Java语言使用Thread类及其子类的对象来表示线程，一个线程的完整生命周期包括如下5种状态：</p>

<p>1 新建</p>

<p>当一个Thread类及其子类的对象被声明创建时，新生的线程对象处于新建状态，此时它已经有了相应的内存空间和其他资源；</p>

<p>2 就绪</p>

<p>线程创建之后就具备了运行的条件，一旦轮到它来享用CPU资源时，即JVM将CPU的使用权切换给该线程时，此线程就可以脱离它的主线程，独立开始自己的生命周期了；</p>

<p>线程创建后仅仅是占有了内存资源，在JVM管理的线程中还没有这个线程，此线程必须调用start()方法（从父类继承的方法）通知JVM，这样JVM就会知道又有一个新线程排队等候切换了；</p>

<p>3 运行</p>

<p>当JVM将CPU的使用权切换给线程时，如果线程是Thread的子类创建的，该类run()方法立即执行。所以，必须在子类中重写父类的run()方法；</p>

<p>4 中断，有4种原因可以产生中断</p>

<p>4.1 JVM将CPU资源从当前线程切换给其他线程，使本线程让出CPU的使用权处于中断状态；</p>

<p>4.2 线程使用CPU资源期间，执行了sleep()方法，使当前线程处于休眠状态，让出CPU的使用权，牌中断状态，等过了参数规定的时间后，该线程重新进到线程队列中排队等候CPU资源，以便从中断处继续执行；</p>

<p>4.3 线程使用的CPU期间，执行了wait()方法，使得线程进入等待状态，它不会主动进行到线程队列中等候CPU资源，必须由其他线程调用notify()方法通知他，使得它可以重新进到线程队列中重新排队等候CPU资源，以便从中断处继续执行；</p>

<p>4.4 线程使用CPU资源期间，执行某个操作进入阻塞状态，比如读/写操作引起的阻塞，进入阻塞状态进线程不能进入排队队列，只有当引起阻塞的原因消除后，线程才重新进入，以便从原来中断处继续执行；</p>

<p>5 死亡</p>

<p>所谓死亡状态就是线程释放了实体，即释放了分配给线程对象的内存空间的内存单元，其原因有二：</p>

<p>5.1 run()方法中的语句全部执行完毕；</p>

<p>5.2 线程被提前强行终止；</p>

<p>要实现多线程，就必须在主线程或其他存在的线程中创建新的线程对象，创建线程的方法有两种：</p>

<p>1 继承Thread类，以子类对象的方式创建线程，要重写run()方法，run()方法是线程体，说明线程的具体操作。在程序需要创建线程时，只需创建该子类的对象，然后调用start()方法即可；</p>

<p>public class ThreadDemo extends Thread{</p>

<p>public void  run(){</p>

<p>System.out.println(&quot;Hello Java Thread&quot;);}</p>

<p>public  static void main(String[] args){</p>

<p>new  ThreadDemo().start();}}</p>

<p>用start()方法启动线程后，会自动调用run()方法；</p>

<p>2 实现Runnable接口的方式创建线程</p>

<p>继承Thread类创建线程的优点是，可以在子类中增加新的成员变量，使线程具有某种属性，也可以在子类中新增加方法，使线程具有某种功能。但是，Java不支持多继承，Thread类的子类不能再扩展其他的类。可以通过接口的形式来实现多重继承，即通过定义一个实现Runnable接口的类来实现线程，然后将该类的一个对象作为目标对象传递给Thread类的构造方法来创建Thread对象；</p>

<p>public class RunnableDemo implements Runnable{</p>

<p>public void  run(){</p>

<p>System.out.println(&quot;Hello Java Thread&quot;);}</p>

<p>public  static void main(String[] args){</p>

<p>new  Thread(new RunnableDemo()).start();}}</p>

<p>线程用Thread类和Runnable接口表示，它们都位于java.lang包中；</p>

<p>1 通过继承Thread类来创建线程，覆写run()方法；run()方法是每一个线程的入口，外界启动一个线程时，并不会自动调用run()方法，而是调写start()方法来启动一个线程；</p>

<p>public class Threaddemo extends{}</p>

<p>2 通过实现Runnable接口创建线程；</p>

<p>public class ThreadDemo implements implements  Runnable{}</p>

<p>以上两种方法一个用继承，一个用实现接口，但在形式上是颇为的，首先，线程的特征都体现在run()方法，实现Runnable接口的类必须实现run()方法，两种实现的run()方法是完全一样的；</p>

<p>对于继承而言，直接用自己的类名new就可以，但是用接口的则不能，只能用Thread类来new一个线程对象，new的时候用实现了Runnable接口的对象作为参数；</p>

<p>用Runnable接口来创建线程就是在一个类中实现Runnale接口，并在该类中重写run()方法；</p>

<p>线程的常用方法</p>

<p>1 设置和获取线程的名字：setName(),getName();</p>

<p>2 返回正在执行的线程：currentThread();</p>

<p>3 挂起线程：sleep(),wati();</p>

<p>4 中断线程：interrupt(),可以结束休眠重新进入就绪队伍；</p>

<p>5 终止线程：可以设置一个boolean变量，再配合return语句使线程安全的终止；</p>

<p>6 检查线程：isAlive();</p>

<p>7 线程联合：join()一个线程需要等待另一个线程执行完毕后才开始运行，如线程A执行期间，执行B.join();则线程A立即中断，一直等到联合的线程B执行完毕。</p>

<p>8 守护线程：也称为用户线程，主要是为其他线程提供支持的，一个线程调用setDaemon(true)方法可以将自己设置成一个守护线程；</p>

<p>在JVM中实现了一个负责管理线程的线程高度器，线程的高度通常是抢占式，而不是时间片式；</p>

<p>使用synchronized实现线程同步</p>

<p>所谓线程同步是指多个纯种同时访问某一个共享资源时，需要保证在同一时间最多只有一个线程访问该资源，在Java中，每一个对象都有一个锁标志，对象是否能被有效地存取是和这个锁标志有关的；</p>

<p>synchronized(this)锁定当前对象；</p>

<p>当一个线程使用一个同步方法时，该线程就会一直占据着该同步方法的“锁”，直到执行完毕，自动释放该锁，但可以通过wait()方法来主动释放同步方法的锁；</p>

<p>notify()和wait()必须出现在同步块中；</p>

<p>死锁</p>

<p>如果有两个线程A和B，线程A获取对象A的锁，要再获取对象B的锁，而线程B这时已获取了B的锁并且也需要获取对象A的锁，就形成了死锁；</p>

<p>死锁是资源无序的使用而带来的，解死锁只要线程获取对象锁的顺序一致即可；</p>

<p>多线程的互动处理：</p>

<p>使用wait(),notify()方法；</p>

<p>当一条线程进入wait()时，另一个线程在一定条件下可调用notify()方法唤醒wait线程；notify()只会唤醒将存取同一对象但暂处于wait状态的线程；</p>

<p>实现Runnable接口，只需要重写run(),但这样一来却少了能够启动新线程的start(),所以必须通过Thread类的构造方法将Runnable对象转换成Thread对象，才能够调用Start()来启动新线程；</p>

<p>方法调用的运行流程（如图）</p>

<p>public class{</p>

<p>public static  void main(String[] args){</p>

<p>m1();</p>

<p>public  static  void m1(){</p>

<p>m2();</p>

<p>m3()</p>

<p>}</p>

<p>public static void m2(){}</p>

<p>public static void m3(){}</p>

<p>}</p>
<img src="多线程1.jpg" />

<p>synchronized:锁定某类某一方法或方法内的某一区间，在run()方法内这个类对象调用这一方法；</p>

<p>1 新建 Thread td=new Thread();</p>

<p>2 就绪 td.start();</p>

<p>3 运行 auto invoke sun();</p>

<p>4 中断 sleep(),wait();</p>

<p>5 死亡 finished run();</p>

<p>Synchronized锁定任何对象所占用的内存。</p>
<p>
<img src="多线程2.jpg" />
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>
