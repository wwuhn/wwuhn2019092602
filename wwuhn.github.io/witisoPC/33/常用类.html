<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 <script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<script type="text/javascript">
 
 function goTopEx(){
        var obj=document.getElementById("goTopBtn");
        function getScrollTop(){
                return document.documentElement.scrollTop;
            }
        function setScrollTop(value){
                document.documentElement.scrollTop=value;
            }    
        window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
        obj.onclick=function(){
            var goTop=setInterval(scrollMove,10);
            function scrollMove(){
                    setScrollTop(getScrollTop()/111);
                    if(getScrollTop()<1)clearInterval(goTop);
                }
        }
    }


</script>
<title>常用类</title>

 <style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"宋体";
width:75.29%;
line-height:1.4em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:15px;
margin-bottom:0px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}


#goTopBtn {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color:#eee;
    color:#000;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 105px;
    _bottom: "auto";
    cursor: pointer;
    opacity: .6;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 30px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 80px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    background-color: #eee;
    color: #fff;
    font-size: 12px;
    text-align: center;
    position: fixed;
    _position: absolute;
 
    right: 10px;
    bottom: 55px;
    _bottom: "auto";
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
}
 
 img{
 border:0;
 }
 
 \s*</p>

<p>\s*
 
 
</p>

<p>
</style>
</head>

<body>

<div class="container">
<p>常用类</p>

<table cellspacing="0" cellpadding="0">
  <col width="24%" />
  <col width="24%" />
  <col width="24%" />
  <col width="24%" />

  <tr height="19">
    <td height="19"><a href="#Calendar">Calendar类</a></td>
    <td><a href="#object">Object类</a></td>
    <td><a href="#collection">集合类    collection</a></td>
    <td><a href="#laoji">老版集合类</a></td>
  </tr>
  <tr height="19">
    <td height="19"><a href="#ge">格式设定类</td>
    <td><a href="#reflect">反射类Reflect</a></td>
    <td><a href="#list">List类</a></td>
    <td>&nbsp;</td>
  </tr>
  <tr height="19">
    <td height="19"></td>
    <td><a href="#ni">匿名类</a></td>
    <td><a href="#set">set类</a></td>
    <td>&nbsp;</td>
  </tr>
  <tr height="19">
    <td height="19"></td>
    <td><a href="#nei">内部类</a></td>
    <td><a href="#map">map类</a></td>
    <td>&nbsp;</td>
  </tr>
  <tr height="19">
    <td height="19"></td>
    <td><a href="#chou">抽象类</a></td>
    <td><a href="#fan">泛型</a></td>
    <td></td>
  </tr>
</table>
<h4>Calendar类<a name="Calendar" id="Calendar"></a></h4>

<p>Calendar cal=Calendar.getInstance();</p>

<p>cal.set(2103,10,6);</p>

<p>int week=cal.get(Calendar.DAY_OF_WEEK)-1;</p>

<p>System.out.println(&quot;2013-11-6是星期&quot;+week);</p>


<h4>格式设定类：<a name="ge" id="ge"></a></h4>

<p>1 Format类（java.text.*;)</p>

<p>2 Formatter类（java.text.*;)</p>

<p>3 java.io.PrintStream类也提供了printf()方法，它可以搭配Formatter类所使用的样式符号，以强化格式设定的能力；</p>

<p>4 Pattern类；（配合正则表达式）</p>

<p>5 Matcher类；（配合正则表达式）</p>

<p>格式设定相关类Format,Formater,可以帮助你将数字格式化，也可以将时间或文字设成你想要的格式。</p>

<p>printf()格式化输出；</p>

<p>System类提供了一些方法和对象，可以用来接受键盘输入、在屏幕上打印文本和对文件进行输入和输出等功能；</p>

<p>Math类只封装了功能，它不需要也不必隐藏数据。由于没有数据，因此也不必担心生成对象以及初始化字段。</p>

<p>Math.random()将返回一个数d,0&lt;=d&lt;1;Math.random*n将返回一个数dn,0&lt;=dn&lt;n.</p>

<p>枚举类型</p>

<p>[访问控制符] enum 枚举类型名{value,vlae,…}</p>

<p>1 可以定义在类的内部，也可以定义在类的外部；</p>

<p>2 其中定义的value都默认为：public static final，用逗号分隔多个value,比较常用的是用它来声明一组常量；</p>

<p>3 也可在常量声明后声明方法（最后一个常量用“；”；）</p>

<p>4 由于枚举类型默认继承了java.lang.Enum类，所以不能再继承其它的类了；</p>

<h4>map类<a name="map" id="map"></a></h4>

<p>Map架构，一次将键名和键值放入；</p>

<p>TreeMap树映射：TreeSet适合用于数据的排序，节点是按存储的对象的大小升序排列。而TreeMap类实现了Map接口，该映射根据其键的自己顺序进行排序，歌者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。</p>

<p>TreeMap最大的好处是得到已经排好序的结果。且它是含有subMap()方法唯一Map，利用它可以返回树的一部分。</p>

<p>Map接口</p>

<p>put(Obj key,Obj value);</p>

<p>get(Obj key);</p>

<p>HashMap散列映射实现了Map接口，提供键与值之间的一个映射。它不保证映射的顺序，特别是不保证该顺序恒久不变。聊了不是线程同步以，HashMap类与HashTable大致相同。</p>

<h4>set类<a name="set" id="set"></a></h4>

<p>HashSet散列集类实现了接口Set,HashSet灰中的绝大方法都是接口方法的实现。散列集在数据组织上类似数学上的集合，可以进行“交”、“并”、“差”等运算。</p>

<p>TreeSet树集类实现set接口，它的大部分方法都是接口方法的实现，用该类创建的对象称为树集。TreeSet基于“红－黑树”机制，这样可以获得一个顺序集合。</p>

<p>在创建树集时，可以自己规定元素按什么“大小”顺序排列。这样必须实现接口.java.lang.Comparable，使某个类具有比较能力。接口Comparable中只有一个comparaeTo(Object o)方法，当这个Object参数大小该方法所属的对象是返回负整数，等于该方法所属的对象时返回零，小于该方法所属的对象时返回正整数。</p>

<p>Hashset用哈希表实现的容器；</p>

<h4>List类<a name="list" id="list"></a></h4>

<p>ArrayList动态数组</p>

<p>泛型将程序代码的类型检查提前到了编译期间，对于错误，越早通知程序员越好；</p>

<p>泛型使得javac可以在编译期间对集合中加入的对象进行检查，如果加入了不同类型的类，那么编译器就会报错，而不必等到运行期间再进行相关的类型转换。和原来没有使用泛型相比，它将原来需要在运行时期才有发现的异常提前到了编译期间。</p>

<p>泛型一般用于集合类；</p>

<p>ArrayList动态数组是可以提供可动态增长的基于序列号的数组功能的集合类，其主要的方法有添加、删除、设置、获取对象等。它的用法与数组几乎相同，只是可以动态改变长度。</p>

<p>LinkedList链表：由若干个称为节点的对象组成的一种数据结构。每个节点含有一个数据和下一个节点对象的引用，称为单链表，或含有一个数据并含有上一个节点对象的引用和下一个节点对象的引用，称为双链表。</p>

<p>ArrayList管理着对象引用的一个内部数组。最终，数组的全部空间有可能被用尽。这就显示出数组列表的操作魅力：如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。如果已经清楚或能够估计出来数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity(100);</p>

<h4>集合类  collection<a name="collection" id="collection"></a></h4>

<p>著名计算机科学家沃思提出：程序＝数据结构+算法。在Java语言中常用的数据结构主要包括数组、链表、队列、栈等，而常用的算法主要是排序和搜索。Java将常用的数据结构和算法抽象出来形成一个Collection类；</p>

<p>一个数组可以容纳多个变量，但是数组一旦创建，其容量大小是固定的，不能动态地改。Collection类提供类似存入对象的功能，但其数据长度可以动态地改变，同时还封装了各种排序、搜索算法；</p>

<p>Collection把集合类的接口和实现分开，里面包含了比较多的类，其分类主要的数据存储有无顺序和是否可以重复来区分；</p>

<p>实际上只有三种容器：Map,List,Set,但是每种接口都不止一个实现版本;</p>

<p>数组、List建立的是数字索引与对象的关联；</p>

<p>Map是一种将对象（而非数字）与对象相关联的设计；</p>

<p>Set是数学集合的抽象模型；</p>

<p>List是一个有序的集合（有时被称为序列），可以包含重复；</p>

<p>Map是数学函数的抽象模型，是一种包含链值对象元素的集合；</p>

<p>Array读快改慢</p>

<p>Linked改快读慢；</p>

<p>Hash两者之间；</p>

<p>各种集合、接口、类所部分具有的特性：</p>

<p>元素、有顺序性、排序性、不可重复、FIFO/LIFO,有健值、健值不可重复，健值有排序性；</p>

<p>对象的对象；</p>

<p>A collection is an object that represents a group of  objects.The primary advantages are:</p>

<p>1 reduces programming efforts by providing useful  data structure and algoriths so you don't have to write them yourslef.</p>

<p>2 Increase performance by providing high-performance  implementations of useful data structures and algoriths.</p>

<p>Hash表是以结点的关键字为自变量，构成一个散列函数，其值为元素的存储位置；哈希表也称为散列表。</p>

<p>集合类是Java数据结构的实现，在写程序时，经常需要和各种数据打交道，为了处理这些数据而选用数据结构对于程序的运行效率非常重要；</p>

<p>容器，存放数据，要对数据进行的操作，包括访问、插入、删除元素等操作，不同的数据结构和算法的组合在不同的操作方法具有不同的优势或效率；</p>

<p>遍历traverse：对集合中的每一个元素依次执行相似的操作；</p>

<p>集合collection:是一个用来存放其他对象的对象；</p>

<p>很多数据结构存在的原因都与计算机的速度有关，如字符串和列表；如果不考虑速度因素，列表这一数据结构是可以包含字符串的；</p>

<p>所有容器都有某种用来处理元素置入和取出的方法；</p>

<p>不同容器提供了不同类型的接口和方法；</p>

<p>不同容器对于某些操作具有不同的效率；</p>

<p>存入集合的对象都泛型化，向上转型为Object,取出时需要向下转型为其原本的类型（除非你只是使用Object所具有的行为属性）；</p>

<p>在实现方法时，选择不同的数据结构会导致其实现风格以及性能存在着很大的差异。需要快速地搜索成千上万个有序的数据项吗？需要快速地在有序的序列中插入元素或删除元素吗？需要建立键与值之间的关联吗？</p>

<p>数组和数组列表都有一个重大缺陷，这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。在数组中间的位置插入一个元素也是如此。另一个数据结构，链表解决了这个问题。尽管数组在连续的存储位置上存放对象引用，但链表却将每个对象存入在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java程序设计语言中，所有链表实际上都是双向链接的（doubly linked)，即每个结点还存放着指向前驱结点的引用。从链表中间删除一个元素是一个很轻松的操作，即需要对被删除元素附近的结点更新一下即可。</p>

<p>链表和数组可以按照人们的意愿排列元素的次序。但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中包含的元素很多，将会消耗很多时间。如果不在意元素的顺序，可以有几种能够快速查找元素的数据结构，其缺点是无法控制元素出现的次序，它们将按照有利于其操作目的的原则组织数据。</p>



<h4>Object类<a name="object" id="object"></a></h4>

<p>object类是所有Java类的顶层类，如果一个类没有使用extends关键字扩展任何类，则编译器自动将创建的类视为Object类的子类；Object类的所有方法都被每个类继承。如equals(),toString(),clone()等；</p>

<p>在Javak中，所有的类都源于一个“神通广大的超类”，它就是Object.</p>

<p>Java类架构的根类：object类，通过这层关系，所有类都可以调用或改写object类所定义的方法；</p>

<p>eauals()方法 public boolean  equals(Object obj):Object对象调用该方法用于比较同一个类的两个不同的对象是否具有相同的内容；</p>

<p>&quot;==&quot;比较的是两个对象引用是否指向同一对象，即判断它在内存中是否存在同一块区域；</p>

<p>finalize()清除对象自己所占用的内存资源；</p>

<p>Object类定义了一些所有对象的最基本的状态和行为，包括与同类对象相比较，转化为字符串等。</p>

<p>clone()方法</p>

<p>Point p=new Point(20,30);</p>

<p>Point pCopy=p.clone();</p>

<p>equals()</p>

<p>Integer one=new Integer(10),another=new Integer(10);</p>

<p>if(one.equals(another))</p>

<p>System.out.println(&quot;Objects are equal.&quot;);</p>

<p>getClass()</p>

<p>返回Class类的一个对象，这个Class类的对象的内容是调用getClass()对象的类的信息，它包含有调用getCalsss()对象的类名、超类名、所实现的接口等。通过对这个Class对象的访问，可以很好地获得调用getClass()对象的类的全面可用的信息。</p>

<p>Point p=new Point(20,30);</p>

<p>System.out.println(&quot;对象p的类名是：&quot;+p.getClass().getName());</p>

<p>toString()</p>

<p>以字符串的形式返回当前对象的有关信息。</p>

<h4>反射类Reflect<a name="reflect" id="reflect"></a></h4>

<p>反射是Java语言的特征之一，它允许运行中的Java程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。Java的这一能力在实际应用中用得不是很多，但是在其他的程序设计语言中根本就不存在这一特性。例如，Pascal、C或者C++中就没有办法在程序中获得函数定义相关信息。</p>

<p>Reflect是Java被视为动态（或准动态）语言的关键，允许程序于执行期Relfection APIs取得任何已知名称之class的内部信息，包括package,type parameters,superclass,implemented interfaces,inner  class,outer class,fields,constructors,methods,modifiers,并可在执行期生成instances、变量fields内容或唤起methods.</p>

<p>Java的类反射所需要的类并不多，它们分别是:Class,Object,Field,Constructor,Method.</p>

<p>Class类的实例用来封闭对象运行时的状态。当一个类被加载且创建对象时，和该类相关的一个类型为Class的对象就会自动创建。Class类本身不提供构造方法，因此，不能使用new运算符和构造方法创建一个Class对象。任何对象调用getClass()方法都可以获得和该对象相关一个Class对象。</p>

<p>反射类：允许程序在执行期生成instance,变量fields或调用method;</p>

<p>反射为Java程序在运行时提供了动态的能力，而注解允许通过一定的方式编写描述类的元数据，这些元数据可以为编译器提供信息，也可以进入字节码文件在运行时使用。</p>

<p>利用反射可以在运行时对程序进行动态的控制。</p>

<p>在Java程序的运行过程中，每个类在被加载后都在内存中产生一个对应的Class类对象，代表一个类，携带类的相关信息，主要包括构造器、方法、成员变量等。</p>

<p>Field、Method、Constructor为java.lang.reflect包中的类，它们的对象分别代表成员变量、方法、构造器，分别携带对应成员变量、方法、构造器的信息。</p>

<p>获取一个类对应的Class对象的方法</p>

<p>1 forName()方法；</p>

<p>2 getClass()方法；</p>

<p>如果想在运行时对程序进行动态控制，就需要使用反射技术，像现在流行的Tomcat servlet容器。</p>

<p>reflection library提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。这项功能被大量地应用于JavaBean中，它是Java组件的体系结构。</p>

<p>能够分析类能力的程序被称为反射(reflective).</p>

<p>1 在运行中分析类的能力；</p>

<p>2 在运行中相看对象，如，编写一个toString方法供所有类使用；</p>

<p>3 实现数组的操作代码；</p>

<p>4 利用Method对象；</p>

<p>Class forName()可以获得类名对应的Class对象；如果类名保存在字符串中，并可在运行中改变，就可以使用这个方法。</p>

<p>将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象；</p>

<p>static Class forName(String className)</p>

<p>返回描述类名为className的Class对象；</p>

<p>反射机制最重要的内容：检查类结构。</p>

<p>Java.lang.reflect包中有三个类Field、Method和Constructor；三个类都有一个getName()的方法，用来返回项目的名称。三个类的getXxx()方法将分别返回Xxx数组；（Xxx是指Field、Method和Constructor）；</p>

<p>反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序来说极其实用，但是通常不适于编写应用程序。</p>

<h4>匿名类 <a name="ni" id="ni"></a></h4>
<p>匿名内部类将类定义和实例化写到一起，创建类的同时创建了对象；</p>

<p>定义：</p>

<p>匿名类是没有有名字的类，它们不能被引用，只能在创建时用New语句来声明它们。匿名类的声明是在编译时进行的，实例化在运行时进行，这意味着for循环中的一个new语句会创建相同匿名类的几个实例，而不是创建几个不同匿名类的一个实例。</p>

<p>匿名类的目的是在某个地方需要特殊的实现，因此在该处编写其实现，并获取它的实例，调用它的方法。不要在匿名内部类编写其他的方法，是不可见的。</p>

<p>形式为：new &lt;类或接口&gt; &lt;类的主体&gt;</p>

<p>匿名类的实现方式：</p>

<p>1. 继承一个类，重写其方法</p>

<p>2. 实现一个接口，可以是多个</p>

<p>public class TestAnonymousClass{</p>

<p>public static  void main(String args[]){</p>

<p>TestAnonymousClass testAnonymousClass=new TestAnonymousClass();</p>

<p>testAnonymousClass.show();</p>

<p>}</p>

<p>//在这个方法中构造了一个匿名内部类</p>

<p>private void  show(){</p>

<p>Out anony=new  Out(){    // 获取匿名内部类实例</p>

<p>void  show(){    //重写父类的方法</p>

<p>System.out.println(&quot;this is Anonymous InterClass showing.&quot;);</p>

<p>}</p>

<p>};</p>

<p>anony.show();// 调用其方法</p>

<p>}</p>

<p>}</p>

<p>// 已有类Out；匿名内部类通过重写其方法获得另外的实现</p>

<p>class Out{</p>

<p>void show(){</p>

<p>System.out.println(&quot;this  is Out showing.&quot;);</p>

<p>}</p>

<p>}</p>

<p>匿名类可以写到一个方法的参数列表中；</p>

<p>1 与类有关的匿名类</p>

<p>当使用类创建对象时，允许把类体和对象的创建结合在一起；</p>

<p>new Human(){</p>

<p>类体}</p>

<p>2 与接口有关的匿名类</p>

<p>如果某个方法的参数是接口类型，那么就可以使用接口名和类体结合创建一个匿名对象，然后传递给方法的一个参数，类体必须实现接口的全部方法。</p>

<p>f(new computable(){</p>

<p>实现接口的匿名类的类体));</p>

<p>大部分的内部类只是为了实现某个接口，或者继承某个类，并重写后者实现其里面的一个或少量方法。通常，这样的内部类不在别的类使用，或只使用一次。为了程序的机构清晰，使用匿名类来定义。则于匿名类没有名字，该类就不能再用来创建对象，只能在该类定义时返回一个该类的对象。</p>

<p>当使用类创建对象时，允许把类体和对象的创建结合在一起。也就是说，类创建对象时，除了构造方法以外还有类体。此类体被认为是该类的一个子灰去掉类声明后的类体，称作匿名类。假设Human是类，用Human匿名类创建对象的代码如下：</p>

<p>new Human(){</p>

<p>类体}</p>

<p>匿名类一定是内部类</p>

<p>匿名类可以继承的方法也可以重写父类的方法。使用匿名类时，必然是在某个类中直接用匿名对象（没有名字的对象），因此匿名类一定是内部类。匿名类可以访问外嵌类中的成员变量和方法。但匿名类中不可以定义static成员就是或static方法；</p>

<p>假设有一个方法</p>

<p>void method(Clc c){</p>

<p>c调用类Cla中的方法；}</p>

<p>因为方法method中的参数是一个对象，那么在调用方法method时可以向其参数c传递一个匿名对象，如：</p>

<p>method(new Cla(){</p>

<p>匿名类的类体</p>

<p>});</p>

<p>匿名类由于没有名字，该类就不能再用来创建对象，只能在该类定义时返回一个类的对象；</p>

<p>适合使用匿名类时的情形：</p>

<p>1 如果只对一个对象调用一次；</p>

<p>2 做为参数时；</p>

<h4>内部类<a name="nei" id="nei"></a></h4>

<p>内部类可以访问其外部类的全部成员方法和变量（包括private);</p>

<p>内部类编译后的字节码文件命名：外部类名称$内部类名称.class;</p>

<p>why use nested classes?</p>

<p>1 Logical groupint of classes,if a class is useful to  only one other class,then it is logical to embed it in that class and keep the  two together.Nesting such &quot;helper classes&quot; makes their package more  streamlined.</p>

<p>2 Increased encapsulation.Consider two top-level  classes A and B,where B needs access to members of A that would otherwise be  declared private.By hiding class B within class A,A's member can  declared private and B can access-them.In  addition,B itself can be hidden from the outside world.</p>

<p>3 More readable,maintainable code.Nesting small  classes within top-level classes places the code closer to where it is used.</p>

<p>Nested classes are divided static nested class and  inner class(non-static);</p>

<p>在实际的程序设计中，内部类一般用于两个类之间有比较紧密的逻辑关系的时候；</p>

<p>匿名类就是没有名字的内部类。大部分的内部类只是为了实现某个接口或者继承某个类，并重写后者实现其里面的一个或少量方法。通常，这样的内部类不在别的类使用，或只使用一次。为了程序的机构清晰，使用匿名类来定义；</p>

<p>匿名内部类</p>

<p>在一个类中直接使用new创建一个类的对象，而不使用这个类的名字，一般只用一次，用于注册组件事件处理的监听方法；</p>

<p>new anonymousClassName(){…}</p>

<p>anonymousClassName可以是要扩展的父类的名字，或要实现的接口的名字；</p>

<p>局部内部类</p>

<p>把一个类定义在一个方法体内；</p>

<p>内部类具有继承多个具体的或抽象的类的能力，接口解决了多重继承的部分问题；</p>

<p>内部类主要用于设计具有相互协作关系的类集合。特别是在编写处理GUI事件的代码时，使用它将可以让代码看起来更加简练专业。</p>

<p>使用内部类的原因</p>

<p>1 内部类方法可以访问该类定义民在的作用域中的数据，包括私有的数据；</p>

<p>2 内部类可以对同一个包中的其他类隐藏起来；</p>

<p>3 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</p>

<p>假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类anonymous inner class.</p>

<p>有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static,以便取消产生的引用。</p>

<h4>抽象类<a name="chou" id="chou"></a></h4>

<p>抽象类和接口：系统架构的蓝图；</p>

<p>An abstract class is a class that is declared  abstract,it may or may not include abstract methods.Abstract classes cannot be  instantiated,by they can be subclassed.</p>

<p>An abstract method is a method that is declared  without an implementation(without braces,and followed by a semicolon);</p>

<p>When an abstract class is subclassed,the subclass  usually provides implementations for all of the abstract methods in its parent  class.However,if it does not,the subclass must also be declared abstract.</p>

<p>Unlike interfaces,abstract classes can contain fields  that are not static and final,and they can contain implemented method.Such  abstract classes are similar to interface,except that they provide a partial  implementation,leaving it to subclasses to complete the implementation.If an  abstract class contains only abstract method declaration,it should be declared  as an interface instead.</p>

<p>To define a class that does not implement all of the  interface method,provided that the class is declared to be abstract.</p>

<p>声明方法的存在而不去实现它的类叫抽象类，抽象类提供了一种多个类在一起共同协作工作的方式，通常有多个类要实现某些类似的功能。抽象类需要子灰来继承实现</p>

<p>类本身就是对象的抽象；</p>

<p>对于一个具有继承关系的类来说，一般情况下，上层父类中的成员的抽象性更强，类中方法的共通性也更强，在实际应用中，有时只关心一个类是否具有某种功能，并不关心其具体的实现方法，具体的行为由子类去实现，此时就需要用到抽象类；</p>

<p>接口与抽象类相比，其抽象的程序又进了一层；</p>

<p>抽象类可以有已实现了的方法，而接口是纯粹的抽象；在实际的工作中，可以将接口放到抽象层的最顶层。</p>

<p>抽象类是为继承定义的，是其子类共同特征的集合，它只能作为其他类的父类；</p>

<p>一个abstract类只关心它的子类是否具有某种功能，并不关心功能的具体行为，功能的具体行为由子类负责实现；</p>

<p>抽象类不能产生实例对象</p>

<p>产生对象实例时不仅会将属性值导入，也会将方法内容所在的内存地址导入；而真正的方法内容会放在另一个内存空间供不同对象重复利用（对象不同所调用的方法内容会相同，所以没有必要在每个对象内部导入方法内容。利用指向方式即可重复利用方法内容）。抽象类中的抽象方法根本没有任何内容可以在运行时间被加载，而且在编译阶段就可以预知这样的结果，所以如果使用new来实例化，将会导致编译失败；</p>

<p>抽象类是为了继承定义的，是其子类的共同的特征的集合，一个抽象类只关心其是否具有某种功能，而不关心其具体实现；</p>

<p>创建抽象方法使得你可以将一个方法置于接口中而不必为此方法提供可能豪无意义的方法（反正要重写，如shape类的draw(),你draw什么呢？只有shape类的子类如circle,square都要重写draw()这个方法；</p>

<p>抽象类本身存在未实现的方法（abstract方法），这些方法不具备实际功能，它只能衍生出子类，抽象方法由衍生子类时所覆盖。</p>

<p>以下三种方法不能做为抽象方法定义</p>

<p>1 构造方法；</p>

<p>2 静态方法</p>

<p>3 私有方法</p>

<p>

<p></p>

<p>

<h4>泛型<a name="fan" id="fan"></a></h4>

<p>

<p>一般来说，在编程时都希望将一个集合中容纳的对象限定为某个特定的类型，为些JDK5引入了泛型(Generics),泛型是指在定义集合对象，不仅需要指出集合类型，而且还需要指出其中所容纳元素的类型。该类型包含在尖括号&lt;&gt;内，称为参数化类型。这样，当我们从泛型集合中取出元素时，不再需要进行强制类型转换。而且编译器会保证添加到集合的元素一定是参数化类型指定的类型，否则会编译出错。这也增加了程序的可读性和键壮性；</p>

<p>

<p>集合也可以限制放入元素的数据类，不过必须搭配泛型(Generics)的功能；</p>

<p>

<p>Collection&lt;String&gt; col=new  HashSet&lt;String&gt;();</p>

<p>

<p>使用泛型将元素设定为String类型；</p>

<p>

<p>如何定义一个泛型类和泛型方法？</p>

<p>

<p>在类名的后面加上一对括号(&quot;&lt;&gt;&quot;),在尖括号中填入需要的类型；</p>

<p>

<p>泛型：通过参数的指定，改变类型；</p>

<p>

<p>泛型一般用于集合类；</p>

<p>

<p>装入集合的类型都被当作Object对待，从而失去自己的实际类型；</p>

<p>

<p>从集合中取出时，往往需要经过转型，效率比较低，容易产生错误；</p>

<p>

<p>引入泛型后，在定义集合的时候同时定义集合中对象的类型（类）；</p>

<p>

<p>可以在定义Collection的时候指定，也可以在循环时用iterate指定；</p>

<p>

<p>可以增加程序的稳定性和可读性；</p>

<p>

<p>在API文档内有如下形式，即可以使用泛型</p>

<p>

<p>class ArrayList&lt;E&gt;</p>

<p>

<p>class HasMap&lt;K,V&gt;</p>
<h4>老版集合类<a name="laoji" id="laoji"></a></h4>

<p>

<p>Hashtable,Vector,Stack是老版本遗留下来的类，目的只是为了把持老的程序；</p>

<p>

<p>将相同类型的对象存储到Vector中；</p>

<p>

<p>Vector存储的对象要么属于同一类，要么有相同的超类；要创建Vector,要引用两个类：Vector和要存储在Vector中的类要将Vector中存储的类的名称放在&quot;&lt;&quot;和&quot;&gt;&quot;之间；</p>

<p>

<p>Vector&lt;String&gt; vector=new  Vector&lt;String&gt;();</p>

<p>

<p>最后的（）可以指定元素的个数；</p>

<p>

<p>要将对象加入到Vector中，调用add()方法，以对象为参数；</p>

<p>

<p>vector.add(&quot;Vernon&quot;);</p>

<p>

<p>Vector向量类，提供了与ArrayList类似的功能，但其主要的方法都是同步的，即可以支持多线程同时访问而不会出现问题，而ArrayList不是线程安全的。</p>

<p>

<p>散列表HashTable是使用相关关键字查找被存储的数据项的一种数据结构，关键字不可以发生逻辑冲突，即两个数据项不能使用相同的关键字，如果出现两个数据项对应相同的关键字，那么，先前散列表中的数据项将被替换。散列表在需要更多的存储空间时会自动增大容量。对于数组和链表这两种数据结构，如果要查找已存储的某个特定元素却不知道它的位置，就需要从头开始访问元素直到找到匹配时为止；如果数据结构中包含很多的元素，就会浪费时间。这时最好使用散列表来存储要查找的数据。</p>

<p>

<p>栈Stack是一种“后进先出”的数据结构，只能在一端进行输入或输出数据的操作。栈把第一个放入该栈的数据放在最底下，而把后继放入的数据放在已有数据的项上。向栈中输入数据的操作称为“压栈”，从栈中输出数据的操作称为“出栈”或“弹栈”。由于栈总是在顶端进行数据的输入输出操作，所以，出栈总是操作最后压入栈中的数据，这就是“后进先出”的由来。</p>

<p>

<p>栈是很灵活的数据结构，使用堆栈可以节省内存的开销。比如，递归是一种很消耗内存的算法，可以借助栈消除大部分递归，达到和递归算法同样的目的。 </p>
<p> 
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
</body>
</html>
<script language="javascript"> 
bg_evensssss("tbrowser","#fff","#F5F5F5","#FFFFCC","#FFDDFF");/*#FFFF84*/
</script>
