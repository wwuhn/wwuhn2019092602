<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">
  <p align="center"><strong>网络攻防实战技术之</strong><strong>——</strong><strong>缓冲区溢出篇</strong></p>

<p><strong>内容摘要</strong></p>

<p>1. 缓冲区溢出相关概念</p>

<p>2. 缓冲区溢出原理</p>

<p>3. 溢出保护技术</p>

<p>4. 安全编程技术</p>

<p><strong>学习要求</strong></p>

<p>1. 了解缓冲区溢出的相关概念</p>

<p>2. 明确缓冲区溢出的危害</p>

<p>3. 理解栈溢出、堆溢出、整型溢出、格式化字符串溢出及文件流溢出的原因</p>

<p>4. 掌握安全编程技术</p>

<p><strong>引言</strong><strong>-</strong><strong>缓冲区溢出的历史</strong></p>

<p>1. 1988年的Morris蠕虫病毒，感染了6000多台机器：利用UNIX服务finger中的缓冲区溢出漏洞来获得访问权限，得到一个shell</p>

<p>2. 1996年前后，开始出现大量的缓冲区溢出攻击，因此引起人们的广泛关注</p>

<p>3. 源码开放的操作系统首当其冲</p>

<p>4. 随后，Windows系统下的缓冲区溢出也相继被发掘出来</p>

<p>5. 已经有一些非常经典细致的文章来介绍与缓冲区溢出有关的技术</p>

<p>6. 这两年广泛流行的一些Internet worms利用了一些缓冲区溢出漏洞</p>

<p><strong>缓冲区溢出相关概念</strong></p>

<p>缓冲区</p>

<p>从程序的角度，缓冲区就是应用程序用来保存用户输入数据、程序临时数据的内存空间</p>

<p>缓冲区的本质：数组</p>

<p>存储位置 ：Stack（栈） 、Heap（堆） 、数据段</p>

<p><img width="171" height="230" src="a_clip_image002.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190105091948820-1059048790.png" /></p>

<p>缓冲区溢出</p>

<p>如果用户输入的数据长度超出了程序为其分配的内存空间，这些数据就会覆盖程序为其它数据分配的内存空间，形成所谓的缓冲区溢出</p>

<p><img width="416" height="345" src="a_clip_image004.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190105092412967-497148558.png" /></p>

<p><strong>为什么会缓冲区溢出？</strong></p>

<p>1. 在C语言中，指针和数组越界不保护是Buffer overflow的根源，而且，在C语言标准库中就有许多能提供溢出的函数，如strcat(), strcpy(), sprintf(), vsprintf(), bcopy(), gets()和scanf()</p>

<p>2. 通过指针填充数据</p>

<p>3. 不好的编程习惯</p>

<p>4. 溢出类型：栈溢出、堆溢出</p>

<p><strong>利用缓冲区溢出进行的攻击</strong></p>

<p>1. 基本的思想</p>

<p>通过修改某些内存区域，把一段恶意代码存储到一个buffer中，并且使这个buffer被溢出，以便当前进程被非法利用(执行这段恶意的代码)</p>

<p>2. 危害性</p>

<p>a. 在UNIX平台上，通过发掘Buffer Overflow, 可以获得一个交互式的shell</p>

<p>b. 在Windows平台上，可以上载并执行任何的代码</p>

<p>c. 溢出漏洞发掘起来需要较高的技巧和知识背景，但是，一旦有人编写出溢出代码，则用起来非常简单</p>

<p>d. 与其他的攻击类型相比，缓冲区溢出攻击</p>

<p>i.&nbsp;不需要太多的先决条件</p>

<p>ii.&nbsp;杀伤力很强</p>

<p>iii.&nbsp;技术性强</p>

<p>e. 在Buffer Overflows攻击面前，防火墙往往显得很无奈</p>

<p><strong>利用缓冲区溢出的攻击</strong></p>

<p>1. 随便往缓冲区中填东西造成它溢出一般只会出现“分段错误”（Segmentation fault），而不能达到攻击的目的。</p>

<p>2. 如果覆盖缓冲区的是一段精心设计的机器指令序列，它可能通过溢出，改变返回地址，将其指向自己的指令序列，从而改变该程序的正常流程。</p>

<p><strong>程序指令流被改变后</strong><strong>……</strong></p>

<p>1. 溢出之后，让程序执行我们指定的代码</p>

<p>a. 我们自己提供的一段代码</p>

<p>b. 系统现有的调用</p>

<p>2. 由于这段代码往往不能太长，所以需要精心设计，并且充分利用系统中现有的函数和指令</p>

<p>3. 对于不同的操作系统</p>

<p>a. Linux/Unix，尽可能地得到一个shell(最好是root shell)</p>

<p>b. Windows，一个可以远程建立连接的telnet会话</p>

<p>4. 通用的模式</p>

<p>a. 找到具有漏洞的程序(vulnerable program )</p>

<p>b. 编写出shellcode，</p>

<p>c. 然后编写把shellcode送到漏洞程序的程序(称为exploit)</p>

<p><strong>Windows</strong><strong>平台下缓冲区溢出</strong></p>

<p>过程</p>

<p>1. 发现目标</p>

<p>a.&nbsp;找到有漏洞的程序，如果在输入非正常字符串的时候，出现下图的情形</p>

<p><img width="398" height="136" src="a_clip_image006.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190105093546970-228352366.png" /></p>

<p>b. 或者从程序中找漏洞，用好的反汇编工具，加上耐心</p>

<p>i.&nbsp;以一个特定的字符串作为线索，跟踪到strcpy这样的函数，看是否有边界检查</p>

<p>c. 编写shellcode</p>

<p>d. 编写exploit程序，并试验，直到成功</p>

<p><strong>简单溢出实例</strong> </p>
<pre>
#include &lt;stdio.h>
int main()
{
    char name[8] = {0};
    printf("Your name:");
    gets(name);
    printf("Hello,%s!",name);
    return 0;
}
</pre>
<p>当程序输入内容超过8个字符串时，程序出错！</p>

<p><img width="667" height="431" src="a_clip_image008.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190105101049620-2142431522.png" /></p>

<p><strong>缓冲区溢出的危害</strong></p>

<p>1. 应用程序异常</p>

<p>2. 系统不稳定甚至崩溃</p>

<p>3. 程序跳转到恶意代码，控制权被窃</p>

<p><strong>缓冲区溢出原理</strong></p>

<p>预备知识</p>

<p>1. 理解程序内存空间</p>

<p>2. 理解堆栈</p>

<p>3. 理解函数调用过程</p>

<p>4. 理解缓冲区溢出的原理</p>

<p><strong>Windows</strong><strong>环境下的堆栈</strong></p>

<p>1. 程序空间由何构成？</p>

<p>2. 堆栈是什么?</p>

<p>3. 堆栈里面放的都是什么信息?</p>

<p>4. 程序使用超过了堆栈默认的大小怎么办?</p>
  <p>5. 在一次函数调用中,堆栈是如何工作的?</p>

<p><strong>程序在内存中的映像</strong></p>

<p><img width="712" height="445" src="a_clip_image002_0000.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190105101946955-198332592.png" /></p>

<p><strong>栈</strong></p>

<p>1. 栈是一块连续的内存空间——就像一个杯子</p>

<p>a. 先入后出</p>

<p>b. 生长方向与内存的生长方向正好相反, 从高地址向低地址生长</p>

<p>2. 每一个线程有自己的栈</p>

<p>a. 提供一个暂时存放数据的区域</p>

<p>3. 使用&nbsp;<strong>POP / PUSH</strong>&nbsp;指令来对栈进行操作</p>

<p>4. 使用&nbsp;<strong>ESP</strong>&nbsp;寄存器指向栈顶，<strong>EBP</strong>&nbsp;指向栈帧底</p>

<p><strong>栈内容</strong></p>

<p>1. 函数的参数</p>

<p>2. 函数返回地址</p>

<p>3.&nbsp;<strong>EBP</strong>&nbsp;的值</p>

<p>4. 一些通用寄存器 (<strong>&nbsp;EDI , ESI …</strong>&nbsp;) 的值</p>

<p>5. 当前正在执行的函数的局部变量</p>

<p><strong>三个重要的寄存器</strong></p>

<p><strong>1. SP ( ESP )</strong>&nbsp;</p>

<p>即栈顶指针，随着数据入栈出栈而发生变化</p>

<p><strong>2. BP ( EBP )</strong></p>

<p>即基地址指针，用于标识栈中一个相对稳定的位置。通过&nbsp;<strong>BP</strong>&nbsp;,可以方便地引用函数参数以及局部变量</p>

<p><strong>3. IP ( EIP )&nbsp;</strong></p>

<p>即指令寄存器，在将某个函数的栈帧压入栈中时，其中就包含当前的&nbsp;<strong>IP</strong>&nbsp;值，即函数调用返回后下一个执行语句的地址</p>

<p><strong>函数调用过程</strong></p>

<p>1. 把参数压入栈</p>

<p>2. 保存指令寄存器中的内容，作为返回地址</p>

<p>3. 放入堆栈当前的基址寄存器</p>

<p>4. 把当前的栈指针 (&nbsp;<strong>ESP</strong>&nbsp;)拷贝到基址寄存器，作为新的基地址</p>

<p>5. 为本地变量留出一定空间，把&nbsp;<strong>ESP</strong>&nbsp;减去适当的数值</p>

<p><strong>函数调用中栈的工作过程</strong></p>

<p>调用函数前</p>

<p>压入栈</p>

<p>上级函数传给 A 函数的参数</p>

<p>返回地址 ( EIP )</p>

<p>当前的 EBP</p>

<p>函数的局部变量</p>

<p>调用函数后</p>

<p>恢复 EBP</p>

<p>恢复 EIP</p>

<p>局部变量不作处理</p>

<p><strong>例子</strong><strong>1</strong> </p>
 <pre>
#include &lt;stdio.h>
#include &lt;string.h>
void foo(const char* input){
    char stack[10];
    strcpy(stack,input);
}
void bar(){
    printf("\nAh,I've been hacked!\n");
}
void main(int argc,char *argv[]){
    foo(argv[1]);
}
//例子2
int main()
{
    AFunc(5,6);
    return 0;
}
int AFunc(int i,int j)
{
    int m = 3;
    int n = 4;
    m = i;n = j;
    BFunc(m,n);
    return 8;
}
int BFunc(int i,int j)
{
    int m = 1;
    int n = 2;
    m = i;
    n = j;
    return m;
}
</pre>
  <p><strong>函数调用中栈的工作过程</strong></p>

<p><strong><img width="480" height="270" src="a_clip_image003.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190105200548496-1280618575.gif" /></strong></p>

<p>视频播放地址：https://www.bilibili.com/video/av39992797/</p>

<p><strong>当缓冲区溢出发生时</strong><strong>……</strong></p>

<p><img width="758" height="494" src="a_clip_image005.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190106000118375-2102045294.png" /></p>

<p><strong>缓冲区溢出原理及其利用</strong></p>

<p>缓冲区溢出种类</p>

<p>1. 栈溢出</p>

<p>2. 堆溢出</p>

<p>3. 整型溢出</p>

<p>4. 格式化字符串溢出</p>

<p>5. 其他溢出</p>

<p><strong>栈溢出</strong></p>

<p>特点</p>

<p>1. 缓冲区在栈中分配</p>

<p>2. 拷贝的数据过长</p>

<p>3. 覆盖了函数的返回地址或其它一些重要数据结构、函数指针</p>

<p><strong>栈溢出实例</strong></p>

<p><strong><img width=100% src="a_clip_image007.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190106113212600-380353121.png" /></strong></p>

<p>代码： </p>
 <pre>
#include &lt;stdio.h>
#include &lt;string.h>
int output()
{
    printf("output\n");
    return 0;
}
int main()
{
    char szBuf[8] = {0};
    //int * 取地址      （int）强制转为int
    *(int *)((int)szBuf+12) = (int)(int *) (output);
    printf("main\n");
    return 0;
}
</pre>
<p>PS：可以看到 main 字符 先 output 字符打印，即证明了main返回到了output函数！！！！</p>

<p><img src="a_clip_image009.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190106112822695-1511365484.png" /></p>

<p><img width="684" height="466" src="a_clip_image011.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190106114015918-905438043.png" /></p>

<p>代码： </p>
 <pre>
#include &lt;stdio.h>
#include &lt;string.h>
int BFunc(int i,int j)
{
    int m = 1;
    int n = 2;
    m = i;
    n = j;
    return m;
}
int AFunc(int i,int j)
{
    int m = 3;
    int n = 4;
    char szBuf[8] = {0};
    *(int *)((int)szBuf+20) = (int)(int *)BFunc;
    m = i;
    n = j;
    BFunc(m,n);
    return 8;
}
int main()
{
    char szBuf[8] = {0};
    AFunc(5,6);
    return 0;
}
</pre>
<p>PS：ppt上写的是</p>

<p>*(int  *)((int)szBuf+20) = BFunc;</p>

<p>这样写编译不通过，不能单独使用BFunc函数名获得BFunc的地址 </p>
  <p><strong>堆溢出</strong></p>

<p>1. 堆和栈有何区别</p>

<p>a. 内存的动态分配与静态分配</p>

<p>b. 数据增长方向</p>

<p>2. 堆溢出特点</p>

<p>a. 缓冲区在堆中分配</p>

<p>b. 拷贝的数据过长</p>

<p>c. 覆盖了堆管理结构 </p>
<pre>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;string.h>
#define  BUFLEN 32
int main(int argc, char* argv[ ])
{
    char *buf1;
    buf1 = (char*)malloc(BUFLEN);
    strcpy(buf1,argv[1]);
    printf("%s\n",buf1);
    free(buf1);
    return 0;
}
</pre>
  <p><strong>关于堆溢出</strong></p>

<p>比较少引起人们的关注，原因在于</p>

<p>1. 比栈溢出难度更大</p>

<p>2. 需要结合其他的技术，比如</p>

<p>a.&nbsp;函数指针改写</p>

<p>b.&nbsp;Vtable改写</p>

<p>c.&nbsp;Malloc库本身的漏洞</p>

<p>3. 对于内存中变量的组织方式有一定的要求</p>

<p><strong>整型溢出</strong></p>

<p>1. 宽度溢出（Widthness Overflow）</p>

<p>尝试存储一个超过变量表示范围的大数到变量中</p>

<p>2. 运算溢出（Arithmetic Overflow）</p>

<p>如果存储值是一个运算操作，稍后使用这个结果的程序的任何一部分都将错误的运行，因为这个计算结果是不正确的。</p>

<p>3. 符号溢出(Signedness Bug)</p>

<p>一个无符号的变量被看作有符号，或者一个有符号的变量被看作无符号</p>

<p><strong>PS</strong><strong>：</strong><strong>memcpy</strong><strong>指的是</strong><strong>c</strong><strong>和</strong><strong>c++</strong><strong>使用的内存拷贝函数，</strong><strong>memcpy</strong><strong>函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中。</strong></p>

<p><strong>该函数的复制内存过程中，是不检查数据边界的。</strong></p>

<p><strong>宽度溢出示例</strong> </p>
<pre>
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>
void main(int argc,char* argv[])
{
    unsigned short s;  // 无符号short类型数据占 4 个字节
    int i;             // int类型数据占 8 个字节
    char buf[80];
    i = atoi(argv[1]);//将字符串转换为整型数据  ， 数据 太长 将被截断，转换出错
    s = i;
    if(s >= 80)
        return;
    memcpy(buf,argv[2],i);
}
运算溢出示例
void CopyIntArray(int *array,int len)
{
    int* myarray,i;
    myarray = malloc(len*sizeof(int));
    if(myarray == NULL)
        return;
    for(i=0;i&lt;len;i++)
        myarray[i] = arrary[i];
}
</pre>
<p><strong>符号溢出示例</strong></p>

<p><strong>当</strong><strong>len</strong><strong>变量数据足够长时，将导致</strong><strong>len</strong><strong>为负数，绕过</strong><strong>len&gt;size</strong><strong>的判断，导致溢出</strong> </p>
<pre>
#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>
void CopySomething(char *buf,int len)
{
    char kbuf[8];
    int size = sizeof(kbuf);
    if(len > size)
        return;
    printf("buf=%s,len=%d,size=%d\n",buf,len,size);
    memcpy(kbuf,buf,len);
    for(int i=0;i&lt;size+10;i++)
        printf("kbuf=%c\n",kbuf[i]);
}
void main(int argc,char* argv[])
{
    char * buf = "123456789012";
    int len = 123456789012;
    CopySomething(buf,len);
}
</pre>
<p><img src="a_clip_image002_0001.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190110221441613-1456099297.png" /></p>

<p><strong>格式化字符串溢出</strong></p>

<p>关键字</p>

<p>“%n”</p>

<p>产生原因</p>

<p>printf()是不定参数输入</p>

<p>printf()不会检查输入参数的个数</p>

<p><strong>其他溢出类型</strong></p>

<p>.data section溢出</p>

<p>PEB/TEB溢出</p>

<p>文件流溢出</p>

<p><strong>归纳</strong></p>

<p>溢出的共性</p>

<p>1. 大object向小object复制数据(字符串或整型)，容纳不下造成溢出</p>

<p>2. 溢出会覆盖一些关键性数据（返回地址、管理数据、异常处理或文件指针等）</p>

<p>3. 利用程序的后续流程，得到程序的控制权</p>

<p><strong>缓冲区溢出的利用</strong></p>

<p>char szBuf[8] = {0};</p>

<p>strcpy(szBuf,argv[2]);</p>

<p>argv[2]的内容：</p>

<p>1. 对EIP的填充</p>

<p>2. Shellcode</p>

<p><img width=100% src="a_clip_image003_0000.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190111101814517-1186838469.gif" /> </p>
  <p><strong>Shellcode</strong></p>

<p>1. Shellcode其实就是一段可以完成某种特定功能的二进制代码</p>

<p>2. Shellcode的功能</p>

<p>a. 基本功能</p>

<p>1)&nbsp;添加administrator or root组用户</p>

<p>2)&nbsp;远程可用shell</p>

<p>3)&nbsp;下载程序（Trojan or Rootkit）执行</p>

<p>b. 高级功能</p>

<p>1)&nbsp;抗NIDS检测</p>

<p>2)&nbsp;穿透防火墙</p>

<p><strong>Shellcode</strong><strong>不通用</strong></p>

<p>Shellcode为什么不通用</p>

<p>1. 不同硬件平台</p>

<p>IBM PC、Alpha，PowerPC</p>

<p>2. 不同系统平台</p>

<p>Unix、Windows</p>

<p>3. 不同内核与补丁版本</p>

<p>4. 不同漏洞对字符串限制不同</p>

<p><strong>&nbsp;</strong><strong>利用缓冲区溢出的攻击实例</strong> </p>
<pre>
login: zch
Password:
Last login: Fri  Jan 12 15:21:34 from 210.34.6.82
Sun Microsystems  Inc.?? SunOS 5.6 Generic August 1997
You have mail.
$ who
zch pts/1 Jan 12 15:22 (linuxlab.xmu.edu.cn)
$ lpset
Usage: lpset [-n  (system|xfn) ] [-x] [-a key=value] [-d key] (printer)#查看是否有lpset程序
$ ./lpset2 944 1600 2
Usages: ./lpset2  &lt;bufsize&gt; &lt;offset&gt; &lt;align&gt;
Using RET address  = 0xefffff40 ,Offset = 1600, Align= 2
# id
uid=0(root) gid=1(other)
#
</pre>

<p>入侵成功。lpset2源程序可在绿盟站点下载。 </p>
<p></p>
  <p><strong>格式化字符串溢出攻击</strong></p>

<p>格式化字符串溢出攻击</p>

<p>格式化字符串：就是在*printf()系列函数中按照一定的格式对数据进行输出，可以输出到标准输出，即printf()，也可以输出到文件句柄，字符串等。</p>

<p>黑客可以利用的几个条件：</p>

<p>(1)参数个数不固定造成访问越界数据</p>

<p>(2)利用%n/%hn格式符写入跳转地址</p>

<p>(3)利用附加格式符控制跳转地址的值</p>

<p><strong>&nbsp;</strong><strong>一个简单的例子</strong><strong>:</strong> </p>
<pre>
#include &lt;iostream>
using namespace std;
int main()
{
    long retloc = 0;
    long shell_addr = 0xffbeffac, reth, retl;
    char buf[256], buf1[256];
    reth = (shell_addr &gt;&gt; 16) & 0xffff ;
    retl = (shell_addr &gt;&gt;  0) & 0xffff ;
    sprintf(buf, "%%.%uu%%hn%%%uc%%hn", reth , retl - reth + 0x10000);
    printf("Before overwrite: retloc = 0x%.8x\n", retloc);
    printf(buf, 'A', &retloc, 'B', (char*)(&retloc) + 2 );
    printf("After overwrite: retloc = 0x%.8x\n", retloc);
    system("pause");
}
</pre>
  <p>程序执行结果：</p>

<p>Before overwrite: retloc = 0x00000000</p>

<p>After overwrite: retloc = 0xffacffbe</p>

<p>程序执行分析：</p>

<p>printf(&quot;%.65470u%hn%65518c%hn&quot;,  'A', &amp;retloc, 'B', (char*)(&amp;retloc) + 2 );</p>

<p><img width="462" height="89" src="a_clip_image005_0000.gif" alt="https://img2018.cnblogs.com/blog/1148798/201901/1148798-20190111104233970-464354879.png" /></p>
<p></p>
<p></p>
<p></p>
</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>

<!--
_____________________________________________________________________________________

1 段落替换
\s*</p>

<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])


------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________

4 把第和章两个字去掉
第(\S*)章
------------------
$1
_____________________________________________________________________________________

7 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/
_____________________________________________________________________________________

8
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
9 将标注序号更改为上标，红色，需一个个替换，英文html中有[1]
(\[\d\])
------------------
<sup>$1</sup>
_____________________________________________________________________________________
10 替换章不是以1-9。?！…”“结尾的段落
([^1-90。?！…”：？“章])</p>
<p>
------------------
$1
-->


