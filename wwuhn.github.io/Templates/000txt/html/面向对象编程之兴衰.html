<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>面向对象编程之兴衰</h3>

<p>【CSDN 编者按】作为一种程序设计思想，OOP 在最初诞生之际就收到了广大开发者的喜爱。但是在技术革新日益实践过程中，不少人发现面向对象的设计会使代码复杂化，难以理解而且难以测试，对此，后来有网友更是将 OOP 称之为是反模块化、反并行的，从而开启了一波又一波的吐槽模式。而论 OOP 在各个领域中的应用时，其是否真的有想象中那么糟糕？接下来，本文将带领大家一读 OOP 的兴衰成长史。</p>
<p>以下为译文：不，面向对象编程（OOP）并没有消亡。但它远没有以前那么流行了。</p>
<p>我记得当时在90年代，关于面向对象编程的教科书和计算机科学课程很多。当时那就是“风口”，下一波潮流。如果你没有以那种方式编程，你就不是一个优秀的程序员，或者至少是可悲地落后于时代发展潮流了。</p>
<p>当时，CS专业的学生以非常严格和教条化的方式学习OOP。从业者们不仅被鼓励以对象和类的形式构建他们的应用程序，甚至被认为应该根据对象和类来考虑问题空间。这样的做法被称为“面向对象的分析和设计”。</p>
<p>然而，随着时间的推进，人们开始意识到严格的面向对象方法会带来许多问题。这些问题往往会使代码复杂化，难以理解而且难以测试。</p>
<p>事实证明，OOP在某些问题领域确实比其他方法更出色。例如，OOP仍然是构建用户界面（窗口和按钮）的最自然的方式。但是，试图使面向对象适应关系数据库一直以来都简直是一场灾难。</p>
<p>以下是我所观察到的一些问题：</p>
<p>“鸭嘴兽”效应</p>
<p>现实世界并不总是能被整洁地划分为具有明确属性定义的类（class）。例如，假设你创建了一个代表动物王国的类层次结构。现在，有爬行动物——冷血，有鳞片，卵生等等。还有哺乳动物——温血，有绒毛，胎生。以及鸟类，两栖动物，无脊椎动物等等</p>
<p>然后鸭嘴兽出现了，它似乎不适合你的任何类别。你该怎么做呢？你是创建一个全新的类别呢，还是重新考虑整个分类方案？这两种方法在工作量和程序复杂性方面都会产生巨大的成本。</p>
<p>（感谢Anselm Hook创造了“鸭嘴兽效应”一词。）</p>
<p>深层次结构</p>
<p>我记得我在谷歌工作时，当时我们有一个JavaScript库叫goog.ui，它被用于创建基于Web的用户界面。以下是此库中某个UI组件的继承层次结构示例：</p>
<p>class ToolbarColorMenuButton</p>
<p>* inherits from ColorMenuButton</p>
<p>* inherits from MenuButton</p>
<p>* inherits from Button</p>
<p>* inherits from Control</p>
<p>* inherits from Component</p>
<p>* inherits from EventTarget</p>
<p>* inherits from Disposable</p>
<p>* inherits from Object</p>
<p>但情况会变得更糟。</p>
<p>许多高级类被只与少数子类相关的方法和属性“污染”。例如，“Control”类有超过90种方法（method）。它具有设置状态的方法，即使特定的子类是无状态的; 它有添加和删除子元素的方法，即使对control来说子元素没有意义。</p>
<p>这种复杂性的一个重要原因是，该库的作者试图组织组件的不同方面——例如组件是按钮还是滑块，或者它是否有颜色——并通过将它们放入类的不同层次来实现这一点。</p>
<p>但实际上，这些不同方面彼此之间无关。咖啡杯是红色的，和它是由陶瓷制成的，这是两个独立的特性。将红色咖啡杯划入“红色物品”类别，还是将其放入“陶瓷制品”甚至“家居用品”类别中都是同样正确的。任何一个选择都是任意的，因为类别是由人头脑中的反映和社会结构决定的。</p>
<p>在Google工作的最后几年里，我创建了一个名为“Quantum Wiz”的新用户界面工具包，旨在替代goog.ui。我们采用的规则之一（以典型的Google风格，以方程式编写）是：</p>
<p>composition > inheritance</p>
<p>用直白的英语解释的话，这说的是：</p>
<p>“更偏向于采用组合的思路——也就是说，能够用更小的构建块来组装组件的功能——而不是继承作为代码重用的手段。”</p>
<p>因此，举个栗子，如果按钮有颜色，你将采用常规的“Button”对象(object)并向其添加“Color”方面(aspect)，作为属性或子对象，而不是创建一个新的“Color Button”类。</p>
<p>作为这项任务的结果，新工具包的类层次结构相对较浅，如果我没记错的话，只有两三个级别。而且更容易理解和使用，也更强大。</p>
<p>（感谢Malte Ubl向我介绍了组合大于继承的概念。）</p>
<p>对象不是真实的</p>
<p>Buckminster Fuller曾经说过：“事物并不存在”。他的意思是，事物之间的区别主要由人的偏见导致。</p>
<p>例如，我坐的沙发是由分子力束缚在一起的原子的集合。然而，这些原子也会受到房间内其他物体的影响——地毯，茶几，甚至是房间内的空气。沙发本身由各种部件组成——织物，木材，金属弹簧等等——它们也受到分子力的约束。那么沙发是一个对象，还是很多对象？也许世上只有一个对象——即我们所在的这个宇宙。</p>
<p>因为人类的视觉和触觉在很大程度上只对表面属性有响应——比如颜色和质感——我们倾向于基于表面现象对世界进行分类。相反，想象一下，如果我们能够直接感知周围物体内的分子组成。我们可能会看到一个“铜”对象，代表着房屋中的所有布线和管道，一个“氮”对象，代表着房间的气体，一个“水”对象，一个“木头”对象，等等。</p>
<p>Fuller的观点是，我们将世界“解析”为离散的“事物”的能力是任意的，这更多地反映了我们的人类心理而不是物理现实。</p>
<p>因为面向对象的继承涉及将事物组织成类，所以它不能很好地模拟现实世界; 但它能很好地模拟人类思考现实世界的方式。</p>
<p>方法（method）也不真实</p>
<p>我记得大约二十年前的一段小插曲，一位软件供应商的技术代表试图向我司的工程人员解释OOP。他试图争辩说，面向对象是一种模拟现实世界的方式，他给出的例子就像上面说的咖啡杯那种。他说杯子可能有个“drink”的方法。</p>
<p>我记得的是，我对此有一个非常强烈的反应——我认为他所说的完全是胡说八道。除了它的特定目的之外，一个物理对象可以有许多用途。我可以用咖啡杯作为镇纸或门挡; 这是否意味着它有一个“holdDownPapers”或“keepDoorOpen”方法？我可以将它用作武器，玩具或艺术品。我甚至可以将杯子碎成碎片，或将其研磨成粉末，并以创造性的方式使用其残余物。</p>
<p>（我认为这个可怜的家伙对我的反驳感到吃惊。）</p>
<p>内部逻辑与外部逻辑</p>
<p>严格的OOP风格的一个原则是，永远不可能从外部改变对象的内部状态。任何改变对象状态的业务或应用程序逻辑都必须作为对象本身的方法实现。因此，举个栗子，如果要删除文本字段中的所有文本，则不能简单地进行：</p>
<p>textField.value = ""; // Set to empty string</p>
<p>这将违背规则。相反，你不得不这样：</p>
<p>textField.clear; // Clear the content of the field</p>
<p>对于简单的操作，这没关系。但是这很容易过火，特别是正在进行的操作处理的是不同对象之间的复杂关系时。</p>
<p>有时候，如果算法独立于任何对象之外，反而更好。这真的是一个重要的问题：对于这个问题集，你更关心名词还是动词？</p>
<p>下面这是一个具体的例子：最近我开始研究编译器（编写编译器是我的一个爱好; 在我做游戏开发的时候，我发明了许多脚本语言）。在过去，当我编写编译器时，我会采用非常严格的OOP方法来设计内部数据结构。有各种类层次结构表示抽象语法树，表达式图，类型等。</p>
<p>通常，编译器通过一系列阶段或“传递”来处理这些数据结构，每一步的输出被送到下一步的输入中。</p>
<p>在过去，我倾向于按照推荐的OOP样式为每个操作中的每个对象设置一些逻辑。这带来不好的后果，当我添加更多步骤时，对象变得越来越复杂。</p>
<p>更糟糕的是，这使得给这些对象写单元测试异常困难。这些复杂的对象在被创建出来之前就需要大量的基础结构。这意味着为了测试一个对象，我必须创建大量的脚手架来满足所有先决条件。</p>
<p>结果，我的测试覆盖率往往很差，因为编写测试是一项耗费大量精力的工作。</p>
<p>最近，我采取了另一种方法。在我最新的编译器中，所有这些内部数据结构都是“傻瓜型”的，意思是说它们所做的只是保存数据而已，没有别的。用于操作和转换对象的所有代码都在这些对象的外部。</p>
<p>这对代码的组织有很大的好处。每个算法都集中在一个地方，而不是分散在一堆源文件中。当我想测试一个特定的编译器操作时，我可以轻松地创建一些示例对象并将其提供给该操作。因此，我的测试写起来更容易了，所以我就能写更多的测试了，从而就能有比以前更好的测试覆盖率了。</p>
<p>关系数据库</p>
<p>前面我提到过，以面向对象的方式处理关系数据库会有问题。对象关系映射（ORM）被一位评论家称为计算机科学领域的越战。（警告——那篇文章很长，很深奥，而且有点倾向性。）</p>
<p>我的大致感觉是，在处理大数据时，你不应将你的记录视为“对象”。关系数据库非常强大，但它们提供的强大功能并不是非常“类似对象”。我倾向于认为关系数据流更像流体，你可以使用代数运算的方式来划分，转换和组合数据。</p>
<p>（感谢Guido Van Rossum指出上面关于ORM的文章的链接。）</p>
<p>函数式编程</p>
<p>在过去十年左右的时间里，人们越来越关注函数式编程（FP）。与OOP一样，函数式编程不仅仅是单纯的一件事物，而是一套整体的风格上的原则。然而，它的要点是，虽然OOP专注于与对象进行交互或通信，但在FP中，重点在于对它们的转换。这里的“转换”，意思是你获取一些对象，将它传递给一个函数，结果是一个全新的对象，代表着对输入内容所做的一些转换。原始对象要么被保留，要么被丢弃，但不会以任何方式被更改或修饰。</p>
<p>在我自己的编程过程中，我更喜欢“混合”方法，在某些地方使用FP技术，而在其他地方使用OOP技术。在解决某些问题上FP确实能大放异彩，但也有另一些问题上OOP是更明智的选择。</p>
<p>我知道很多FP爱好者都热衷于“纯粹”的函数式语言，其中所有对象都是不可变的，并且只能被转换，而不能被修改。然而，我发现纯粹的方法倾向于把某些相对简单的编程实践变成谜题。我的意思是一些聪明的，但不那么显而易见的技巧，这能吸引那种喜欢脑筋急转弯的人，但是对其他人来说却是完全无法理解的。</p>
<p>因此，我倾向于在合理的范围内使用FP，使阅读我代码的普通程序员都能理解。如果我想做任何抖机灵的事情，我会写一篇长篇评论来解释我所做的事情，以及它是如何work的（这满足了我炫耀的心理——我经常认为编程应该是一种表演艺术。）</p>
<p>所以，面向对象编程不再有昔日的辉煌了。它仍然是一个很好的工具，仍然值得学习。但它已跌下神坛，你很难再看到有人能像 25 年前那样，以宗教般的狂热来吹捧它了。</p>
<p>原文：https://medium.com/machine-words/the-rise-and-fall-of-object-oriented-programming-d67078f970e2</p>


<p style='float:right;'>本页共69段，4994个字符，12449 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
