<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 
<title>寄存器</title>

 <style type="text/css">
#tbrowser a:link，.container a:visited{
font-size:18px;
text-decoration:none;
}
.container{
font-size:1.2em;
margin:auto;
font-family:"mv boli","宋体";
width:75.29%;
line-height:1.4em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:5px;
margin-bottom:-15px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}

a:link {
	text-decoration: none;
}


a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
a:active {
	text-decoration: none;
}
</style>
</head>

<body>
<div class="container">
  <p align="left"><strong><a href="http://www.techcn.com.cn/index.php?doc-view-113374.html">寄存器</a></strong></p>
  <img width="50%" border="0" src="table no_clip_image001.jpg" alt="（图）寄存器" />
  <p align="left">寄存器是<a href="http://www.techcn.com.cn/index.php?doc-innerlink-CPU" title="CPU">CPU</a>内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF" title="时序逻辑电路">时序逻辑电路</a>，但这种时序逻辑电路只包含<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%AD%98%E5%82%A8%E7%94%B5%E8%B7%AF" title="存储电路">存储电路</a>。寄存器的存储电路是由<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%94%81%E5%AD%98%E5%99%A8" title="锁存器">锁存器</a>或<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E8%A7%A6%E5%8F%91%E5%99%A8" title="触发器">触发器</a>构成的，因为一个锁存器或触发器能存储1位<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E4%BA%8C%E8%BF%9B%E5%88%B6" title="二进制">二进制</a>数，所以由N个锁存器或触发器可以构成N位寄存器。寄存器是<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" title="中央处理器">中央处理器</a>内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%8C%87%E4%BB%A4" title="指令">指令</a>、<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%95%B0%E6%8D%AE" title="数据">数据</a>和位址。在中央处理器的控制部件中，包含的寄存器有<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8" title="指令寄存器">指令寄存器</a>(IR)和<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8" title="程序计数器">程序计数器</a>(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E7%B4%AF%E5%8A%A0%E5%99%A8" title="累加器">累加器</a>(ACC)。   </p>
<p>

    <a name="section" id="section">目录</a> </p>
  <ul>
    <li><a href="#1">特点及原理</a> </li>
    <li><a href="#3">主要技术</a> </li>
    <li> <a href="#5">技术规范</a> </li>
    <li><a href="#7">具体分类</a> </li>

  </ul>
 
<p>

    特点及原理 <a href="#section">回目录</a> </p>
<img border="0" width="300" height="204" src="table no_clip_image002.jpg" alt="（图）寄存器" />
  <p align="left">寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%AD%98%E5%82%A8%E5%99%A8" title="存储器">存储器</a>相比，寄存器又有自己独有的特点：   </p>
<p>

    ①寄存器位于CPU内部，数量很少，仅十四个；  </p>
<p>

    ②寄存器所能存储的数据不一定是8<a href="http://www.techcn.com.cn/index.php?doc-innerlink-bit" title="bit">bit</a>，有一些寄存器可以存储16bit数据，对于386/486处理器中的一些寄存器则能存储32bit数据；  </p>
<p>

    ③每个内部寄存器都有一个名字，而没有类似存储器的<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%9C%B0%E5%9D%80%E7%BC%96%E5%8F%B7" title="地址编号">地址编号</a>。   </p>
<p>

    寄存器的功能十分重要，CPU对存储器中的数据进行处理时，往往先把数据取到内部寄存器中，而后再作处理。外部寄存器是计算机中其它一些部件上用于暂存数据的寄存器，它与CPU之间通过“<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E7%AB%AF%E5%8F%A3" title="端口">端口</a>”交换数据，外部寄存器具有寄存器和内存储器双重特点。有些时候我们常把外部寄存器就称为“端口”，这种说法不太严格，但经常这样说。   </p>
<p>

    外部寄存器虽然也用于存放数据，但是它保存的数据具有特殊的用途。某些寄存器中各个位的0、1状态反映了外部设备的工作状态或方式；还有一些寄存器中的各个位可对<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87" title="外部设备">外部设备</a>进行控制；也有一些端口作为CPU同外部设备交换数据的通路。所以说，端口是CPU和外设间的联系桥梁。CPU对端口的访问也是依据端口的“编号”（地址），这一点又和访问存储器一样。不过考虑到机器所联接的外设数量并不多，所以在设计机器的时候仅安排了1024个端口地址，端口地址范围为0--3FFH。   </p>
<p>

    主要技术<a name="3" id="3"></a> <a href="#section">回目录</a> </p>

  <p align="left">1．<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%87%8D%E5%91%BD%E5%90%8D%E6%8A%80%E6%9C%AF" title="重命名技术">重命名技术</a>  </p>
<p>
<img border="0" width="50%"   src="table no_clip_image003.jpg" alt="（图）寄存器" />
    寄存器重命名，是CPU在解码过程中对寄存器进行重命名，<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E8%A7%A3%E7%A0%81%E5%99%A8" title="解码器">解码器</a>把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。   </p>
<p>

    2．<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF" title="乱序执行技术">乱序执行技术</a>  </p>
<p>

    采用乱序执行技术使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。这好比请A、B、C三个名人为春节联欢晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字，如果这时在一张大纸上按顺序由A写好“春节”后再交给B写“联欢”，然后再由C写“晚会”，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。但如果采用三个人分别用三张纸同时写的做法，那么B和C都不必等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就像乱序执行），但当他们都写完后就必须重新在横幅上按“春节联欢晚会”的顺序排好（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）才能挂出去。   </p>
<p>

    技术规范<a name="5" id="5"></a> <a href="#section">回目录</a> </p>
 <img border="0"  width="50%"  src="table no_clip_image004.jpg" alt="（图）寄存器" /></a> </td>
     
  <p align="left">寄存器通常都用来意指由一个指令之输出或输入可以直接索引到的寄存器群组。更适当的是称为“架构寄存器”。x86指令及定义八个32位元寄存器的集合，但一个实作x86指令集的CPU可以包含比八个更多的寄存器。共有以下几类的寄存器:  </p>
<p>

    （1）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E8%B5%84%E6%96%99%E5%AF%84%E5%AD%98%E5%99%A8" title="资料寄存器">资料寄存器</a>：用来储存整数数字（参考以下的浮点寄存器）。在某些简单/旧的CPU，特别的资料寄存器是累加器，作为数学计算之用。  </p>
<p>

    （2）位址寄存器-持有内存位址，以及用来存取内存。在某些简单/旧的CPU里，特别的位址寄存器是索引寄存器（可能出现一个或多个）。  </p>
<p>

    （3）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%80%9A%E7%94%A8%E7%9B%AE%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8" title="通用目的寄存器">通用目的寄存器</a>（GPRs）-可以保存资料或位址两者，也就是说他们是结合资料/位址寄存器的功用。  </p>
<p>

    （4）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%B5%AE%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8" title="浮点寄存器">浮点寄存器</a>（FPRs）-用来储存浮点数字。  </p>
<p>

    （5）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%B8%B8%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8" title="常数寄存器">常数寄存器</a>-用来持有只读的数值（例如0、1、圆周率等等）。  </p>
<p>

    （6）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%90%91%E9%87%8F%E5%AF%84%E5%AD%98%E5%99%A8" title="向量寄存器">向量寄存器</a>-用来储存由向量处理器执行SIMD（SingleInstruction,MultipleData）指令所得到的资料。  </p>
<p>

    （7）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E7%89%B9%E6%AE%8A%E7%9B%AE%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8" title="特殊目的寄存器">特殊目的寄存器</a>-储存CPU内部的资料，像是程式计数器（或称为指令指标），堆栈寄存器，以及状态寄存器（或称微处理器状态字组）。  </p>
<p>

    （8）指令寄存器（instructionregister）-储存现在正在被执行的指令  </p>
<p>

    （9）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E7%B4%A2%E5%BC%95%E5%AF%84%E5%AD%98%E5%99%A8" title="索引寄存器">索引寄存器</a>（indexregister）-是在程式执行实用来更改算子位址之用。在某些架构下，模式指示寄存器（也称为“机器指示寄存器”）储存和设定跟处理器自己有关的资料。由于他们的意图目的是附加到特定处理器的设计，因此他们并不被预期会成微处理器世代之间保留的标准。 </p>
 <img border="0"  width="50%"  src="table no_clip_image005.jpg" alt="（图）寄存器" /></a> </td>
 
  <p align="left">随机存取内存提取资讯的寄存器与CPU（位于不同芯片的储存寄存器集合）：  </p>
<p>

        </p>
<p>

    （1）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%AF%84%E5%AD%98%E5%99%A8" title="内存缓冲寄存器">内存缓冲寄存器</a>（Memorybufferregister）  </p>
<p>

    </p>
<p>

    （2）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%86%85%E5%AD%98%E8%B5%84%E6%96%99%E5%AF%84%E5%AD%98%E5%99%A8" title="内存资料寄存器">内存资料寄存器</a>（Memorydataregister）  </p>
<p>

    </p>
<p>

    （3）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%86%85%E5%AD%98%E4%BD%8D%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8" title="内存位址寄存器">内存位址寄存器</a>（Memoryaddressregister）  </p>
<p>

    </p>
<p>

    （4）<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%86%85%E5%AD%98%E5%9E%8B%E6%80%81%E8%8C%83%E5%9B%B4%E5%AF%84%E5%AD%98%E5%99%A8" title="内存型态范围寄存器">内存型态范围寄存器</a>（MemoryTypeRangeRegisters）   </p>
<p>

    具体分类<a name="7" id="7"></a> <a href="#section">回目录</a> </p>
 <img border="0"  width="50%"  src="table no_clip_image006.jpg" alt="（图）寄存器" /></a> </td>
   
  <p align="left">1、<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8" title="数据寄存器">数据寄存器</a>  </p>
<p>

        </p>
<p>

    数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。32位CPU有4个32位的通用寄存器<a href="http://www.techcn.com.cn/index.php?doc-innerlink-EAX" title="EAX">EAX</a>、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。   </p>
<p>

    4个16位寄存器又可分割成8个独立的8位寄存器(AX：<a href="http://www.techcn.com.cn/index.php?doc-innerlink-AH-AL" title="AH-AL">AH-AL</a>、BX：<a href="http://www.techcn.com.cn/index.php?doc-innerlink-BH-BL" title="BH-BL">BH-BL</a>、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E4%B9%98" title="乘">乘</a>、<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%99%A4" title="除">除</a>、输入/输出等操作，它们的使用<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%A2%91%E7%8E%87" title="频率">频率</a>很高；寄存器BX称为基地址寄存器(BaseRegister)。它可作为存储器指针来使用；寄存器CX称为计数寄存器(CountRegister)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；  </p>
<p>

    </p>
<p>

    寄存器DX称为数据寄存器(DataRegister)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。  </p>
<p>

    </p>
<p>

    2、<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8" title="变址寄存器">变址寄存器</a>  </p>
<p>

    </p>
<p>

    32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。寄存器ESI、EDI、SI和DI称为变址寄存器(IndexRegister)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。 </p>
 <img border="0"  width="50%"  src="table no_clip_image007.jpg" alt="（图）寄存器" /></a> </td>
  
  <p align="left">3、<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8" title="指针寄存器">指针寄存器</a>  </p>
<p>

        </p>
<p>

    32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的SBP和SP，对低16位数据的存取，不影响高16位的数据。寄存器EBP、ESP、BP和SP称为指针寄存器(PointerRegister)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。  </p>
<p>

    </p>
<p>

    它们主要用于访问堆栈内的存储单元，并且规定：  </p>
<p>

    （1）BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；  </p>
<p>

    （2）SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。 </p>
 <img border="0"  width="50%"  src="table no_clip_image008.jpg" alt="（图）寄存器" /></a> </td>
 
  <p align="left">4、<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8" title="段寄存器">段寄存器</a>  </p>
<p>

        </p>
<p>

    段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成  </p>
<p>

    的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。  </p>
<p>

    CPU内部的段寄存器：  </p>
<p>

    CS——<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8" title="代码段寄存器">代码段寄存器</a>(CodeSegmentRegister)，其值为代码段的段值；  </p>
<p>

    DS——<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8" title="数据段寄存器">数据段寄存器</a>(DataSegmentRegister)，其值为数据段的段值；  </p>
<p>

    ES——<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%99%84%E5%8A%A0%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8" title="附加段寄存器">附加段寄存器</a>(ExtraSegmentRegister)，其值为附加数据段的段值；  </p>
<p>

    SS——<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%A0%86%E6%A0%88%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8" title="堆栈段寄存器">堆栈段寄存器</a>(StackSegmentRegister)，其值为堆栈段的段值；  </p>
<p>

    FS——<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%99%84%E5%8A%A0%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8" title="附加段寄存器">附加段寄存器</a>(ExtraSegmentRegister)，其值为附加数据段的段值；  </p>
<p>

    GS——<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E9%99%84%E5%8A%A0%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8" title="附加段寄存器">附加段寄存器</a>(ExtraSegmentRegister)，其值为附加数据段的段值。   </p>
<p>

    在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简单描述如下：  </p>
<p>

    </p>
<p>

    实方式：前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为段值：“<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%81%8F%E7%A7%BB%E9%87%8F" title="偏移量">偏移量</a>”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。保护方式：在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为”选择子”(Selector)的某个值。 </p>
 <img border="0"  width="50%"  src="table no_clip_image009.jpg" alt="（图）寄存器" /></a> </td>
  
  <p align="left">5、<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8" title="指令指针寄存器">指令指针寄存器</a>  </p>
<p>

        </p>
<p>

    32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。指令指针EIP、IP(InstructionPointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。在实方式下，由于每个段的最大范围为64K，所以，EIP中的高16位肯定都为0，此时，相当于只用其低16位的<a href="http://www.techcn.com.cn/index.php?doc-innerlink-IP" title="IP">IP</a>来反映<a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E7%A8%8B%E5%BA%8F" title="程序">程序</a>中指令的执行次序。   </p>
<p>

    相关词条<a name="9" id="9"></a><a href="http://www.techcn.com.cn/index.php?doc-editsection-113374-9.html">编辑本段 </a> <a href="#section">回目录</a> </p>
  <table border="1" cellspacing="0" cellpadding="0" align="left" width="100%">
    <tr>
      <td>  </p>
<p>

        <a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8" title="数据寄存器">数据寄存器</a> </td>
      <td><p align="center"><a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8" title="变址寄存器">变址寄存器</a></p></td>
      <td><p align="center"><a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8" title="指令寄存器">指令寄存器</a></p></td>
    </tr>
    <tr>
      <td><p align="center"><a href="http://www.techcn.com.cn/index.php?doc-innerlink-CPU" title="CPU">CPU</a></p></td>
      <td><p align="center"><a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E7%AB%AF%E5%8F%A3" title="端口">端口</a></p></td>
      <td><p align="center"><a href="http://www.techcn.com.cn/index.php?doc-innerlink-%E4%BA%8C%E8%BF%9B%E5%88%B6" title="二进制">二进制</a></p></td>
    </tr>
  </table>
  <p align="left">参考资料<a name="11" id="11"></a> <a href="#section">回目录</a>   </p>
<p>

    [1] 中电网 <a href="http://baike.eccn.com/eewiki/index.php/%E5%AF%84%E5%AD%98%E5%99%A8">http://baike.eccn.com/eewiki/index.php/%E5%AF%84%E5%AD%98%E5%99%A8</a>  </p>
<p>

    [2] 电脑报 <a href="http://diy.ccw.com.cn/superior/htm2005/20050705_208PN.htm">http://diy.ccw.com.cn/superior/htm2005/20050705_208PN.htm</a></p>
  <p>1.什么是寄存器   </p>
<p>

    所谓寄存器（register），它是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储1位二进制数，所以由N个锁存器或触发器可以构成N位寄存器。   </p>
<p>

  <a href="http://www.win7zj.com/article/UploadPic/2012-3/20123613132230.jpg" target="_blank"><img border="0" width="200" height="124" src="table no_clip_image001_0000.jpg" alt="http://www.win7zj.com/article/UploadPic/2012-3/20123613132230.jpg" /></a>   </p>
<p>

    2.寄存器与CPU指令   </p>
<p>

    在讲CPU的寄存器之前，我们先了解一下CPU指令系统。指令系统指的是一个CPU所能够处理的全部指令的集合，Athlon <a href="http://www.win7zj.com" target="_blank">XP</a>和P4都是基于x86指令集，这是CPU的根本属性，决定CPU运行什么样的程序。   </p>
<p>

    指令一般分为：算术逻辑运算指令、浮点运算指令、位操作指令及其他的一些非运算指令，其中整数、地址、指令指针和浮点数据是按照数据形式来划分的。通常我们把需要CPU进行不同处理的单个数据称为标量数据(Scala Data)。标量数据既可以是整数数据，也可以是浮点数据。其中整数标量数据的存放区一般为通用寄存器(GPR)，浮点标量数据的存放区一般为浮点寄存器(FPR)。与标量数据相对的是矢量数据(Vector Data)，所谓矢量数据就是指一列需要由处理器作相同处理的数据集合。比如处理器在做MP3编码的过程中，需要对内存中的音频文件里的各字节数据作相同的MP3编码操作。那么通常使用MMX或SSE这类单指令多数据流(SIMD)指令，将数个字节打包为一组矢量数据，存放在MMX或SSE寄存器中，再送往相应的功能单元进行统一操作。   </p>
<p>

    其中通用寄存器是处理器中最快的存储器，用来保存参加运算的操作数和中间结果。在通用寄存器的设计上，RISC与CISC（也就是我们常说的x86架构）有着很大的不同。CISC的寄存器通常很少——只有8个通用寄存器。由于CPU在执行指令过程中，存在指令依赖性，在一定程度上使得x86  CPU不能在每个时钟周期中立即发布大量的指令。所谓“依赖性”就是指令的执行需要前个指令的运算结果。比如程序员经常使用的分支程序，请看下面这个例子：   </p>
<p>

A=C*1  </p>
<p>

B=A+2  </p>
<p>

    只要变量A的值还不知道，B=A+2就不能进行运算。也就是说，只要指令1的结果没有写进寄存器，CPU调度器就不能把指令2发布到执行单元。由于程序分支会造成具有较长流水线CPU运行停滞的，目前常用的解决方法是采用分支预测。   </p>
<p>

    不过，分支预测同样存在一个问题：流水线越长，指令潜伏期也越长，等待前一指令运算结果的时间也越长，同样会造成CPU运行停滞。我们知道，程序指令通常都有各类型的条件分支语句，通过验证条件决定执行路线。但CPU执行单元内是通过一项特殊的预测机制选择一条路线直接执行（这样可以避免验证语句条件而处于等待情况），然后在后面进行验证。如果预测正确则继续往下执行，如果发现以前的预测错误，那么就必须返回原地重新开始，以前的指令就会作废。   </p>
<p>

    因此，管线越长，意味着出现分支预测错误的机会就越多，越多在管线内的指令会被清除掉，而且重新让管道填满指令的时间也会越长。对于普通处理器来说，如果出现分支预测错误，CPU就不得不将整条流水线清空后从错误的地方重新装满数据、重新执行。毫无疑问这将花更多的时间，整体性能就会下降。因此，针对通用寄存器少的问题，在x86架构中比较完美的解决方法就是增加寄存器的数量和采用“乱序执行”。   </p>
<p>

    3.为什么寄存器不够用   </p>
<p>

    在上面我们已经提到，寄存器只是用来暂时存放指令值的，如果CPU需要把两个值加起来，它需要用1个寄存器来存放运算结果，用2个寄存器来存放相加的数值。例如，在以下的方程式中：A = 2  + 4  </p>
<p>

* 在寄存器1储存“2”；   </p>
<p>

* 在寄存器2储存“4”；   </p>
<p>

* 在寄存器3储存“寄存器1 + 寄存器 2”；   </p>
<p>

    因为在微处理器里面有超过3个寄存器，因此这个运算能够轻易地执行，不会造成用光寄存器的情况。   </p>
<p>

    在这些运算被执行之后，所有的3个数值都能够被保留并重新使用，因此如果我们再想在结果加上2的话，处理器只需要执行：寄存器 1 + 寄存器 3 就可以了。如果微处理器仅有2个剩余的寄存器，而我们又需要再次使用2和4的值，那么这些值在覆盖结果A之前，必须储存在主内存之中。运算执行的过程则会变成如下所示：   </p>
<p>

* 在寄存器1储存 “2”；   </p>
<p>

* 在寄存器2储存“4”；   </p>
<p>

* 在主内存的某个空间储存“寄存器1 + 寄存器2”；   </p>
<p>

    我们可以看到这里使用了其它的内存访问过程，而在这期间其实还有我们没有提到的其它处理过程，比如主内存的定位也需要占据寄存器，以便让CPU 告诉装载/储存单元该往哪里发送数据。如果我们需要使用到这些结果的话，那么CPU将不得不首先到主内存中找回这些结果，把目前满载的寄存器驱逐一些数据，把它们写入主内存，然后再把寻找到的数据储存在寄存器里。   </p>
<p>

  <a href="http://www.win7zj.com/article/UploadPic/2012-3/20123613133940.jpg" target="_blank"><img border="0" width="200" height="117" src="table no_clip_image002_0000.jpg" alt="http://www.win7zj.com/article/UploadPic/2012-3/20123613133940.jpg" /></a>   </p>
<p>

    </p>
<p>

    这里大家应该能够明白吧，对内存的访问次数将会可怕地增加；你需要访问内存的时间越多，那么处理器等待工作完成的时间就越长——因而造成性能的下降。因此面对超标量CPU在并行处理大量运算，x86体系仅有的8个通用寄存器远远不能满足需要，在同一时钟周期中，如果有3个指令发布，你就需要3个输出寄存器和6个输入寄存器。我们该怎么办呢？聪明的工程师们发现了突破这个限制的方法：“寄存器重命名”。   </p>
<p>

4.寄存器重命名技术   </p>
<p>

    寄存器重命名，是CPU在解码过程中对寄存器进行重命名，解码器把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。   </p>
<p>

  <a href="http://www.win7zj.com/article/UploadPic/2012-3/20123613133505.jpg" target="_blank"><img border="0" width="200" height="170" src="table no_clip_image003_0000.jpg" alt="http://www.win7zj.com/article/UploadPic/2012-3/20123613133505.jpg" /></a> </p>
  <p>下面我们以一个超标量CPU执行8个算术指令为例：假设它在每个时钟周期中能对2个指令解码，引出计算结果是在指令发布后3个时钟周期发生的：   </p>
<p>

（1）在第1个时钟周期，两个指令发布：它们互不关联，因此，它们将在3个时钟周期后（第4个时钟周期）引出；   </p>
<p>

（2）在第2个时钟周期，我们首次遇到了“指令依赖”，指令3需要指令2的结果，此时指令3不能开始发布；   </p>
<p>

（3）如果是按序执行，指令4、5、6就不能在指令3前发布。只有在第5个时钟周期时（指令2的结果已得到）才能发布指令3；   </p>
<p>

（4）在第6个时钟周期有个大问题：我们想把结果写到寄存器R1，但这将改变指令5的结果。因此，我们只有在R1空闲时（第10个时钟周期）才能发布指令6。   </p>
<p>

    按照正常情况处理的话，尽管这个CPU每个时钟周期可以对2个指令解码，但它每个时钟周期的指令执行数只有0.53。如果每次程序所需的寄存器正被使用，我们可以把数据放到其它的寄存器中，在第6个时钟周期将寄存器R1重命名，指令6和指令8不再耽误CPU的工作。结果是我们能够将每个时钟周期的指令执行数提高50％。寄存器重命名技术可以使x86 CPU的寄存器可以突破8个的限制，达到32个甚至更多。寄存器重命名技术现在已经深深地扎根于超标量CPU中了。   </p>
<p>

    5.乱序执行技术   </p>
<p>

    除此之外，处理器工程师还引入了乱序执行技术，从一定程度上来缓解通用寄存器不足的问题。采用乱序执行技术的目的是为了使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。   </p>
<p>

    这好比请A、B、C三个名人为春节联欢晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字，如果这时在一张大纸上按顺序由A写好“春节”后再交给B写“联欢”，然后再由C写“晚会”，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。但如果采用三个人分别用三张纸同时写的做法，那么B和C都不必等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就像乱序执行），但当他们都写完后就必须重新在横幅上按“春节联欢晚会”的顺序排好（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）才能挂出去。   </p>
<p>

    不过，虽然采用寄存器重命名技术、乱序执行技术，但仍不能从根本上解决x86处理器通用寄存器不足的问题。以寄存器重命名技术来说，这种技术的寄存器操作相对于RISC来说，要花费一个时钟周期来对寄存器进行重命名，这无形中降低了处理器性能以及流水线工作效率，也增加了程序和编译器的优化难度。针对这个问题，最新的x86-64架构中（K8处理器），AMD在x86架构基础上将通用寄存器和SIMD寄存器的数量增加了1倍：其中新增了8个通用寄存器以及8个SIMD寄存器作为原有x86处理器寄存器的扩充。   </p>
<p>

    这些通用寄存器都工作在64位模式下，经过64位编码的程序就可以使用到它们。这些64位寄存器称为RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、RIP以及EFLAGS，在32位环境下并不完全使用到这些寄存器，同时AMD也将原有的EAX等寄存器扩展至64位的RAX，这样可以增强通用寄存器对字节的操作能力。从扩充方式上看，EAX等寄存器可以看做是RAX的一个子集，系统仍然可以完整地执行以往的32位编码程序。增加通用寄存器除了可高效存储数据外，还可作为寻址时的地址指针，从而缩短指令长度和指令执行时间，加快CPU的运算处理速度，同时也给编程带来方便。   </p>
<p>

    此外，为了保证K8的分支预测更有效率，K8的分支预测寄存器增加到64个。分支指令可以被设为真或假，而每个指令中的6位被分配到单独一个预测寄存器中，只有预测寄存器被设定为“真”时,那些指向预测寄存器为“真”的指令结果才会被执行。其次由于所有的分支都能并行执行，CPU所花的时间同只执行单个分支的时间是相同的，降低了预测出错的风险。第三由于CPU不再跳跃执行，它不会把程序代码分成小块。也就是说，稍前和稍后的程序代码可以打包。这样CPU能够一并将它们发布，增大并行工作量。从而使性能提高10％～15％，特别是在整数代码部分。   </p>
<p>

    不过在x86-64中，寄存器的扩展部分似乎仅对于整数、地址数据有效。对浮点和向量数据则仍然保持原样。我们能从K8向64位的扩展所获得的好处，只不过是可以在同样一条指令中，处理更大数值的整数数值以及管理空间更大的内存区域而已。而在32位的情况下，由于通用寄存器只能容纳最大32位的数据，因此显然要花费更多条指令对尺寸超过32位的数据进行处理。这种改进对服务器、科学计算这样的领域具有一定的意义，但显然并不是普通家用环境急需的改进。   </p>
<p>

    可以说，处理器的寄存器对处理器的性能有着巨大的影响。但是无论怎么发展，通用型CPU目前还没有脱离x86架构的限制，也许有一天，新的寄存器技术能让我们的CPU变得更加功能强大！ </p>

</div>
</body>
</html>
