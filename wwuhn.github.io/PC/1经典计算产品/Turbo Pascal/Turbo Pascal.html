<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 
<title></title>
 <style type="text/css">
.container{
font-size:1.3em;
text-indent:2em;
margin:auto;
font-family:"mv boli","宋体";
width:75.29%;
line-height:1.3em;
}
P{
margin:8px;
text-indent:2em;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;
line-height:1.3em;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:5px;
margin-bottom:-15px;
text-indent:0em;
}
img{
margin-right:5px;
}
.fc{
color:red;
}
table {
	width:100%;
	margin:auto;
	border-collapse:collapse;
	font-family: "MV Boli";
	text-align:center;
	line-height:30px;
	table-layout:fixed;
}

table th,table td{
border:1px solid #aaa;
font-size:20px;
color:#000000;
text-align:left;
font-family: "MV Boli";
}

table thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:2px 0px;
display:table-column-group;
}
table th{
background-color:#f2f4b9;
}
table th.title{
background-color:#e3e685;
}

table caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


table .xhx{
border-bottom:0px solid #aaa;
}

table .font16{
font-size:12px;

}

table tr{
height:6px;
}
table tr>th{
font-size:16px;
}

table tr>td{
font-size:1em;text-align:center;
width:30%;
}
table tr>td+td{
text-align:left;
width:70%;
font-size:1em;
}
table tr>td+td+td{
font-size:1em;

}
table tr>td+td+td+td{
font-size:1em;text-align:center;
}table tr>td+td+td+td+td{
font-size:1em;text-align:left;
}
table tr>td+td+td+td+td+td{
font-size:1em;
}


table tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}
</style>
</head>

<body>
<div class="container">
  <p align="left"><strong><a href="http://www.techcn.com.cn/index.php?doc-view-140972.html">Turbo Pascal</a></strong></p>
  <p align="left">Turbo Pascal是Borland公司一个很有代表性的软件开发产品。从语言角度说Turbo Pascal是Pascal语言的一个扩展。它扩展了标准Pascal的功能特性。在语法上，Turbo Pascal吸取了其他语言如C等的特性，简化了标准Pascal的语法；在功能上，Turbo Pascal提供了包括屏幕控制、图形处理、系统调用等有用的函数库（Turbo Pascal中称为单元）。 </p>
<p>
      <img width="640" height="638" src="Turbo Pascal_clip_image001.jpg" alt="http://www.techcn.com.cn/uploads/201001/1263732735GmuJFNtZ.jpg" /> </p>
<p>
    Turbo Pascal包括CP/M、MS-DOS、Windows等不同操作系统上的版本。 </p>
<p>
    1983年，Borland公司发布了Turbo Pascal的第一个版本。该版本的编译器核心部分由安德斯·海尔斯伯格授权给Borland公司。同时，安德斯·海尔斯伯格也作为雇员加入了Borland公司，并且是后来所有Turbo Pascal版本与Delphi前3个版本的架构师。在第一个版本的Turbo Pascal中，Borland公司的创始人Philippe Kahn为该版本的Turbo Pascal添加了用户界面与编辑器。第一版本Turbo Pascal是个人电脑上编译器发展的一个里程碑。 </p>
<p>
    1989年发布的Turbo Pascal 5.5版是一个重要的版本，从这一版本起，Borland公司把OOP引入Pascal语言，这就是大家所知道的Object Pascal的开端。 </p>
<p>
    Turbo Pascal 6.0推出一个用OOP思想封装的Dos下的应用程序框架（Framework），叫做TurboVision，这个版本的IDE据信即是使用该Framework开发的。 </p>
<p>
    Turbo Pascal的最后一个版本叫做Borland Pascal 7，它包含一个增强的Dos下的IDE和编译器，可以创建Dos和Windows3.x程序，后来为Delphi1.0代替。 </p>
<p>
    1983年11月20日 Turbo Pascal version 1.0发布 </p>
<p>
    1986年9月17日 Turbo Pascal version 3.02 发布 </p>
<p>
    1989年5月2日 Turbo Pascal version 5.5 发布 </p>
<p>
  <a name="section" id="section">目录</a> </p>
<p>
    • <a href="#1">关于Turbo Pascal</a> </p>
<p>
    • <a href="#3">Pascal程序语言入门</a> </p>
<p>
    • <a href="#5">PASCAL语言的发展</a> </p>
<p>
    • <a href="#7">数据格式</a> </p>
 
  <p align="left">关于Turbo Pascal<a name="1" id="1"></a> <a href="#section">回目录</a></p>
<p>
      <img border="0" width="520" height="812" src="Turbo Pascal_clip_image002.jpg" alt="http://www.techcn.com.cn/uploads/201001/1263732735NbawMcW8.jpg" /> </p>
<p>
      </p>
<p>
    Pascal是一种计算机通用的高级程序设计语言。它由瑞士Niklaus Wirth教授于六十年代末设计并创立。 </p>
<p>
    以法国数学家命名的Pascal语言现已成为使用最广泛的基于DOS的语言之一，其主要特点有：严格的结构化形式；丰富完备的数据类型；运行效率高；查错能力强。 </p>
<p>
    正因为上述特点，Pascal语言可以被方便地用于描述各种算法与数据结构。尤其是对于程序设计的初学者，Pascal语言有益于培养良好的程序设计风格和习惯。IOI(国际奥林匹克信息学竞赛)把Pascal语言作为三种程序设计语言之一， NOI(全国奥林匹克信息学竞赛)把Pascal语言定为唯一提倡的程序设计语言，在大学中Pascal语言也常常被用作学习数据结构与算法的教学语言。 现在由于版权等问题，在NOIP中使用Free Pascal，而在NOI和IOI中使用Lazarus 0.9.10和Linux系统。</p>
<p>
    在Pascal问世以来的三十余年间，先后产生了适合于不同机型的各种各样版本。其中影响最大的莫过于Turbo Pascal系列软件。它是由美国Borland公司设计、研制的一种适用于微机的Pascal编译系统。该编译系统由1983年推出1.0版本发展到1992年推出的7.0版本，其版本不断更新，而功能更趋完善。　　 </p>
<p>
    Pascal程序语言入门<a name="3" id="3"></a> <a href="#section">回目录</a> </p>
<p>
    Pascal是由瑞士Niklaus Writh教授于60年代末设计并创立。它是一种计算机通用的高级程序设计语言，是一种优良的程序设计教学语言，整个语言紧凑整齐，概念简洁，数据结构和控制结构比较丰富，程序可读性好，查错能力强，有利于培养学生严谨、清析的程序设计风格和良好习惯，并使他们从中领会和理解精细的程序设计技巧。尤其引入了结构化程序设计的思路，充分考虑了算法设计中的自顶向下、由粗到精的模块化思想，以及总可以将算法步骤剖解为顺序、分支、重复三种基本结构流程的结构化原则，提供了丰富的数据类型和清晰的描述模块化的语句。</p>
<p>
    Turbo Pascal系列软件作为开发系统软件与就任软件及实施科学计算和教学的有力工具，下发挥着越来越大的作用。也是国际和全国青少年信息学奥林匹克竞赛指定的语言之一。从历届信息学竞赛的情况看，它是最能出成绩和选手最欢迎的语言。以后的例子就以Turbo Pascal 7.0进行程序设计。</p>
<p>
    下面我们就以一个实例来看一看Pascal程序的结构，从中认识到Pascal语言程序的书写方式，以及其规范的标准设计方式。 </p>
<p>
    PASCAL语言的发展<a name="5" id="5"></a> <a href="#section">回目录</a> </p>
<p>
    在Pascal问世以来的三十余年间，先后产生了适合于不同机型的各种各样版本。其中影响最大的莫过于Turbo Pascal系列软件。它是由美国Borland公司设计、研制的一种适用于微机的Pascal编译系统。该编译系统由1983年推出1.0版本发展到1992年推出的7.0版本，其版本不断更新，而功能更趋完善。 </p>
<p>
    Turbo Pascal语言是编译型程序语言，它提供了一个集成环境的工作系统，集编辑、编译、运行、调试等多功能于一体 </p>
<p>
    Pascal有5个主要的版本，分别是Unextended Pascal、Extended Pascal、Object-Oriented Extensions to Pascal、Borland  Pascal和Delphi Object Pascal。其中，Unextended  Pascal、Extended Pascal和Object-Oriented  Extensions to Pascal是由Pascal标准委员会所创立和维护的，Unextended Pascal类似于瑞士Niklaus Wirth教授和K.Jensen于1974年联名发表的Pascal用户手册和报告，而Extended Pascal则是在其基础上进行了扩展，加入了许多新的特性，它们都属于正式的Pascal标准；Object-Oriented Extensions to  Pascal是由Pascal标准委员会发表的一份技术报告，在Extended  Pascal的基础上增加了一些用以支持面向对象程序设计的特性，但它属于非正式的标准。Borland  Pascal和Delphi Object Pascal是由Borland公司专门为其开发的编译工具设计的Pascal语言，前者是用于DOS的Turbo  Pascal系列和Windows 3.x的Turbo  Pascal for Windows的传统高级语言，后者是用于Windows的Delphi和Linux的Kylix的面向对象程序设计语言，它们都不是正式的Pascal标准，具有专利性。但由于Turbo Pascal系列和Delphi功能强大并且广为流行，Borland Pascal和Delphi Object Pascal已自成为一种标准，为许多人所熟悉 </p>
<p>
  <img border="0" width="500" height="648" src="Turbo Pascal_clip_image003.jpg" alt="http://www.techcn.com.cn/uploads/201001/1263732735oGeayBIA.jpg" /> </p>
<p>
    数据格式<a name="7" id="7"></a> <a href="#section">回目录</a> </p>
<p>
    例1：判断这个数是奇数还是偶数。</p>
<p>
    它的Pascal程序如下:</p>
<p>
    program e5_1( input, output) ; {程序首部}</p>
<p>
    var {变量说明}</p>
<p>
    a:longint {在tp7中，规定pi约等于3.1415926536}</p>
<p>
    begin {程序开始}</p>
<p>
    readln(a); {打入数字}</p>
<p>
    if a mod 2 &lt;&gt;0{判断是否为奇数}</p>
<p>
    then writeln(a&quot;-jishu&quot;) {输出a-jishu</p>
<p>
    else writeln(a&quot;-oushu&quot;);或a-oushu}</p>
<p>
    end. {结束程序}</p>
<p>
    从以上简单的例子可以看出，Turbo Pascal程序是由程序首部、程序说明部分和程序执行部分组成。具体如下所示：</p>
<p>
    program 程序名; {程序首部，可省略}</p>
<p>
    说明部分 {说明部分}</p>
<p>
    begin {程序开始}</p>
<p>
    语句1； {执行语句}</p>
<p>
    语句2； {执行语句}</p>
<p>
    …… {执行语句}</p>
<p>
    End. (End;){结束程序}</p>
<p>
    上面程序由如下两部分组成:</p>
<p>
    1、程序首部</p>
<p>
    程序首部是程序的开头部分，由保留字program后，接程序名及程序参数表组成，结束时一定要有分号。程序名yzhch是用户自己定义的标识符，参数表一般是文件变量名，用于该程序与外界的数据交流。最常用的参数为input和output。Turbo  Pascal程序首部中参数表可以省略。</p>
<p>
    2、程序说明部分</p>
<p>
    Pascal语言要求用户将在程序中所使用的标号、常量、类型、变量、记录、文件、以及过程和函数除了Pascal自己预先定义的标准量之外，都必须在说明部分说明后才能在程序执行部分使用。但各个内容部分是可选的，只有执行程序部分需要的时候才进行说明。</p>
<p>
    3、程序执行部分</p>
<p>
    紧接着说明部分的begin和end之间的部分为程序的执行部分。它由一系列语句组成，一条语句执行一定的功能，所有语句完成程序设计的任务。语句之间用“;”隔开，允许一行写多个语句，也允许一个语句写多行。最后一行的end后加“.”号表示结束。所跟其后的语句将无任何作用。Begin与end应配对出现，这是每一个Turbo Pascal程序都必须的。</p>
<p>
    注意：后面将学习到的语句中，也需要引用begin和end作为程序段的分隔标记，但其必须遵守语句规则。</p>
<p>
    字符集和符号</p>
<p>
    一、基本字符</p>
<p>
    （1）字母：A到Z，a到z和_（下划线）</p>
<p>
    （2）数字：0、1、2、3、4、5、6、7、8、9</p>
<p>
    （3）特殊字符：+、-、*、/、=、^、&lt;、&gt;、(、)、[、]、{、}、.、:、;、'、#、$、@</p>
<p>
    赋值运算符：:=</p>
<p>
    关系运算符：&gt;、&lt;、&lt;&gt;、=、&gt;=、&lt;=</p>
<p>
    子界分隔符：..</p>
<p>
    括号：[]</p>
<p>
    注释号：{}</p>
<p>
    二、符号</p>
<p>
    （一）保留字</p>
<p>
    保留字是由字母拼成的字，Turbo Pascal语言预先规定了他们的意义，不允许被再定义。因此，不能作为用户自定义的标示符，否则Turbo Pascal编译器将提示出错信息。Turbo Pascal共有保留字50多个，如下表所示。</p>
<p>
    保留字 含义 保留字 含义</p>
<p>
    And 逻辑“与”运算 Mod 求余运算</p>
<p>
    Asm 汇编语句调用 Nil 空指针</p>
<p>
    Array 定义数组 Not 逻辑“非”运算</p>
<p>
    Begin 复合语句结构部分 Object 对象定义符</p>
<p>
    Case 情况语句结构部分 Or 逻辑“或”运算</p>
<p>
    Constructor 构造对象定义 Packed 紧缩数组定义</p>
<p>
    Destrutor 销毁对象定义 Procedure 过程说明符</p>
<p>
    Div 整除运算 Program 程序首部定义</p>
<p>
    Do For循环语句结构部分 Record 记录定义</p>
<p>
    Downto For循环语句结构部分 Repeat  Repeat 循环语句结构部分</p>
<p>
    Else 条件语句结构部分 Set 集合定义</p>
<p>
    End 复合语句结构部分 Shl 二进制左移运算符</p>
<p>
    Exports 动态链接库输出项目定义 Shr 二进制右移运算符 </p>
<p>
    File 文件定义 String 字符串定义</p>
<p>
    For For循环语句结构部分 Then 条件语句结构部分</p>
<p>
    Function 函数定义 To For循环语句结构部分</p>
<p>
    Goto 无条件转移语句 Type 类型说明</p>
<p>
    If 条件语句结构部分 Unit 多个程序模块说明</p>
<p>
    Implementation 单位实现部分起始标识符  Until Repeat 循环语句结构部分</p>
<p>
    In 属于 Uses 单元说明</p>
<p>
    Inherited 对象继承说明符 Var 变量定义</p>
<p>
    Inline 机器代码插入指令 While While循环语句结构部分</p>
<p>
    Interface 外挂单元文件接口说明 With 开域语句结构部分</p>
<p>
    Label 标号定义 Xor 逻辑“异或”运算</p>
<p>
    Library 动态链接库DLL编译指令</p>
<p>
    数据类型、常量的变量</p>
<p>
    一、数据类型的概念</p>
<p>
    计算机处理数据对象是一个广义的概念。例如，125、12.76是数据，’xiang qj zhong’这一串字符也是数据。前者是数值数据，后者是字符串数据，是非数值数据。显然，为了表示这些数据，它们在内存中必须以不同方式存放。为处理这些数据，计算机对它们施加的运算也不同。为此，Turbo Pascal语言建立了数据类型的概念，对描述的数据进行分类。每一种数据类型定义了一个具有相同性质的数据集合。各种数据类型的数据具有不同的性质。程序中所用到的每一个数据，包括常量和变量都有一个和它相联系的类型。由此决定了数据所具有的值，也决定了对该数据所能进行的操作。</p>
<p>
    Turbo Pascal语言中数据具有丰富的类型，按它们的特点可以分为简单类型、构造类型、指针类型和过程类型四大类，如图下所示。</p>
<p>
    其中，标准类型用语言系统预先定义的标准标识符表示，整型用integer表示，实型用real表示，布尔型用boolean表示，字符型用char表示。</p>
<p>
    二、常量</p>
<p>
    常量是指在程序中使用的一些具体的整型数、实型数和字符串。</p>
<p>
    (1)整型数：如9、3、-5、0等。</p>
<p>
    (2)实型数：如3.1、-6.1E+20等。</p>
<p>
    (3)字符串：是用单引号括起来的一串字符，如，’book’、’96•5’、’ABC’等。</p>
<p>
    以上列举的都可以作为常量在程序中使用。为了提高程序的可读性并使程序便于修改，在程序中往往用一些标识符来代表具体的常量。</p>
<p>
    在Turbo Pascal语言中，可以给一些常量取个名字用一个标识符代表它，这就是常量定义。例如，Cost=60；Blank=’ ’。</p>
<p>
    经常量定义的标识符又称为常量标识符。</p>
<p>
    在Turbo Pascal语言中，常量定义要写在常量定义部分中。</p>
<p>
    常量定义部分的一般形式:</p>
<p>
    Const</p>
<p>
    (常量标识符1)= (常量1);</p>
<p>
    (常量标识符2)=(常量2);</p>
<p>
    (常量标识符n)=(常量n);</p>
<p>
    Const是保留宇，表示开始一个常量定义部分，其后可以有若干个常量定义，这些</p>
<p>
    常量定义之间要用“；”号分隔。例如：</p>
<p>
    Const</p>
<p>
    Cost=60;</p>
<p>
    A=Cost+30;</p>
<p>
    Pi =3.14159;</p>
<p>
    Turbo Pascal语言对常量定义有如下要求:</p>
<p>
    (1)常量定义要放在程序的常量定义部分，即程序首部之后，执行部分之前。</p>
<p>
    (2)必须遵循先定义后使用的原则，即只有已经定义的常量标识符，才能在程序中</p>
<p>
    使用。</p>
<p>
    三、变量</p>
<p>
    在程序执行过程中其值可以改变的数据，称为变量。每个变量都要有一个名称，这就是变量名。变量名由用户自己定义，但必须符合标识符的规定。</p>
<p>
    在一个程序中，一个变量只能属于一种确定的数据类型。因此，程序中出现的每个变量都必须说明其数据类型，这样就规定了该变量的取值范围，也决定了对该变量所能执行的运算操作。</p>
<p>
    变量的类型，可以是标准数据类型integer、real、boolean和char，也可以是用户自定义的各种类型。</p>
<p>
    变量说明形式是：一个变量标识符或由逗号隔开的多个变量标识符在它的冒号&quot;：&quot;后面说明其数据类型。</p>
<p>
    在Turbo Pascal程序中，变量说明要写在变量说明部分中。</p>
<p>
    变量说明部分的一般形式:</p>
<p>
    var</p>
<p>
    (变量说明1)；</p>
<p>
    (变量说明2)；</p>
<p>
    ……(变量说明n)；</p>
<p>
    其中var是保留字，表示一个变量说明部分开始。一个var可以含有多个不同的变量说明，每个变量说明之间用分号隔开，有时称被分号隔开的变量说明为变量说明项。例如：</p>
<p>
    var</p>
<p>
    x，y：real；</p>
<p>
    chl：char；</p>
<p>
    t，f：boolean；</p>
<p>
    注意:不同类型的变量一般不能互相串用。</p>
<p>
    这里还应指出，变量一经说明系统就在计算机内存中为其分配一个存贮空间。在程序中使用到变量时，就在相应的内存中存入数据或取出数据，这种操作称为变量的访问。</p>
<p>
    标准数据类型</p>
<p>
    Pascal向程序设计者提供了丰富的数据类型，它们用于专门的目的，但却都是由简单的、非构造型的数据类型所构成的。本节介绍Turbo Pascal中最为基本的几种数据类型：整型、实型、布尔型和字符型。它们都是系统定义的简单数据类型，称为标准数据类型，其对应的名字称为标准标识符。</p>
<p>
    1、整型</p>
<p>
    一个整型数据用来存放整数，整型数据可以是正整数、负整数和整数零。</p>
<p>
    Turbo Pascal中的整型常数必须按规定严格书写。</p>
<p>
    Turbo Pascal支持五种预定义整型，它们是短整型(Shortint)、整型(Integer)、长整型 (Longint)、字节型(Byte)和字类型(Word)，每一种类型规定了相应的整数取值范围以及所占内存字节数(一个字节为8个二进制位)。因此，用户在具体编程定义变量类型时，要根据它们的特点选用适当的类型，以达到理想的效果。当两个不同范围类型的操作数进行运算时，得到的结果属于较大范围的类型。如下表所示。</p>
<p>
    Turbo Pascal语言规定可以对整型数据进行算术运算符+、一、*、Div、Mod。</p>
<p>
    它们分别表示加、减、乘、整除和取余。这五种运算，要求参加运算的两个数都是整型数，运算结果也是整型数。前三种运算与一般的算术运算加、减、乘相同。Div整除运算，是两个整型数相除取整数部分(商的整数部分)，得到整型结果。Mod取余运算，是两个整型数相除取余数，余数的符号与被除数符号相同。例如：</p>
<p>
    3 Div 2 = 1 5 Div 7 = 0</p>
<p>
    6 Div (-4) = - 1 (-12) Div (-5) = 2 </p>
<p>
    7 Mod 4 = 3 (14) Mod (-4) = 2</p>
<p>
    (-18) Mod (-6) = 0 6 Mod l7 = 6</p>
<p>
    由此可见，a Mod b，所得结果的符号与a相同，其值(绝对值)在0～∣b∣-1之间。运算符Mod与Div之间有如下关系：</p>
<p>
    a Mod b = a – (a Div b) * b  (b&lt;&gt;0)</p>
<p>
    其中Mod运算的结果的符号与a的符号相同。</p>
<p>
    利用以上两种运算可以对正整数进行分离。例如：</p>
<p>
    n为四位数8531，可用下法分离出它的个、十、百、千位。</p>
<p>
    8531 Mod l0 = 1 (个位数)</p>
<p>
    (8531 Mod l00) Div l0 = 3 (十位数)</p>
<p>
    (8531 Mod l000) Div l00 = 5 (百位数)</p>
<p>
    8531 Mod l000 = 8 (千位数)</p>
<p>
    利用 a Mod b可以判断a能否被b整除。当a Mod b = 0时，a能被b整除。</p>
<p>
    2、实型</p>
<p>
    一个实型数据用来存放实数。实型数据可以是正实数、负实数和实数零。实型数据一般用小数或指数形式(亦称科学表示法)表示。例如：</p>
<p>
    +1993，33，3.5E+5(=3.5×10５)， -0.5E-3(=-0.5×10-３，)，-20.0，，0.0等都是合法实型数。</p>
<p>
    Turbo Pascal支持一种预定义实型，它们是基本实型(Real)、单精度实型(Single)、双精度实型(Double)、扩展实型(Extended)和装配实型(Comp)。每一种类型规定了相应的实数取值范围和所占内存字节数，以及它们所能达到的精度，即有效数字位数。因此，用户在具体编程时应根据以上的参数适当选用，以达到最佳效果。如下表所示。</p>
<p>
    对于此类实型数据，若其绝对值大于上界，则产生上溢；绝对值小于下界，则产生下溢，下溢导致结果为0。Comp类型的取值范围是-263+1～238-1之间的整数，相当于十进制的-9.218～9.218。由于Comp类型的数据表示成二进制形式的数，这种类型的变量有时处理起来比较方便，特别对于数值很大的整数间的计算，这种数据类型很有用。</p>
<p>
    Turbo Pascal语言允许实型数使用下列运算符进行运算。</p>
<p>
    运算符：+、-、*、/</p>
<p>
    分别表示加、减、乘和除。其中&quot;/&quot;叫实数除，即使两个整型数相除，其结果也总是实型，如： 7/2=3.5 6/3=2.0</p>
<p>
    3、字符型</p>
<p>
    用标准标识符Char标明字符型。字符型数据可以是字母、符号、数字(0-9)等ASCII码的所有字符。Turbo  Pascal支持扩展ASCII码，共包括256个字符。但非印刷字符是不能在标准显示上显示或打印输出。在计算机内部，字符集的元素是以该元素在字符集内的顺序位置来标记的，位置取值范围为0~255，我们称这些整数为字符在字符集内的序数值或序号。每个字符型数据在内存中占一个字节。将字符用单引号括起来，即成字符常数，如，’X’，’7’，’?’。字符常数可按字符的序数值确定大小关系，也就是说它们的大小由它们所对应的ASCII码值决定，如：’Y’，’Z’，’A’&lt;’a’。 </p>
<p>
    由于采用ASCII码，字符依ASCII码序号排列。这样，字符与ASCII码序号有一一对应的映射关系。</p>
<p>
    4、布尔型</p>
<p>
    一个布尔型数据用来存放逻辑值，或称布尔值。Turbo Pascal支持预定义布尔型，以标准标识符Boolean表示。Boolean一词，系根据19世纪英国数学家George boole (1815-1864)的名字而得，George boole为现代布尔代数之父。布尔型数据的值只有两个：True(逻辑真)和False(逻辑假)。布尔型是顺序类型，规定False&lt;TRUE，FALSE的序号为0，TRUE的序号为1。</p>
<p>
    逻辑运算的结果只有两个：True（真）和False（假）。Turbo Pascal提供了六种关系运算符和三种逻辑运算符：</p>
<p>
    =(等于)、&lt;（小于）、&lt;=（小于等于）、&gt;（大于）、&gt;=（大于等于）、&lt;&gt;（不等于）</p>
<p>
    NOT（非）、AND（与）、OR（或）</p>
<p>
    运算关系</p>
<p>
    函 数</p>
<p>
    标准函数。Turbo Pascal语言提供了自变量为整型量的标准函数有顺序函数算术函数和转换函数等。</p>
<p>
    标准函数是Turbo Pascal语言预先定义的，它们实际上是能完成特定功能的称步子程序的程序段。每个标准函数都用一个标识符来标识，每个标准函数都能完成一个特定的功能，在程序中可以直接调用它们。Turbo Pascal语言中某些标准函数与数学中的函数有相似之处。</p>
<p>
    一、整数类型函数</p>
<p>
    整型是顺序类型，即所有的整型数都是按一定的顺序排列的。如3的后序数是4，350的后序数是351。以后介绍的布尔型、字符型、枚举类型和子界类型等都是顺序类型。顺序函数可以对顺序类型数据进行操作，但要注意它们自变量的取值范围。</p>
<p>
    ①前趋函数：Pred(x)函数值为x-l，例如：</p>
<p>
    Pred (6)=5 Pred (-21)=-22</p>
<p>
    ②后继函数：Succ (x)函数值为x+l，例如：</p>
<p>
    Succ (l5)=16 Succ (-114)= -113 </p>
<p>
    ③绝对值函数：Abs (x)函数值为︱X︱，例如： </p>
<p>
    Abs (-119)=119 Abs (101)=101</p>
<p>
    ④平方函数：Sqr (x)函数值为X2，例如：</p>
<p>
    Sqr (-5)=，25 Sqr (l0)= 100</p>
<p>
    以上四个函数的结果仍是整型数。</p>
<p>
    ⑤奇函数：Odd (x)，函数的结果为布尔型。当X为奇数时，函数值为true；当X为偶数时，函数值为false。例如：</p>
<p>
    Odd (13)= True Odd (16)= False</p>
<p>
    ⑥字符函数：Chr (X)，函数值是序号的ASCII字符，属字符型。例如：</p>
<p>
    Chr (65)=’A’ Chr (32)=’ ’</p>
<p>
    二、实数类型函数</p>
<p>
    在下列算术函数中，X可以是实型或整型数的表达式。对于函数Abs和Sqr，其结果类型和变量X的类型相同，其他算术函数的结果类型都是实型。</p>
<p>
    绝对值函数Abs(x)：函数值为x的绝对值</p>
<p>
    平方函数Sqr (x)：函数值为x的平方</p>
<p>
    小数函数Frac (x)：函数值为x的小数部分</p>
<p>
    整数函数Int (x)：函数值为x的整数部分</p>
<p>
    正弦函数Sin (x)：函数值为x的正弦，其中的单位为弧度</p>
<p>
    余弦函数Cos (x)：函数值为x的余弦，其中的单位为弧度</p>
<p>
    指数函数Exp (x)：函数值为e（x）</p>
<p>
    对数函数Ln (X)：函数值为x的自然对数</p>
<p>
    平方根函数的Sqrt (x)：函数值为x的平方根</p>
<p>
    反正切函数Arctan(x)：函数值为x的反正切，单位为弧度</p>
<p>
    随机函数Random：无自变量时，函数值取(0,1)间的随机小数；有自变量且为Word类型时，函数值取(0，自变量)间的随机整数。</p>
<p>
    三、字符类型函数</p>
<p>
    Turbo Pascal语言提供如下自变量为字符型的标准函数，其中Chr为字符型。</p>
<p>
    后继函数Succ (ch)：例如，Succ (’8’)=’9’ Succ (’E’)=’F’</p>
<p>
    对字符集的最后一个字符，Succ函数无意义。</p>
<p>
    前趋函数Pred (ch)：例如，Pred (’7’)=’6’ Pred (’B’)=’ A’</p>
<p>
    序数函数Ord (ch)：:给出字符ch在ASCII字符集中的序号，结果为整型。</p>
<p>
    注意：Ord (’7’)&lt;&gt;7，正确的是：Ord (’7’)=Ord(’0’)+7=48+7=55</p>
<p>
    若ch是数字字符，则Ord (ch)-Ord ('0')是该数字字符的数值。例如：Ord (’7’)-Ord(’0’)=7</p>
<p>
    前面介绍的字符函数Chr (i)是Ord (ch)的逆函数。例如:</p>
<p>
    Chr (55)= ’7’ Chr (Ord(’A’))=’A’</p>
<p>
    三、布尔类型函数</p>
<p>
    Turbo Pascal语言提供布尔型函数主要是几个字符型函数。</p>
<p>
    Ord (B) 例如：Ord (false)=0 Ord  (true)=1</p>
<p>
    表达式</p>
<p>
    运算是对数据进行加工处理的过程，得到运算结果的数学公式或其它式子统称为表达式。表达式可以是常量也可以是变量或算式，在表达式中又可分为：算术表达式、逻辑表达式和字符串表达式。</p>
<p>
    1、算术表达式：</p>
<p>
    算术表达式是最常用的表达式，又称为数值表达式。它是通过算术运算符来进行运算的数学公式。我们先来看Visual  Basic中的算术运算符：</p>
<p>
    算术运算符</p>
<p>
    运算符 表达式 说 明 举 例</p>
<p>
    * X*Y 求X乘Y的值 6*7=42</p>
<p>
    / X/Y 求X除Y的值（浮点数运算） 2.76/1.2=2.3</p>
<p>
    div X div Y 求X除Y的整数商（对整型数计算） 25=5</p>
<p>
    Mod X mod Y 求X除Y的余数（对整型数运算） 25 mod 4=1</p>
<p>
    + X+Y 加法运算 32+2=34</p>
<p>
    - X-Y 减法运算 48-21=27</p>
<p>
    由于Visual Basic只能识别按其格式书写的数学表达式，所以必须将我们常用的数学表达式转换成Visual Basic表达式。例如：</p>
<p>
    数学式 Visual Basic表达式</p>
<p>
    注:Turbo Pascal中没有乘方函数,但乘方运算可通过指数函数Exp (x)进行,如计算x^y,有</p>
<p>
    x^y=e^(y*lnx)=Exp(y*Ln(x))</p>
<p>
    2、逻辑运算</p>
<p>
    逻辑运算的结果只有两个：True（真）和False（假）。Visual Basic提供了六种关系运算符和三种逻辑运算符：</p>
<p>
    =(等于)、&lt;（小于）、&lt;=（小于等于）、&gt;（大于）、&gt;=（大于等于）、&lt;&gt;（不等于）</p>
<p>
    NOT（非）、AND（与）、OR（或）</p>
<p>
    运算关系</p>
<p>
    p  q  NOT p  p AND q p OR q</p>
<p>
    True  True  False  True True</p>
<p>
    True  False  False  False True</p>
<p>
    False  True True False True</p>
<p>
    False  False  True False False</p>
<p>
    例如：5&gt;3 结果为 True, “a”&gt;”b” 结果为False。</p>
<p>
    3、表达式的运算优先顺序</p>
<p>
    在进行表达式的转换过程中，必须了解各种运算的优先顺序，使转换后的表达式能满足数学公式的运算要求。运算优先顺序为：</p>
<p>
    括号→函数→乘、除→加、减→字符连接运算符→关系运算符→逻辑运算符</p>
<p>
    如果同级的运算是按从左到右次序进行；多层括号由里向外。</p>
<p>
    例：</p>
<p>
    （10+6）*3^2*COS(1)/2*8+7</p>
<p>
    ① ④ ③ ⑤ ② ⑥ ⑦ ⑧</p>
<p>
    Sqrt(Abs(p/n-1))+1 </p>
<p>
    ④ ③ ① ② ⑤ </p>
<p>
    主要语句：<a name="9" id="9"></a> <a href="#section">回目录</a> </p>
<p>
    赋值语句：&lt;变量&gt;:=&lt;表达式&gt;；</p>
<p>
    输入语句；Read([&lt;文件&gt;,]&lt;变量1&gt;,[&lt;变量2&gt;,[…]]);或ReadLn([&lt;文件&gt;,][&lt;变量1&gt;,[&lt;变量2&gt;,[…]]]);</p>
<p>
    输出语句：格式同上，Write Writeln</p>
<p>
    判断语句；if &lt;Boolean表达式&gt;  then &lt;语句块1&gt; else &lt;语句块2&gt;</p>
<p>
    循环语句：</p>
<p>
    FOR循环1：FOR &lt;顺序型变量&gt;:=&lt;初值&gt; TO &lt;终止量&gt; DO &lt;语句块&gt;;</p>
<p>
    FOR循环2：FOR &lt;顺序型变量&gt;:=&lt;初值&gt; DOWNTO &lt;终止量&gt; DO &lt;语句块&gt;;</p>
<p>
    注：FOR循环1 是初值的ascii码值小于等于终止量的（即从小到大），</p>
<p>
    FOR循环1 是初值的ascii码值大于等于终止量的（即从大到小），</p>
<p>
    WHILE循环：WHILE &lt;Boolean表达式&gt; DO &lt;语句块&gt;;</p>
<p>
    REPEAT-UNTIL循环：REPEAT &lt;语句块&gt;; UNTIL &lt;Boolean表达式&gt;;</p>
<p>
    复合语句（语句至少2句时使用）：begin</p>
<p>
    （语句1）；</p>
<p>
    （语句2）；</p>
<p>
    .....</p>
<p>
    （语句n）；</p>
<p>
    end.</p>
<p>
    pascal编程时常见错误：</p>
<p>
    1 无效DoS功能号 </p>
<p>
    2 文件末找到 </p>
<p>
    3 路径未找到 </p>
<p>
    4 打开文件过多 </p>
<p>
    5 禁止文件存取 </p>
<p>
    6 无效文件句柄 </p>
<p>
    12 无效文件存取代码 </p>
<p>
    15 无效驱动器号 </p>
<p>
    16 不能删除当前目录 </p>
<p>
    17 不能跨驱动器改文件名 </p>
<p>
    100 Disk read error 磁盘读错误 </p>
<p>
    101 Disk write error 磁盘写错误 </p>
<p>
    102 文件变量末赋值 </p>
<p>
    103 File not open 文件未打开 </p>
<p>
    104 File not open for input 文件未用输入方式打开 </p>
<p>
    105 File not open for output 文件末用输出方式打开 </p>
<p>
    106 Invalid numeric format 无效数字格式 </p>
<p>
    150 磁盘写保护 </p>
<p>
    151 未知单元 </p>
<p>
    152 驱动器未准备好 </p>
<p>
    153 未知命令 </p>
<p>
    154 数据CRC校验错 </p>
<p>
    155 驱动器请求的结构长度错 </p>
<p>
    156 磁盘定位错 </p>
<p>
    157 未知媒介类型 </p>
<p>
    158 扇区末找到 </p>
<p>
    159 打印机缺纸 </p>
<p>
    160 设备写失败 </p>
<p>
    161 设备读失败 </p>
<p>
    162 硬件故障 </p>
<p>
    200 Division by zero 被零除 </p>
<p>
    201 Range check error 数据范围检查错 </p>
<p>
    202 Stack overflow error 堆栈溢出错 </p>
<p>
    203 Heap overflow error 堆溢出错 </p>
<p>
    204 Invalid pointer operation 无效指针操作 </p>
<p>
    205 Floating point overflow 浮点上溢出 </p>
<p>
    206 Floating point underflow 浮点下溢出 </p>
<p>
    207 Invalid floating point operation 无效浮点运算 </p>
<p>
    208 未安装覆盖管理程序 </p>
<p>
    209 覆盖文件读错 </p>
<p>
    210 Object not initialized 对象未初始化 </p>
<p>
    211 Call to abstract method 调用抽象方法 </p>
<p>
    212 Stream registration error 流登计错 </p>
<p>
    213 Collection index out of range 集合下标越界 </p>
<p>
    214 Collection overflow error集合溢出 </p>
<p>
    215 Arithmetic overflow error 算术上溢错误 </p>
<p>
    216 General protection fault 存取非法 </p>
<p>
    217 控制-C </p>
<p>
    218 授权指令 </p>
<p>
    219 无效的TYPECAST </p>
<p>
    220 无效的变体TYPECAST </p>
<p>
    221 无效的变体操作 </p>
<p>
    222 没有变体方法调用DISPATCHER </p>
<p>
    223 不能建立变体数组 </p>
<p>
    224 变体不包含数组 </p>
<p>
    225 变体数组边界错误 </p>
<p>
    226 TLS初始化错误 </p>
<p>
    这些是编译错误： </p>
<p>
    l内存溢出 </p>
<p>
    2缺标识符 </p>
<p>
    3标识符未定义 </p>
<p>
    4标识符重定义 </p>
<p>
    5语法错误 </p>
<p>
    6实型常量错 </p>
<p>
    7整型常量错 </p>
<p>
    8字符串常量跨行 </p>
<p>
    9文件嵌套过多 </p>
<p>
    10非正常文件结束 </p>
<p>
    11行过长 </p>
<p>
    12缺类型标识符 </p>
<p>
    13打开文件过多 </p>
<p>
    14无效文件名 </p>
<p>
    15文件未找到 </p>
<p>
    16磁盘满 </p>
<p>
    17无效编译指示 </p>
<p>
    18文件过多 </p>
<p>
    19指针定义中未定义类型 </p>
<p>
    20缺变量标识符 </p>
<p>
    21类型错误 </p>
<p>
    22结构过长 </p>
<p>
    24文件分量不能为文件 </p>
<p>
    25无效字符串长度 </p>
<p>
    26类型不匹配 </p>
<p>
    27无效子界基类型 </p>
<p>
    28下界大于上界 </p>
<p>
    29缺有序类型 </p>
<p>
    30缺整型常数 </p>
<p>
    31缺常数 </p>
<p>
    32缺整型或实型常数 </p>
<p>
    33缺指针类型标识符 </p>
<p>
    34无效的函数结果类型 </p>
<p>
    35缺标号标识符 </p>
<p>
    36缺BEGIN </p>
<p>
    37缺END </p>
<p>
    38缺整型表达式 </p>
<p>
    39缺有序表达式 </p>
<p>
    40缺布尔表达式 </p>
<p>
    41操作数类型与操作符不匹配 </p>
<p>
    42表达式错 </p>
<p>
    43非法赋值 </p>
<p>
    44缺字段标识符 </p>
<p>
    45目标文件过长 </p>
<p>
    46未定义外部标识符 </p>
<p>
    47无效*.OBJ文件记录 </p>
<p>
    48代码段过长 </p>
<p>
    49数据段过长 </p>
<p>
    50缺DO </p>
<p>
    51无效PUBLIC定义 </p>
<p>
    52无效EXTRN定义 </p>
<p>
    53EXTRN定义过多 </p>
<p>
    54缺0F </p>
<p>
    55缺INTERFACE </p>
<p>
    56无效重定位引用 </p>
<p>
    57缺THEN </p>
<p>
    58缺T0或DOWNTO </p>
<p>
    59未定义的向前引用 </p>
<p>
    60过程过多 </p>
<p>
    61无效类型转换 </p>
<p>
    62被零除D </p>
<p>
    63无效文件类型 </p>
<p>
    64不能读写该类型的变量 </p>
<p>
    65缺指针变量 </p>
<p>
    66缺字符串变量 </p>
<p>
    67缺字符串表达式 </p>
<p>
    68单元循环引用 </p>
<p>
    69单元名不匹配 </p>
<p>
    70单元版本不匹配 </p>
<p>
    71单元重名 </p>
<p>
    72单元文件格式错误 </p>
<p>
    73缺IMPLEMENTATl0N </p>
<p>
    74常数与CASE类型不相匹配 </p>
<p>
    75缺记录变量 </p>
<p>
    76常数越界 </p>
<p>
    77缺文件变量 </p>
<p>
    78缺指针变量 </p>
<p>
    79缺整型或实型表达式 </p>
<p>
    80标号不在当前块中 </p>
<p>
    81标号已定义 </p>
<p>
    82标号未定义 </p>
<p>
    83无效参数 </p>
<p>
    84缺UNIT </p>
<p>
    85缺“；” </p>
<p>
    86缺“：” </p>
<p>
    87缺“，” </p>
<p>
    88缺“(” </p>
<p>
    89缺“)” </p>
<p>
    90缺“＝” </p>
<p>
    91缺“：＝” </p>
<p>
    92缺“[”或“(．” </p>
<p>
    93缺“]”或“．)” </p>
<p>
    94缺“．” </p>
<p>
    96变量过多 </p>
<p>
    97无效FOR控制变量 </p>
<p>
    98缺整型变量 </p>
<p>
    99此处不允许用文件和 </p>
<p>
    100字符串长度不匹配 </p>
<p>
    101无效字顺序 </p>
<p>
    102缺字符串常数 </p>
<p>
    103缺整型或实型变量 </p>
<p>
    104缺有序变量 </p>
<p>
    105INLINE错 </p>
<p>
    106缺字符表达式 </p>
<p>
    107重定位项过多 </p>
<p>
    112CASE常量越界 </p>
<p>
    113语句错 </p>
<p>
    114不能调用中断过程 </p>
<p>
    116必须在8087方式下编译 </p>
<p>
    117末找到目标地址 </p>
<p>
    118此处不允许包含文件 </p>
<p>
    120缺NIL </p>
<p>
    121无效限定符 </p>
<p>
    122无效变量引用 </p>
<p>
    123符号过多 </p>
<p>
    124语句部分过长 </p>
<p>
    126文件必须为变量参数 </p>
<p>
    127条件符号过多 </p>
<p>
    128条件指令错位 </p>
<p>
    130初始条件定义错 </p>
<p>
    13l过程和函数头与前面定义的不匹酉 </p>
<p>
    132严重磁盘错误 </p>
<p>
    133不能计算该表达式 </p>
<p>
    134表达式错误结束 </p>
<p>
    l35无效格式说明符 </p>
<p>
    136无效间接引用 </p>
<p>
    137此处不允许结构变量 </p>
<p>
    138无SYSTEM单元不能计算 </p>
<p>
    l39不能存取该符号 </p>
<p>
    140无效浮点运算 </p>
<p>
    141不能将覆盖编译至内存 </p>
<p>
    142缺过程和函数变量 </p>
<p>
    143无效过程或函数引用 </p>
<p>
    144不能覆盖该单元 </p>
<p>
    147缺对象类型 </p>
<p>
    148不允许局部对象类型 </p>
<p>
    149缺VIRTUAL </p>
<p>
    150缺方法标识符 </p>
<p>
    151不允许虚拟构造方法 </p>
<p>
    152缺构造方法标识符 </p>
<p>
    153缺释放方法标识符 </p>
<p>
    154FAIL只允许在构造方法内使用 </p>
<p>
    155无效的操作符和操作数组合 </p>
<p>
    156缺内存引用 </p>
<p>
    l57不能加减可重定位符号 </p>
<p>
    158无效寄存器组合 </p>
<p>
    159未激活286／287指令 </p>
<p>
    160无效符号引用 </p>
<p>
    161代码生成错 </p>
<p>
    162缺ASM </p>
<p>
  </p>
<p>
    扩展阅读： </p>
<p>
    1.ASCII码众所周知全称为“美国信息交换标准码，American Standard Code for  Information Interchange”。 </p>
<p>
    2.实例 </p>
<p>
    3.让我们到幕后去看看，看看ASCII码是如何以数字形式表示文本的。举2个例子： </p>
<p>
    4.(1) ASCII码'A' -- 其内存存储字节2进制表示为&quot;01000001&quot; --- 其16进制值为0x41 --- 其10进制值为65(这里的值实际上是'A'在ASCII码表中编号)； </p>
<p>
    5.验证过程： </p>
<p>
    6.char c = 'A'; </p>
<p>
    7.printf(&quot;%c\n&quot;, c);/* A */ </p>
<p>
    8.printf(&quot;%x\n&quot;, c);/* 41 */ </p>
<p>
    9.printf(&quot;%d\n&quot;, c);/* 65 */ </p>
<p>
    10.(2) ASCII码'6' -- 其内存存储字节2进制表示为&quot;00110110&quot; --- 其16进制值为0x36 --- 其10进制值为54(这里的值实际上是'6'在ASCII码表中的编号)； </p>
<p>
    11.char c = '6'; </p>
<p>
    12.printf(&quot;%c\n&quot;, c);/* 6 */ </p>
<p>
    13.printf(&quot;%x\n&quot;, c);/* 36 */ </p>
<p>
    14.printf(&quot;%d\n&quot;, c);/* 54 */ </p>
<p>
    15.ASCII码通讯 </p>
<p>
    16.利用ASCII码作为通讯方式到底是一种什么样的通讯方式呢？（FTP协议中有两种通讯方式，其中一种是ASCII码方式，即文本方式）这里也举例说明：比如我们要传送数值123, 123数值用16进制表示为0x7b，以二进制表示为01111011，那么以二进制方式通讯，01111011就是我们真实传送的数据，但是如果以ASCII码方式通讯，则完全不同了，如果你还传送01111011的话，对方那边的得到的将是'{'('{'对应的ASCII码用16进制表示为7b)。那么我们该如何怎么传呢？正确的方式就是将123每位上的数字转化为其相应的ASCII码，然后传送。这里'1'、'2'和'3'对应的ASCII码用16进制表示分别为0x31、0x32和0x33。这样组合起来后要传送的数据应为&quot;001100010011001000110011&quot;。 </p>
<p>
    从Turbo Pascal到Delphi<a name="11" id="11"></a> <a href="#section">回目录</a></p>
<p>
    我是在高一接触pascal语言，因为参加NOI的需要，顺理成章的要使用Turbo Pascal来写程序了。半年后，我开始想着如何编写Windows程序，又理所当然的找上Delphi。初见Delphi，除了begin，end让我觉得倍感亲切外，Object Pascal里的增加的面向对象的语法却让我很是吃惊，当时的我可根本不懂什么叫面向过程，面向对象；最可恶的是，国内那些教育家们，除了会拿着清华的那本精简的不能再精简的pascal教材照本宣科外，似乎再也没有什么实质性的工作了，传说中的《Turbo  Pascal大全》更是无处可寻，所以关于unit，interface这些Delphi里随处可见的关键字我也很不明白。所幸，其后不久，我得到一本名为《计算机反病毒技术》的书，里面统统都是用Turbo Pascal编写的源代码，通过它我迅速明白了早已存在于Turbo Pascal中unit，interface等关键字的含义和用法，又以Delphi中的Help文档为扶手，开始蹒跚学步了。&nbsp;</p>
<p>
    印象中，国内Delphi作家似乎更偏爱编写应用实例类的技术书籍，至于语法这种东西，没有几个人愿意多去涉及，即使书中必须谈及，也是寥寥数笔，匆匆带过，或者干脆与某本书类似。对Object Pascal语法讲解最好，最权威的恐怕就算《Delphi5开发人员指南》了，这本书至今也是备受推崇的。但与如今泛滥的C++书籍相比，Delphi仍然逊色许多，也难怪很多新手特别是从来没有接触过pascal语言的新手，在学习Object Pascal时会遇到不少困难。自己的感觉是：在从Turbo Pascal向Delphi过渡的过程中，由于没有正确的指引，走了很多弯路；由于没有正确的桥梁，必须要一步实现大跨越。所以，在这里，我提出自己曾经遇见的沟壑，路标性给出我自己的认识和总结，希望给入门的同学们一些帮助。我不打算详细介绍语法知识，并假设你已经有一点pascal语言和面向对象概念的基础。要想学习相关详细知识，我推荐各位一定要阅读《Delphi开发人员指南》和Delphi Help文档中的相关章节。&nbsp;</p>
<p>
    ●&nbsp;&nbsp;&nbsp;&nbsp; Record，Class，Object</p>
<p>
    习惯了在一个Program模块内写完所有面向过程代码的我，有几天的时间一直未能彻底明白在非Unit模块中，自定义类的框架，语法是如何的，VCL源代码虽然经典，却过于繁杂，不能让我迅速掌握根本，我需要一个最简单又最能说明问题，完整的可运行的代码，苦于无处寻求答案，只好亲自动手，探索对应关系，终成其下两段代码。&nbsp;</p>
<p>
    program TP;</p>
<p>
    {本代码在Turbo Pascal 7.0下编译通过}&nbsp;</p>
<p>
    type</p>
<p>
  &nbsp; MyRecord = record</p>
<p>
  &nbsp;&nbsp;&nbsp;&nbsp; {...}</p>
<p>
  &nbsp; end;&nbsp;</p>
<p>
    var</p>
<p>
  &nbsp; MR: MyRecord;</p>
<p>
  &nbsp; procedure MyProcedure;</p>
<p>
  &nbsp; begin</p>
<p>
  &nbsp;&nbsp;&nbsp; {MyProcedure Code}</p>
<p>
  &nbsp; end;</p>
<p>
    {=========== main ===========}</p>
<p>
    begin</p>
<p>
    {以这个begin为标志，主程序开始，其作用相当于C/C++中的main函数}</p>
<p>
  &nbsp; MyProcedure;</p>
<p>
    end.&nbsp;</p>
<p>
    上面是一段极其简单的包含记录类型声明和过程声明的代码，二者基本规则如下：用户自定义的数据类型，需要放在以保留字“type”开头的代码段中；过程(procedure)和函数(function)要放在以保留字“var”开头的代码段中；最后一个夹在begin和end间的代码段是主程序的开始，也就是整个程序的入口，作用相当于C/C++里的main函数,请注意，只有在以program保留字开头的代码模块中，这个begin和end才具有程序入口的作用。&nbsp;</p>
<p>
    再看下面的代码：&nbsp;</p>
<p>
    program Delphi;</p>
<p>
    {代码在Delphi7.0下编译通过}&nbsp;</p>
<p>
    {$APPTYPE CONSOLE}&nbsp;</p>
<p>
    uses</p>
<p>
  &nbsp; SysUtils;&nbsp;</p>
<p>
    type</p>
<p>
    TMyClass = class(TObject)</p>
<p>
  &nbsp; public</p>
<p>
  &nbsp;&nbsp;&nbsp; constructor Create;</p>
<p>
  &nbsp;&nbsp;&nbsp; procedure PrintClassName;</p>
<p>
  &nbsp; private</p>
<p>
  &nbsp;&nbsp;&nbsp; ClassName: string;</p>
<p>
  &nbsp; end;&nbsp;</p>
<p>
    var</p>
<p>
  &nbsp; MyClass: TMyClass;&nbsp;</p>
<p>
  &nbsp; constructor TMyClass.Create;</p>
<p>
  &nbsp; begin</p>
<p>
  &nbsp;&nbsp;&nbsp; ClassName := 'TMyClass';</p>
<p>
  &nbsp; end;&nbsp;</p>
<p>
  &nbsp; procedure TMyClass.PrintClassName;</p>
<p>
  &nbsp; begin</p>
<p>
  &nbsp;&nbsp;&nbsp; writeln(ClassName);</p>
<p>
  &nbsp; end;&nbsp;</p>
<p>
    {=========== main ===========}</p>
<p>
    begin</p>
<p>
  &nbsp; MyClass := TMyClass.Create;</p>
<p>
  &nbsp; MyClass.PrintClassName;</p>
<p>
  &nbsp; MyClass.Free;</p>
<p>
  &nbsp; readln;</p>
<p>
    end.&nbsp;</p>
<p>
    类作为用户自定义的一种数据类型，其声明的规则，成员函数、过程的实现方法都符合经典 Pascal的基本规则，唯一不同的是保留字变了，从记录体变成了类（详细比较代码结构和语法规则），这也说明Object Pascal是在经典Pascal的基础上进行了面向对象内容的语法扩充。当然，内部的运行机制并没有表面语法扩充这么轻松，可那是编译器的事情，在这里，我们完全不用理会。差点忘记告诉读者怎么调试上面的代码了：在IDE环境主菜单里选择 File | New | Other ，在New Item项里选择Console Application，这时出现了代码编辑框，再将上面的代码贴入，F9，完成！&nbsp;</p>
<p>
    代码内的{$APPTYPE CONSOLE}是一个编译开关，它告诉编译器，这是控制台程序，在格式上它与注释的差别就是那个“$”符号；TMyClass = class(TObject)可以简写为 </p>
<p>
    TMyClass = class，表示TMyClass类从TObject类继承而来，TObject是Delpi中所有类的祖先，这也是为什么我在代码中没有声明Destroy过程却仍然能够使用的原因；Delphi中类的构造很有趣，请注意MyClass := TMyClass.Create这一句，这与C++不同[注1]。readln使程序停顿下来，直到用户按下回车键才结束程序退出。更多详细内容请参考《Delphi开发人员指南》2.17.1节。&nbsp;</p>
<p>
  &nbsp;&nbsp; 上面两段代码相互对应，虽然很简单，不过我却认为他们在某种程度上很容易让同学发现由经典Pascal向Object Pascal过渡的一些方法，对Object Pascal的类定义语法有个初步了解，这是很重要的一步。当初我要是能够看到这两段代码，或许能少浪费很多时间了。&nbsp;</p>
<p>
    另外，在TP5.5 –Delphi 7.0中都支持Object类型（对象类型）。语法如下：&nbsp;</p>
<p>
    object</p>
<p>
    Field;</p>
<p>
    Field;</p>
<p>
    ...</p>
<p>
    Method;</p>
<p>
    Method;</p>
<p>
    end;&nbsp;</p>
<p>
    Method允许以下几种形式： </p>
<p>
    procedure  MethodName(&lt;parameter(s)&gt;:type);</p>
<p>
    或者function  MethodName(&lt;parameter(s)&gt;:type):type;</p>
<p>
    或者constructor MethodName(&lt;parameter(s)&gt;: type  [;&lt;parameter(s)&gt;:type]); [virtual];</p>
<p>
    或者destructor MethodName[(&lt;parameters&gt;:  type)];[virtual];&nbsp;</p>
<p>
    不错的，构造函数和析构函数都支持virtual，在构造函数中，还有一个有用的东西是Fail函数，当构造函数的初始化失败时，它可以用来释放已经分配的资源。&nbsp;</p>
<p>
    接下来的代码，是Turbo Pascal的Help文档中，关于Fail函数的演示代码，可以让大家对此有个较深的认识。Turbo Pascal确实是很强大和优秀的。&nbsp;</p>
<p>
    type</p>
<p>
  &nbsp;PBase = ^TBase;</p>
<p>
  &nbsp;TBase = object(TObject)&nbsp; {在这里就已经出现Tobject了，是不是很亲切？}</p>
<p>
  &nbsp;&nbsp; constructor Init(FailMe: Boolean);</p>
<p>
  &nbsp;end;&nbsp;</p>
<p>
  &nbsp;PDerived = ^TDerived;</p>
<p>
  &nbsp;TDerived = object(TBase)</p>
<p>
  &nbsp;&nbsp; constructor Init(FailMe: Boolean);</p>
<p>
  &nbsp;end;&nbsp;</p>
<p>
    constructor TBase.Init(FailMe: Boolean);</p>
<p>
    begin</p>
<p>
  &nbsp;inherited Init;</p>
<p>
  &nbsp;if FailMe then Fail;</p>
<p>
    end;&nbsp;</p>
<p>
    constructor TDerived.Init(FailMe: Boolean);</p>
<p>
    begin</p>
<p>
  &nbsp;if not inherited Init(FailMe) then </p>
<p>
    {判断父类的初始化是否成功}</p>
<p>
  &nbsp;&nbsp; { Ancestor failed to construct, we must fail  too }</p>
<p>
  &nbsp;&nbsp; Fail;</p>
<p>
  &nbsp;{ Otherwise, proceed with construction }</p>
<p>
  &nbsp;{...}</p>
<p>
    end;&nbsp;</p>
<p>
    var</p>
<p>
  &nbsp;P: PObject;</p>
<p>
  &nbsp;X: Boolean;</p>
<p>
    begin</p>
<p>
  &nbsp;for X := False to True do</p>
<p>
  &nbsp;begin</p>
<p>
  &nbsp;&nbsp; P := New(PDerived, Init(X));</p>
<p>
  &nbsp;&nbsp; if P &lt;&gt; nil then</p>
<p>
  &nbsp;&nbsp; begin</p>
<p>
  &nbsp;&nbsp;&nbsp;&nbsp; writeln('Object constructed  sucessfully');</p>
<p>
  &nbsp;&nbsp;&nbsp;&nbsp; Dispose(P, Done);</p>
<p>
  &nbsp;&nbsp; end</p>
<p>
  &nbsp;&nbsp; else</p>
<p>
  &nbsp;&nbsp;&nbsp;&nbsp; writeln('Object failed to  construct');</p>
<p>
  &nbsp;end;</p>
<p>
    end.&nbsp;</p>
<p>
    自定义的Object不一定要从Tobject继承下来，因此它也没有内建的构造、析构和其他方法，通常使用New过程和Dispose过程建立和销毁它的实例。Delphi中仍旧支持Object，并有property成员了，但是仍然不允许published。KOL[注2]也使用该类型实现自己的构架。但是对此关键字的保留主要是为了兼容，建议用户改用class关键字。&nbsp;</p>
<p>
    ●&nbsp; unit模块 </p>
<p>
    在Turbo Pascal的Help文档里，是这样说明unit功能的：Units are the basis of modular  programming inBorland Pascal. You use units to createlibraries and to divide  large programs into logically related modules。小规模的程序，我们可能将所有代码集中在一个program中，可是面对更加复杂的大型工程时，正确的划分功能封装功能对代码管理和以后的维护有着重要的作用，而使用unit模块正好解决了这些问题。其语法规则如下：&nbsp;</p>
<p>
    unit identifier;&nbsp; { Heading }&nbsp;</p>
<p>
  &nbsp;interface&nbsp; { Public symbols }:</p>
<p>
  &nbsp; uses&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Uses clause }</p>
<p>
  &nbsp; const&nbsp;&nbsp;&nbsp;&nbsp; { Constants }</p>
<p>
  &nbsp; type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Types }</p>
<p>
  &nbsp; var&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {  Variables }</p>
<p>
  &nbsp; procedure { Procedures }</p>
<p>
  &nbsp; function&nbsp; { Functions }&nbsp;</p>
<p>
  &nbsp;implementation&nbsp;&nbsp; { Private symbols }:</p>
<p>
  &nbsp;  uses&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Uses  clause }</p>
<p>
  &nbsp;  label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Labels }</p>
<p>
  &nbsp;  const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Constants }</p>
<p>
  &nbsp;  type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Types  }</p>
<p>
  &nbsp;  var&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {  Variables }</p>
<p>
  &nbsp; procedure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {  Procedures}</p>
<p>
  &nbsp; function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  { Functions }</p>
<p>
  &nbsp;begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  { Initialization }</p>
<p>
  &nbsp; statement;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {  Statements }</p>
<p>
  &nbsp;&nbsp;&nbsp; statement</p>
<p>
  &nbsp;end.&nbsp;</p>
<p>
    Interface部分用来声明对外接口，也就是可以被外部引用该文件的程序使用的函数和过程；implementation部分包含接口部分声明的各种函数、过程具体实现的代码；begin一直到最后的end.之间都是初始化部分，可以为本unit内的各种变量，过程，函数初始化。如果没有内容需要初始化，那么begin可以省略，但end.必须存在。&nbsp;</p>
<p>
    在Delphi下经典Pascal中的unit部分有了变动，请看来源于Delphi Help文档的说明： </p>
<p>
    unit Unit1;&nbsp;</p>
<p>
    interface&nbsp;</p>
<p>
    uses&nbsp; </p>
<p>
    { List of units goes here }&nbsp;</p>
<p>
  &nbsp; { Interface section goes here }&nbsp;</p>
<p>
    implementation&nbsp;</p>
<p>
    uses&nbsp; </p>
<p>
    { List of units goes here }&nbsp;</p>
<p>
  &nbsp; { Implementation section goes here }&nbsp;</p>
<p>
    initialization</p>
<p>
  &nbsp; { Initialization section goes here }&nbsp;</p>
<p>
    finalization</p>
<p>
  &nbsp; { Finalization section goes here }&nbsp;</p>
<p>
    end.&nbsp;</p>
<p>
    可见Initialization部分的开始关键字begin，被Initialization取代了，并且增加了一个finalization部分。Initialization部分的代码可以这样写：&nbsp;</p>
<p>
    initialization</p>
<p>
    begin</p>
<p>
  &nbsp; {do something…}</p>
<p>
    end;&nbsp;</p>
<p>
    也可以这样写：&nbsp;</p>
<p>
    initialization</p>
<p>
  &nbsp; {do something…}&nbsp;</p>
<p>
    finalization部分的功能，有点类似于析构函数，它主要针对本unit模块中initialization部分初始化的资源进行释放，并且是在程序结束时运行，如果程序以Halt过程结束了，该部分的程序将不能执行。&nbsp;</p>
<p>
    Unit模块中的interface等关键字和结构初看似乎有些限制程序员的自由度，但也正是这种语法规定体现出Pascal语言的严谨和优美，为减少程序出错的几率做出保证。&nbsp;</p>
<p>
    program相当文章的提纲挈领，unit则是文章的各个段落。Delphi里，program模块包含在.prj文件中，unit模块包含在传统的.pas文件中。这就是为什么在Delphi中我们经常面对的是为各个窗口服务的unit模块，而非在一个program中写完所有代码。不过我在Delphi的Help中看到这样一句话：In  traditional Pascal programming, all source code, including the main program, is  stored in .pas files.不知道这算思考角度不同还是算bug，毕竟这种语法并非Delphi中才有，Turbo Pascal程序员也一直在采用这种方法组织程序结构。&nbsp;</p>
<p>
    给出一个简单的initialization例子。在菜单中选择File | New |  Application，再在窗体上放置一个按钮，双击该按钮编写它的Click事件处理代码，完整代码如下：&nbsp;</p>
<p>
    unit Unit1;&nbsp;</p>
<p>
    interface&nbsp;</p>
<p>
    uses</p>
<p>
  &nbsp; Windows, Messages, SysUtils, Variants, Classes,  Graphics, Controls, Forms,</p>
<p>
  &nbsp; Dialogs, StdCtrls;&nbsp;</p>
<p>
    type</p>
<p>
  &nbsp; TForm1 = class(TForm)</p>
<p>
  &nbsp;&nbsp;&nbsp; Button1: TButton;</p>
<p>
  &nbsp;&nbsp;&nbsp; procedure Button1Click(Sender:  TObject);</p>
<p>
  &nbsp; private</p>
<p>
  &nbsp;&nbsp;&nbsp; { Private declarations }</p>
<p>
  &nbsp; public</p>
<p>
  &nbsp;&nbsp;&nbsp; { Public declarations }</p>
<p>
  &nbsp; end;&nbsp;</p>
<p>
    var</p>
<p>
  &nbsp; Form1: TForm1;</p>
<p>
  &nbsp; Msg: string;&nbsp;</p>
<p>
    implementation&nbsp;</p>
<p>
    {$R *.dfm}&nbsp;</p>
<p>
    procedure TForm1.Button1Click(Sender: TObject);</p>
<p>
    begin</p>
<p>
  &nbsp; ShowMessage(Msg);</p>
<p>
  &nbsp; Msg := 'second';</p>
<p>
    end;&nbsp;</p>
<p>
    initialization</p>
<p>
  &nbsp; Msg := 'first';&nbsp;</p>
<p>
    end.&nbsp;</p>
<p>
  &nbsp;&nbsp; 以上所述，是过渡中两个基本的重要问题，弄懂它们方可初步明白自己为什么要这样编写代码，该在哪里编写代码，如何扩展代码功能。&nbsp;</p>
<p>
    ●&nbsp; 我推荐的参考书籍&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>
  &nbsp;&nbsp;&nbsp;&nbsp; Delphi参考书籍 </p>
<p>
    《Delphi 5 开发人员指南》机械工业出版社 </p>
<p>
    《Inside VCL》李维 电子工业出版社 </p>
<p>
    《Delphi深度历险》陈宽达 科学出版社 </p>
<p>
    《Pascal精要》网络下载电子版&nbsp;</p>
<p>
    Windows参考书籍 </p>
<p>
    《Programming Windows》Charles Petzold</p>
<p>
    《Windows2000开发人员指南》中国水利水电出版社&nbsp;</p>
<p>
    Delphi组件参考书我暂时没有发现特别好的，平时我主要依靠论坛，源代码，Delphi自带的Demo和文档来学习组件的使用。&nbsp;</p>
<p>
    ●&nbsp;&nbsp;&nbsp;&nbsp; 再说点 </p>
<p>
    现在有一些大学取消了Pascal语言课程，去年的ACM大赛也取消了Pascal语言的使用，不禁心寒，启蒙教育没有人做了，这些都使得Delphi在学生中的处境更加艰难。在国内的Delphi论坛上，常常见到许多半吊子程序员在享受Delphi的快速开发的时候，嘴巴里还在责备Delphi功能太弱，不能搞什么底层开发，甚至直接责怪Pascal语言，殊不知，在Dos年代，有多少著名软件使用Pascal开发出来的呢，有多少底层控制程序有着Pascal的身影呢？现在我手头上还有Pascal编写的病毒代码，反病毒代码，IC芯片控制代码。&nbsp;</p>
<p>
    或许正是Delphi的RAD能力降低了程序开发的门槛，让很多半吊子进入了程序界，RAD开发蒙蔽了许多半吊子编程者（称呼他们为程序员或许稍欠火候）的眼睛，但是国内的教育界同样有着不可推卸的责任，选修课开VB的不少，讲Delphi的很少，我曾经还遇到过一个从心底里就瞧不起Delphi，不啻谈论的老师，而事实上他根本就没有用过Delphi。我现在常去外国网站，发现国内被争论不休的问题，在国外早就有人在做，并且做的非常棒。&nbsp;</p>
<p>
    似乎我在为Delphi翻案，不停的维护它，没辙，谁要我是它的fans呢，人总要有点信仰，喜好不是吗？所以我认为，与其花时间咒骂一个工具的“不足之处”，不如花时间研究如何解决这个问题。&nbsp;</p>
<p>
    参考文献<a name="13" id="13"></a> <a href="#section">回目录</a> </p>
<p>
  <a href="http://zh.wikipedia.org/wiki/Turbo_Pascal">http://zh.wikipedia.org/wiki/Turbo_Pascal</a></p>
<p>
  <a href="http://en.wikipedia.org/wiki/Turbo_Pascal">http://en.wikipedia.org/wiki/Turbo_Pascal</a></p>


</div>
</body>
</html>
